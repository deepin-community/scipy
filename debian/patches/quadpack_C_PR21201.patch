From d074be3b82eb4a65a141c1bd7ca367ac158bb524 Mon Sep 17 00:00:00 2001
From: Ilhan Polat <ilhanpolat@gmail.com>
Date: Tue, 16 Jul 2024 13:37:32 +0200
Subject: [PATCH 1/7] MAINT:integrate: Remove FORTRAN QUADPACK

---
 scipy/integrate/quadpack/changes    |   5 -
 scipy/integrate/quadpack/disclaimer |  10 -
 scipy/integrate/quadpack/doc        | 477 ------------------------
 scipy/integrate/quadpack/dqag.f     | 182 ---------
 scipy/integrate/quadpack/dqage.f    | 340 -----------------
 scipy/integrate/quadpack/dqagi.f    | 191 ----------
 scipy/integrate/quadpack/dqagie.f   | 452 -----------------------
 scipy/integrate/quadpack/dqagp.f    | 225 ------------
 scipy/integrate/quadpack/dqagpe.f   | 550 ----------------------------
 scipy/integrate/quadpack/dqags.f    | 188 ----------
 scipy/integrate/quadpack/dqagse.f   | 444 ----------------------
 scipy/integrate/quadpack/dqawc.f    | 178 ---------
 scipy/integrate/quadpack/dqawce.f   | 326 -----------------
 scipy/integrate/quadpack/dqawf.f    | 231 ------------
 scipy/integrate/quadpack/dqawfe.f   | 363 ------------------
 scipy/integrate/quadpack/dqawo.f    | 225 ------------
 scipy/integrate/quadpack/dqawoe.f   | 531 ---------------------------
 scipy/integrate/quadpack/dqaws.f    | 200 ----------
 scipy/integrate/quadpack/dqawse.f   | 370 -------------------
 scipy/integrate/quadpack/dqc25c.f   | 161 --------
 scipy/integrate/quadpack/dqc25f.f   | 355 ------------------
 scipy/integrate/quadpack/dqc25s.f   | 337 -----------------
 scipy/integrate/quadpack/dqcheb.f   | 148 --------
 scipy/integrate/quadpack/dqelg.f    | 184 ----------
 scipy/integrate/quadpack/dqk15.f    | 174 ---------
 scipy/integrate/quadpack/dqk15i.f   | 196 ----------
 scipy/integrate/quadpack/dqk15w.f   | 180 ---------
 scipy/integrate/quadpack/dqk21.f    | 182 ---------
 scipy/integrate/quadpack/dqk31.f    | 191 ----------
 scipy/integrate/quadpack/dqk41.f    | 207 -----------
 scipy/integrate/quadpack/dqk51.f    | 220 -----------
 scipy/integrate/quadpack/dqk61.f    | 231 ------------
 scipy/integrate/quadpack/dqmomo.f   | 127 -------
 scipy/integrate/quadpack/dqng.f     | 375 -------------------
 scipy/integrate/quadpack/dqpsrt.f   | 130 -------
 scipy/integrate/quadpack/dqwgtc.f   |  18 -
 scipy/integrate/quadpack/dqwgtf.f   |  20 -
 scipy/integrate/quadpack/dqwgts.f   |  27 --
 scipy/integrate/quadpack/index      | 304 ---------------
 scipy/integrate/quadpack/permission |   1 -
 scipy/integrate/quadpack/readme     | 104 ------
 41 files changed, 9360 deletions(-)
 delete mode 100644 scipy/integrate/quadpack/changes
 delete mode 100644 scipy/integrate/quadpack/disclaimer
 delete mode 100644 scipy/integrate/quadpack/doc
 delete mode 100644 scipy/integrate/quadpack/dqag.f
 delete mode 100644 scipy/integrate/quadpack/dqage.f
 delete mode 100644 scipy/integrate/quadpack/dqagi.f
 delete mode 100644 scipy/integrate/quadpack/dqagie.f
 delete mode 100644 scipy/integrate/quadpack/dqagp.f
 delete mode 100644 scipy/integrate/quadpack/dqagpe.f
 delete mode 100644 scipy/integrate/quadpack/dqags.f
 delete mode 100644 scipy/integrate/quadpack/dqagse.f
 delete mode 100644 scipy/integrate/quadpack/dqawc.f
 delete mode 100644 scipy/integrate/quadpack/dqawce.f
 delete mode 100644 scipy/integrate/quadpack/dqawf.f
 delete mode 100644 scipy/integrate/quadpack/dqawfe.f
 delete mode 100644 scipy/integrate/quadpack/dqawo.f
 delete mode 100644 scipy/integrate/quadpack/dqawoe.f
 delete mode 100644 scipy/integrate/quadpack/dqaws.f
 delete mode 100644 scipy/integrate/quadpack/dqawse.f
 delete mode 100644 scipy/integrate/quadpack/dqc25c.f
 delete mode 100644 scipy/integrate/quadpack/dqc25f.f
 delete mode 100644 scipy/integrate/quadpack/dqc25s.f
 delete mode 100644 scipy/integrate/quadpack/dqcheb.f
 delete mode 100644 scipy/integrate/quadpack/dqelg.f
 delete mode 100644 scipy/integrate/quadpack/dqk15.f
 delete mode 100644 scipy/integrate/quadpack/dqk15i.f
 delete mode 100644 scipy/integrate/quadpack/dqk15w.f
 delete mode 100644 scipy/integrate/quadpack/dqk21.f
 delete mode 100644 scipy/integrate/quadpack/dqk31.f
 delete mode 100644 scipy/integrate/quadpack/dqk41.f
 delete mode 100644 scipy/integrate/quadpack/dqk51.f
 delete mode 100644 scipy/integrate/quadpack/dqk61.f
 delete mode 100644 scipy/integrate/quadpack/dqmomo.f
 delete mode 100644 scipy/integrate/quadpack/dqng.f
 delete mode 100644 scipy/integrate/quadpack/dqpsrt.f
 delete mode 100644 scipy/integrate/quadpack/dqwgtc.f
 delete mode 100644 scipy/integrate/quadpack/dqwgtf.f
 delete mode 100644 scipy/integrate/quadpack/dqwgts.f
 delete mode 100644 scipy/integrate/quadpack/index
 delete mode 100644 scipy/integrate/quadpack/permission
 delete mode 100644 scipy/integrate/quadpack/readme

Index: scipy/scipy/integrate/quadpack/changes
===================================================================
--- scipy.orig/scipy/integrate/quadpack/changes	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-1 Aug 86  ehg
-  qwgt*.f were declared double precision, but should have been single
-
-21 May 87  ehg, reported by dongarra
-  dqc25c.f was missing data x(11).  copied from dqc25s.f
Index: scipy/scipy/integrate/quadpack/disclaimer
===================================================================
--- scipy.orig/scipy/integrate/quadpack/disclaimer	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,10 +0,0 @@
-This version obtained on 1 Jun 84 from    (kahaner@nbs-sdc)
-   David K. Kahaner
-   Scientific Computing Division
-   National Bureau of Standards
-   Washington DC 20234
-
-WARNING: the calling sequences here differ from those in the book:
-  R. Piessens, E. deDoncker-Kapenga, C. Uberhuber, D. Kahaner
-  Quadpack: a Subroutine Package for Automatic Integration
-  Springer Verlag, 1983.    Series in Computational Mathematics v.1
Index: scipy/scipy/integrate/quadpack/doc
===================================================================
--- scipy.orig/scipy/integrate/quadpack/doc	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,477 +0,0 @@
-See also:
-  R. Piessens, E. deDoncker-Kapenga, C. Uberhuber, D. Kahaner
-  Quadpack: a Subroutine Package for Automatic Integration
-  Springer Verlag, 1983.    Series in Computational Mathematics v.1
-  515.43/Q1S  100394Z
-
-      SUBROUTINE QPDOC
-C***BEGIN PROLOGUE  QPDOC
-C***DATE WRITTEN   810401   (YYMMDD)
-C***REVISION DATE  840417   (YYMMDD)
-C***CATEGORY NO.  H2
-C***KEYWORDS  SURVEY OF INTEGRATORS, GUIDELINES FOR SELECTION,QUADPACK
-C***AUTHOR  PIESSENS, ROBERT(APPL. MATH. AND PROGR. DIV.- K.U.LEUVEN)
-C           DE DONKER, ELISE(APPL. MATH. AND PROGR. DIV.- K.U.LEUVEN
-C           KAHANER,DAVID(NATIONAL BUREAU OF STANDARDS)
-C***PURPOSE  QUADPACK documentation routine.
-C***DESCRIPTION
-C 1. Introduction
-C    ------------
-C    QUADPACK is a FORTRAN subroutine package for the numerical
-C    computation of definite one-dimensional integrals. It originated
-C    from a joint project of R. Piessens and E. de Doncker (Appl.
-C    Math. and Progr. Div.- K.U.Leuven, Belgium), C. Ueberhuber (Inst.
-C    Fuer Math.- Techn.U.Wien, Austria), and D. Kahaner (Nation. Bur.
-C    of Standards- Washington D.C., U.S.A.).
-C    Documentation routine QPDOC describes the package in the form it
-C    was released from A.M.P.D.- Leuven, for adherence to the SLATEC
-C    library in May 1981. Apart from a survey of the integrators, some
-C    guidelines will be given in order to help the QUADPACK user with
-C    selecting an appropriate routine or a combination of several
-C    routines for handling his problem.
-C
-C    In the LONG DESCRIPTION of QPDOC it is demonstrated how to call
-C    the integrators, by means of small example calling programs.
-C
-C    For precise guidelines involving the use of each routine in
-C    particular, we refer to the extensive introductory comments
-C    within each routine.
-C
-C 2. Survey
-C    ------
-C    The following list gives an overview of the QUADPACK integrators.
-C    The routine names for the DOUBLE PRECISION versions are preceded
-C    by the letter D.
-C
-C    - QNG  : Is a simple non-adaptive automatic integrator, based on
-C             a sequence of rules with increasing degree of algebraic
-C             precision (Patterson, 1968).
-C
-C    - QAG  : Is a simple globally adaptive integrator using the
-C             strategy of Aind (Piessens, 1973). It is possible to
-C             choose between 6 pairs of Gauss-Kronrod quadrature
-C             formulae for the rule evaluation component. The pairs
-C             of high degree of precision are suitable for handling
-C             integration difficulties due to a strongly oscillating
-C             integrand.
-C
-C    - QAGS : Is an integrator based on globally adaptive interval
-C             subdivision in connection with extrapolation (de Doncker,
-C             1978) by the Epsilon algorithm (Wynn, 1956).
-C
-C    - QAGP : Serves the same purposes as QAGS, but also allows
-C             for eventual user-supplied information, i.e. the
-C             abscissae of internal singularities, discontinuities
-C             and other difficulties of the integrand function.
-C             The algorithm is a modification of that in QAGS.
-C
-C    - QAGI : Handles integration over infinite intervals. The
-C             infinite range is mapped onto a finite interval and
-C             then the same strategy as in QAGS is applied.
-C
-C    - QAWO : Is a routine for the integration of COS(OMEGA*X)*F(X)
-C             or SIN(OMEGA*X)*F(X) over a finite interval (A,B).
-C             OMEGA is specified by the user
-C             The rule evaluation component is based on the
-C             modified Clenshaw-Curtis technique.
-C             An adaptive subdivision scheme is used connected with
-C             an extrapolation procedure, which is a modification
-C             of that in QAGS and provides the possibility to deal
-C             even with singularities in F.
-C
-C    - QAWF : Calculates the Fourier cosine or Fourier sine
-C             transform of F(X), for user-supplied interval (A,
-C             INFINITY), OMEGA, and F. The procedure of QAWO is
-C             used on successive finite intervals, and convergence
-C             acceleration by means of the Epsilon algorithm (Wynn,
-C             1956) is applied to the series of the integral
-C             contributions.
-C
-C    - QAWS : Integrates W(X)*F(X) over (A,B) with A.LT.B finite,
-C             and   W(X) = ((X-A)**ALFA)*((B-X)**BETA)*V(X)
-C             where V(X) = 1 or LOG(X-A) or LOG(B-X)
-C                            or LOG(X-A)*LOG(B-X)
-C             and   ALFA.GT.(-1), BETA.GT.(-1).
-C             The user specifies A, B, ALFA, BETA and the type of
-C             the function V.
-C             A globally adaptive subdivision strategy is applied,
-C             with modified Clenshaw-Curtis integration on the
-C             subintervals which contain A or B.
-C
-C    - QAWC : Computes the Cauchy Principal Value of F(X)/(X-C)
-C             over a finite interval (A,B) and for
-C             user-determined C.
-C             The strategy is globally adaptive, and modified
-C             Clenshaw-Curtis integration is used on the subranges
-C             which contain the point X = C.
-C
-C  Each of the routines above also has a "more detailed" version
-C    with a name ending in E, as QAGE.  These provide more
-C    information and control than the easier versions.
-C
-C
-C   The preceding routines are all automatic.  That is, the user
-C      inputs his problem and an error tolerance.  The routine
-C      attempts to perform the integration to within the requested
-C      absolute or relative error.
-C   There are, in addition, a number of non-automatic integrators.
-C      These are most useful when the problem is such that the
-C      user knows that a fixed rule will provide the accuracy
-C      required.  Typically they return an error estimate but make
-C      no attempt to satisfy any particular input error request.
-C
-C      QK15
-C      QK21
-C      QK31
-C      QK41
-C      QK51
-C      QK61
-C           Estimate the integral on [a,b] using 15, 21,..., 61
-C           point rule and return an error estimate.
-C      QK15I 15 point rule for (semi)infinite interval.
-C      QK15W 15 point rule for special singular weight functions.
-C      QC25C 25 point rule for Cauchy Principal Values
-C      QC25F 25 point rule for sin/cos integrand.
-C      QMOMO Integrates k-th degree Chebychev polynomial times
-C            function with various explicit singularities.
-C
-C 3. Guidelines for the use of QUADPACK
-C    ----------------------------------
-C    Here it is not our purpose to investigate the question when
-C    automatic quadrature should be used. We shall rather attempt
-C    to help the user who already made the decision to use QUADPACK,
-C    with selecting an appropriate routine or a combination of
-C    several routines for handling his problem.
-C
-C    For both quadrature over finite and over infinite intervals,
-C    one of the first questions to be answered by the user is
-C    related to the amount of computer time he wants to spend,
-C    versus his -own- time which would be needed, for example, for
-C    manual subdivision of the interval or other analytic
-C    manipulations.
-C
-C    (1) The user may not care about computer time, or not be
-C        willing to do any analysis of the problem. especially when
-C        only one or a few integrals must be calculated, this attitude
-C        can be perfectly reasonable. In this case it is clear that
-C        either the most sophisticated of the routines for finite
-C        intervals, QAGS, must be used, or its analogue for infinite
-C        intervals, GAGI. These routines are able to cope with
-C        rather difficult, even with improper integrals.
-C        This way of proceeding may be expensive. But the integrator
-C        is supposed to give you an answer in return, with additional
-C        information in the case of a failure, through its error
-C        estimate and flag. Yet it must be stressed that the programs
-C        cannot be totally reliable.
-C        ------
-C
-C    (2) The user may want to examine the integrand function.
-C        If bad local difficulties occur, such as a discontinuity, a
-C        singularity, derivative singularity or high peak at one or
-C        more points within the interval, the first advice is to
-C        split up the interval at these points. The integrand must
-C        then be examined over each of the subintervals separately,
-C        so that a suitable integrator can be selected for each of
-C        them. If this yields problems involving relative accuracies
-C        to be imposed on -finite- subintervals, one can make use of
-C        QAGP, which must be provided with the positions of the local
-C        difficulties. However, if strong singularities are present
-C        and a high accuracy is requested, application of QAGS on the
-C        subintervals may yield a better result.
-C
-C        For quadrature over finite intervals we thus dispose of QAGS
-C        and
-C        - QNG for well-behaved integrands,
-C        - QAG for functions with an oscillating behaviour of a non
-C          specific type,
-C        - QAWO for functions, eventually singular, containing a
-C          factor COS(OMEGA*X) or SIN(OMEGA*X) where OMEGA is known,
-C        - QAWS for integrands with Algebraico-Logarithmic end point
-C          singularities of known type,
-C        - QAWC for Cauchy Principal Values.
-C
-C        Remark
-C        ------
-C        On return, the work arrays in the argument lists of the
-C        adaptive integrators contain information about the interval
-C        subdivision process and hence about the integrand behaviour:
-C        the end points of the subintervals, the local integral
-C        contributions and error estimates, and eventually other
-C        characteristics. For this reason, and because of its simple
-C        globally adaptive nature, the routine QAG in particular is
-C        well-suited for integrand examination. Difficult spots can
-C        be located by investigating the error estimates on the
-C        subintervals.
-C
-C        For infinite intervals we provide only one general-purpose
-C        routine, QAGI. It is based on the QAGS algorithm applied
-C        after a transformation of the original interval into (0,1).
-C        Yet it may eventuate that another type of transformation is
-C        more appropriate, or one might prefer to break up the
-C        original interval and use QAGI only on the infinite part
-C        and so on. These kinds of actions suggest a combined use of
-C        different QUADPACK integrators. Note that, when the only
-C        difficulty is an integrand singularity at the finite
-C        integration limit, it will in general not be necessary to
-C        break up the interval, as QAGI deals with several types of
-C        singularity at the boundary point of the integration range.
-C        It also handles slowly convergent improper integrals, on
-C        the condition that the integrand does not oscillate over
-C        the entire infinite interval. If it does we would advise
-C        to sum succeeding positive and negative contributions to
-C        the integral -e.g. integrate between the zeros- with one
-C        or more of the finite-range integrators, and apply
-C        convergence acceleration eventually by means of QUADPACK
-C        subroutine QELG which implements the Epsilon algorithm.
-C        Such quadrature problems include the Fourier transform as
-C        a special case. Yet for the latter we have an automatic
-C        integrator available, QAWF.
-C
-C***LONG DESCRIPTION
-C 4. Example Programs
-C    ----------------
-C 4.1. Calling Program for QNG
-C      -----------------------
-C
-C            REAL A,ABSERR,B,F,EPSABS,EPSREL,RESULT
-C            INTEGER IER,NEVAL
-C            EXTERNAL F
-C            A = 0.0E0
-C            B = 1.0E0
-C            EPSABS = 0.0E0
-C            EPSREL = 1.0E-3
-C            CALL QNG(F,A,B,EPSABS,EPSREL,RESULT,ABSERR,NEVAL,IER)
-C      C  INCLUDE WRITE STATEMENTS
-C            STOP
-C            END
-C      C
-C            REAL FUNCTION F(X)
-C            REAL X
-C            F = EXP(X)/(X*X+0.1E+01)
-C            RETURN
-C            END
-C
-C 4.2. Calling Program for QAG
-C      -----------------------
-C
-C            REAL A,ABSERR,B,EPSABS,EPSREL,F,RESULT,WORK
-C            INTEGER IER,IWORK,KEY,LAST,LENW,LIMIT,NEVAL
-C            DIMENSION IWORK(100),WORK(400)
-C            EXTERNAL F
-C            A = 0.0E0
-C            B = 1.0E0
-C            EPSABS = 0.0E0
-C            EPSREL = 1.0E-3
-C            KEY = 6
-C            LIMIT = 100
-C            LENW = LIMIT*4
-C            CALL QAG(F,A,B,EPSABS,EPSREL,KEY,RESULT,ABSERR,NEVAL,
-C           *  IER,LIMIT,LENW,LAST,IWORK,WORK)
-C      C  INCLUDE WRITE STATEMENTS
-C            STOP
-C            END
-C      C
-C            REAL FUNCTION F(X)
-C            REAL X
-C            F = 2.0E0/(2.0E0+SIN(31.41592653589793E0*X))
-C            RETURN
-C            END
-C
-C 4.3. Calling Program for QAGS
-C      ------------------------
-C
-C            REAL A,ABSERR,B,EPSABS,EPSREL,F,RESULT,WORK
-C            INTEGER IER,IWORK,LAST,LENW,LIMIT,NEVAL
-C            DIMENSION IWORK(100),WORK(400)
-C            EXTERNAL F
-C            A = 0.0E0
-C            B = 1.0E0
-C            EPSABS = 0.0E0
-C            EPSREL = 1.0E-3
-C            LIMIT = 100
-C            LENW = LIMIT*4
-C            CALL QAGS(F,A,B,EPSABS,EPSREL,RESULT,ABSERR,NEVAL,IER,
-C           *  LIMIT,LENW,LAST,IWORK,WORK)
-C      C  INCLUDE WRITE STATEMENTS
-C            STOP
-C            END
-C      C
-C            REAL FUNCTION F(X)
-C            REAL X
-C            F = 0.0E0
-C            IF(X.GT.0.0E0) F = 1.0E0/SQRT(X)
-C            RETURN
-C            END
-C
-C 4.4. Calling Program for QAGP
-C      ------------------------
-C
-C            REAL A,ABSERR,B,EPSABS,EPSREL,F,POINTS,RESULT,WORK
-C            INTEGER IER,IWORK,LAST,LENIW,LENW,LIMIT,NEVAL,NPTS2
-C            DIMENSION IWORK(204),POINTS(4),WORK(404)
-C            EXTERNAL F
-C            A = 0.0E0
-C            B = 1.0E0
-C            NPTS2 = 4
-C            POINTS(1) = 1.0E0/7.0E0
-C            POINTS(2) = 2.0E0/3.0E0
-C            LIMIT = 100
-C            LENIW = LIMIT*2+NPTS2
-C            LENW = LIMIT*4+NPTS2
-C            CALL QAGP(F,A,B,NPTS2,POINTS,EPSABS,EPSREL,RESULT,ABSERR,
-C           *  NEVAL,IER,LENIW,LENW,LAST,IWORK,WORK)
-C      C  INCLUDE WRITE STATEMENTS
-C            STOP
-C            END
-C      C
-C            REAL FUNCTION F(X)
-C            REAL X
-C            F = 0.0E+00
-C            IF(X.NE.1.0E0/7.0E0.AND.X.NE.2.0E0/3.0E0) F =
-C           *  ABS(X-1.0E0/7.0E0)**(-0.25E0)*
-C           *  ABS(X-2.0E0/3.0E0)**(-0.55E0)
-C            RETURN
-C            END
-C
-C 4.5. Calling Program for QAGI
-C      ------------------------
-C
-C            REAL ABSERR,BOUN,EPSABS,EPSREL,F,RESULT,WORK
-C            INTEGER IER,INF,IWORK,LAST,LENW,LIMIT,NEVAL
-C            DIMENSION IWORK(100),WORK(400)
-C            EXTERNAL F
-C            BOUN = 0.0E0
-C            INF = 1
-C            EPSABS = 0.0E0
-C            EPSREL = 1.0E-3
-C            LIMIT = 100
-C            LENW = LIMIT*4
-C            CALL QAGI(F,BOUN,INF,EPSABS,EPSREL,RESULT,ABSERR,NEVAL,
-C           *  IER,LIMIT,LENW,LAST,IWORK,WORK)
-C      C  INCLUDE WRITE STATEMENTS
-C            STOP
-C            END
-C      C
-C            REAL FUNCTION F(X)
-C            REAL X
-C            F = 0.0E0
-C            IF(X.GT.0.0E0) F = SQRT(X)*ALOG(X)/
-C           *                   ((X+1.0E0)*(X+2.0E0))
-C            RETURN
-C            END
-C
-C 4.6. Calling Program for QAWO
-C      ------------------------
-C
-C            REAL A,ABSERR,B,EPSABS,EPSREL,F,RESULT,OMEGA,WORK
-C            INTEGER IER,INTEGR,IWORK,LAST,LENIW,LENW,LIMIT,MAXP1,NEVAL
-C            DIMENSION IWORK(200),WORK(925)
-C            EXTERNAL F
-C            A = 0.0E0
-C            B = 1.0E0
-C            OMEGA = 10.0E0
-C            INTEGR = 1
-C            EPSABS = 0.0E0
-C            EPSREL = 1.0E-3
-C            LIMIT = 100
-C            LENIW = LIMIT*2
-C            MAXP1 = 21
-C            LENW = LIMIT*4+MAXP1*25
-C            CALL QAWO(F,A,B,OMEGA,INTEGR,EPSABS,EPSREL,RESULT,ABSERR,
-C           *  NEVAL,IER,LENIW,MAXP1,LENW,LAST,IWORK,WORK)
-C      C  INCLUDE WRITE STATEMENTS
-C            STOP
-C            END
-C      C
-C            REAL FUNCTION F(X)
-C            REAL X
-C            F = 0.0E0
-C            IF(X.GT.0.0E0) F = EXP(-X)*ALOG(X)
-C            RETURN
-C            END
-C
-C 4.7. Calling Program for QAWF
-C      ------------------------
-C
-C            REAL A,ABSERR,EPSABS,F,RESULT,OMEGA,WORK
-C            INTEGER IER,INTEGR,IWORK,LAST,LENIW,LENW,LIMIT,LIMLST,
-C           *  LST,MAXP1,NEVAL
-C            DIMENSION IWORK(250),WORK(1025)
-C            EXTERNAL F
-C            A = 0.0E0
-C            OMEGA = 8.0E0
-C            INTEGR = 2
-C            EPSABS = 1.0E-3
-C            LIMLST = 50
-C            LIMIT = 100
-C            LENIW = LIMIT*2+LIMLST
-C            MAXP1 = 21
-C            LENW = LENIW*2+MAXP1*25
-C            CALL QAWF(F,A,OMEGA,INTEGR,EPSABS,RESULT,ABSERR,NEVAL,
-C           *  IER,LIMLST,LST,LENIW,MAXP1,LENW,IWORK,WORK)
-C      C  INCLUDE WRITE STATEMENTS
-C            STOP
-C            END
-C      C
-C            REAL FUNCTION F(X)
-C            REAL X
-C            IF(X.GT.0.0E0) F = SIN(50.0E0*X)/(X*SQRT(X))
-C            RETURN
-C            END
-C
-C 4.8. Calling Program for QAWS
-C      ------------------------
-C
-C            REAL A,ABSERR,ALFA,B,BETA,EPSABS,EPSREL,F,RESULT,WORK
-C            INTEGER IER,INTEGR,IWORK,LAST,LENW,LIMIT,NEVAL
-C            DIMENSION IWORK(100),WORK(400)
-C            EXTERNAL F
-C            A = 0.0E0
-C            B = 1.0E0
-C            ALFA = -0.5E0
-C            BETA = -0.5E0
-C            INTEGR = 1
-C            EPSABS = 0.0E0
-C            EPSREL = 1.0E-3
-C            LIMIT = 100
-C            LENW = LIMIT*4
-C            CALL QAWS(F,A,B,ALFA,BETA,INTEGR,EPSABS,EPSREL,RESULT,
-C           *  ABSERR,NEVAL,IER,LIMIT,LENW,LAST,IWORK,WORK)
-C      C  INCLUDE WRITE STATEMENTS
-C            STOP
-C            END
-C      C
-C            REAL FUNCTION F(X)
-C            REAL X
-C            F = SIN(10.0E0*X)
-C            RETURN
-C            END
-C
-C 4.9. Calling Program for QAWC
-C      ------------------------
-C
-C            REAL A,ABSERR,B,C,EPSABS,EPSREL,F,RESULT,WORK
-C            INTEGER IER,IWORK,LAST,LENW,LIMIT,NEVAL
-C            DIMENSION IWORK(100),WORK(400)
-C            EXTERNAL F
-C            A = -1.0E0
-C            B = 1.0E0
-C            C = 0.5E0
-C            EPSABS = 0.0E0
-C            EPSREL = 1.0E-3
-C            LIMIT = 100
-C            LENW = LIMIT*4
-C            CALL QAWC(F,A,B,C,EPSABS,EPSREL,RESULT,ABSERR,NEVAL,
-C           *  IER,LIMIT,LENW,LAST,IWORK,WORK)
-C      C  INCLUDE WRITE STATEMENTS
-C            STOP
-C            END
-C      C
-C            REAL FUNCTION F(X)
-C            REAL X
-C            F = 1.0E0/(X*X+1.0E-4)
-C            RETURN
-C            END
-C***REFERENCES  (NONE)
-C***ROUTINES CALLED  (NONE)
-C***END PROLOGUE  QPDOC
Index: scipy/scipy/integrate/quadpack/dqag.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqag.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,182 +0,0 @@
-      recursive subroutine dqag(f,a,b,epsabs,epsrel,key,result,abserr,
-     *    neval,ier,limit,lenw,last,iwork,work)
-c***begin prologue  dqag
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a1
-c***keywords  automatic integrator, general-purpose,
-c             integrand examinator, globally adaptive,
-c             gauss-kronrod
-c***author  piessens,robert,appl. math. & progr. div - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral i = integral of f over (a,b),
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result)le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c        computation of a definite integral
-c        standard fortran subroutine
-c        double precision version
-c
-c            f      - double precision
-c                     function subprogam defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            epsabs - double precision
-c                     absolute accoracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c            key    - integer
-c                     key for choice of local integration rule
-c                     a gauss-kronrod pair is used with
-c                       7 - 15 points if key.lt.2,
-c                      10 - 21 points if key = 2,
-c                      15 - 31 points if key = 3,
-c                      20 - 41 points if key = 4,
-c                      25 - 51 points if key = 5,
-c                      30 - 61 points if key.gt.5.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine
-c                             the estimates for result and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c                      error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more
-c                             subdivisions by increasing the value of
-c                             limit (and taking the according dimension
-c                             adjustments into account). however, if
-c                             this yield no improvement it is advised
-c                             to analyze the integrand in order to
-c                             determine the integration difficulaties.
-c                             if the position of a local difficulty can
-c                             be determined (i.e.singularity,
-c                             discontinuity within the interval) one
-c                             will probably gain from splitting up the
-c                             interval at this point and calling the
-c                             integrator on the subranges. if possible,
-c                             an appropriate special-purpose integrator
-c                             should be used which is designed for
-c                             handling the type of difficulty involved.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 6 the input is invalid, because
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
-c                             or limit.lt.1 or lenw.lt.limit*4.
-c                             result, abserr, neval, last are set
-c                             to zero.
-c                             except when lenw is invalid, iwork(1),
-c                             work(limit*2+1) and work(limit*3+1) are
-c                             set to zero, work(1) is set to a and
-c                             work(limit+1) to b.
-c
-c         dimensioning parameters
-c            limit - integer
-c                    dimensioning parameter for iwork
-c                    limit determines the maximum number of subintervals
-c                    in the partition of the given integration interval
-c                    (a,b), limit.ge.1.
-c                    if limit.lt.1, the routine will end with ier = 6.
-c
-c            lenw  - integer
-c                    dimensioning parameter for work
-c                    lenw must be at least limit*4.
-c                    if lenw.lt.limit*4, the routine will end with
-c                    ier = 6.
-c
-c            last  - integer
-c                    on return, last equals the number of subintervals
-c                    produced in the subdiviosion process, which
-c                    determines the number of significant elements
-c                    actually in the work arrays.
-c
-c         work arrays
-c            iwork - integer
-c                    vector of dimension at least limit, the first k
-c                    elements of which contain pointers to the error
-c                    estimates over the subintervals, such that
-c                    work(limit*3+iwork(1)),... , work(limit*3+iwork(k))
-c                    form a decreasing sequence with k = last if
-c                    last.le.(limit/2+2), and k = limit+1-last otherwise
-c
-c            work  - double precision
-c                    vector of dimension at least lenw
-c                    on return
-c                    work(1), ..., work(last) contain the left end
-c                    points of the subintervals in the partition of
-c                     (a,b),
-c                    work(limit+1), ..., work(limit+last) contain the
-c                     right end points,
-c                    work(limit*2+1), ..., work(limit*2+last) contain
-c                     the integral approximations over the subintervals,
-c                    work(limit*3+1), ..., work(limit*3+last) contain
-c                     the error estimates.
-c
-c***references  (none)
-c***routines called  dqage,xerror
-c***end prologue  dqag
-      double precision a,abserr,b,epsabs,epsrel,f,result,work
-      integer ier,iwork,key,last,lenw,limit,lvl,l1,l2,l3,neval
-c
-      dimension iwork(limit),work(lenw)
-c
-      external f
-c
-c         check validity of lenw.
-c
-c***first executable statement  dqag
-      ier = 6
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(limit.lt.1.or.lenw.lt.limit*4) go to 10
-c
-c         prepare call for dqage.
-c
-      l1 = limit+1
-      l2 = limit+l1
-      l3 = limit+l2
-c
-      call dqage(f,a,b,epsabs,epsrel,key,limit,result,abserr,neval,
-     *  ier,work(1),work(l1),work(l2),work(l3),iwork,last)
-c
-c         call error handler if necessary.
-c
-      lvl = 0
-10    if(ier.eq.6) lvl = 1
-      if(ier.ne.0) call xerror('abnormal return from dqag' ,26,ier,lvl)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqage.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqage.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,340 +0,0 @@
-      recursive subroutine dqage(f,a,b,epsabs,epsrel,key,limit,result,
-     *   abserr,neval,ier,alist,blist,rlist,elist,iord,last)
-c***begin prologue  dqage
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a1
-c***keywords  automatic integrator, general-purpose,
-c             integrand examinator, globally adaptive,
-c             gauss-kronrod
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral   i = integral of f over (a,b),
-c            hopefully satisfying following claim for accuracy
-c            abs(i-reslt).le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c        computation of a definite integral
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c            key    - integer
-c                     key for choice of local integration rule
-c                     a gauss-kronrod pair is used with
-c                          7 - 15 points if key.lt.2,
-c                         10 - 21 points if key = 2,
-c                         15 - 31 points if key = 3,
-c                         20 - 41 points if key = 4,
-c                         25 - 51 points if key = 5,
-c                         30 - 61 points if key.gt.5.
-c
-c            limit  - integer
-c                     gives an upperbound on the number of subintervals
-c                     in the partition of (a,b), limit.ge.1.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine
-c                             the estimates for result and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more
-c                             subdivisions by increasing the value
-c                             of limit.
-c                             however, if this yields no improvement it
-c                             is rather advised to analyze the integrand
-c                             in order to determine the integration
-c                             difficulties. if the position of a local
-c                             difficulty can be determined(e.g.
-c                             singularity, discontinuity within the
-c                             interval) one will probably gain from
-c                             splitting up the interval at this point
-c                             and calling the integrator on the
-c                             subranges. if possible, an appropriate
-c                             special-purpose integrator should be used
-c                             which is designed for handling the type of
-c                             difficulty involved.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 6 the input is invalid, because
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                             result, abserr, neval, last, rlist(1) ,
-c                             elist(1) and iord(1) are set to zero.
-c                             alist(1) and blist(1) are set to a and b
-c                             respectively.
-c
-c            alist   - double precision
-c                      vector of dimension at least limit, the first
-c                       last  elements of which are the left
-c                      end points of the subintervals in the partition
-c                      of the given integration range (a,b)
-c
-c            blist   - double precision
-c                      vector of dimension at least limit, the first
-c                       last  elements of which are the right
-c                      end points of the subintervals in the partition
-c                      of the given integration range (a,b)
-c
-c            rlist   - double precision
-c                      vector of dimension at least limit, the first
-c                       last  elements of which are the
-c                      integral approximations on the subintervals
-c
-c            elist   - double precision
-c                      vector of dimension at least limit, the first
-c                       last  elements of which are the moduli of the
-c                      absolute error estimates on the subintervals
-c
-c            iord    - integer
-c                      vector of dimension at least limit, the first k
-c                      elements of which are pointers to the
-c                      error estimates over the subintervals,
-c                      such that elist(iord(1)), ...,
-c                      elist(iord(k)) form a decreasing sequence,
-c                      with k = last if last.le.(limit/2+2), and
-c                      k = limit+1-last otherwise
-c
-c            last    - integer
-c                      number of subintervals actually produced in the
-c                      subdivision process
-c
-c***references  (none)
-c***routines called  d1mach,dqk15,dqk21,dqk31,
-c                    dqk41,dqk51,dqk61,dqpsrt
-c***end prologue  dqage
-c
-      double precision a,abserr,alist,area,area1,area12,area2,a1,a2,b,
-     *  blist,b1,b2,dabs,defabs,defab1,defab2,dmax1,d1mach,elist,epmach,
-     *  epsabs,epsrel,errbnd,errmax,error1,error2,erro12,errsum,f,
-     *  resabs,result,rlist,uflow
-      integer ier,iord,iroff1,iroff2,k,key,keyf,last,limit,maxerr,neval,
-     *  nrmax
-c
-      dimension alist(limit),blist(limit),elist(limit),iord(limit),
-     *  rlist(limit)
-c
-      external f
-c
-c            list of major variables
-c            -----------------------
-c
-c           alist     - list of left end points of all subintervals
-c                       considered up to now
-c           blist     - list of right end points of all subintervals
-c                       considered up to now
-c           rlist(i)  - approximation to the integral over
-c                      (alist(i),blist(i))
-c           elist(i)  - error estimate applying to rlist(i)
-c           maxerr    - pointer to the interval with largest
-c                       error estimate
-c           errmax    - elist(maxerr)
-c           area      - sum of the integrals over the subintervals
-c           errsum    - sum of the errors over the subintervals
-c           errbnd    - requested accuracy max(epsabs,epsrel*
-c                       abs(result))
-c           *****1    - variable for the left subinterval
-c           *****2    - variable for the right subinterval
-c           last      - index for subdivision
-c
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach  is the largest relative spacing.
-c           uflow  is the smallest positive magnitude.
-c
-c***first executable statement  dqage
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-c           test on validity of parameters
-c           ------------------------------
-c
-      ier = 0
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      alist(1) = a
-      blist(1) = b
-      rlist(1) = 0.0d+00
-      elist(1) = 0.0d+00
-      iord(1) = 0
-      if(epsabs.le.0.0d+00.and.
-     *  epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28)) ier = 6
-      if(ier.eq.6) go to 999
-c
-c           first approximation to the integral
-c           -----------------------------------
-c
-      keyf = key
-      if(key.le.0) keyf = 1
-      if(key.ge.7) keyf = 6
-      neval = 0
-      if(keyf.eq.1) call dqk15(f,a,b,result,abserr,defabs,resabs)
-      if(keyf.eq.2) call dqk21(f,a,b,result,abserr,defabs,resabs)
-      if(keyf.eq.3) call dqk31(f,a,b,result,abserr,defabs,resabs)
-      if(keyf.eq.4) call dqk41(f,a,b,result,abserr,defabs,resabs)
-      if(keyf.eq.5) call dqk51(f,a,b,result,abserr,defabs,resabs)
-      if(keyf.eq.6) call dqk61(f,a,b,result,abserr,defabs,resabs)
-      last = 1
-      rlist(1) = result
-      elist(1) = abserr
-      iord(1) = 1
-c
-c           test on accuracy.
-c
-      errbnd = dmax1(epsabs,epsrel*dabs(result))
-      if(abserr.le.0.5d+02*epmach*defabs.and.abserr.gt.errbnd) ier = 2
-      if(limit.eq.1) ier = 1
-      if(ier.ne.0.or.(abserr.le.errbnd.and.abserr.ne.resabs)
-     *  .or.abserr.eq.0.0d+00) go to 60
-c
-c           initialization
-c           --------------
-c
-c
-      errmax = abserr
-      maxerr = 1
-      area = result
-      errsum = abserr
-      nrmax = 1
-      iroff1 = 0
-      iroff2 = 0
-c
-c           main do-loop
-c           ------------
-c
-      do 30 last = 2,limit
-c
-c           bisect the subinterval with the largest error estimate.
-c
-        a1 = alist(maxerr)
-        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
-        a2 = b1
-        b2 = blist(maxerr)
-        if(keyf.eq.1) call dqk15(f,a1,b1,area1,error1,resabs,defab1)
-        if(keyf.eq.2) call dqk21(f,a1,b1,area1,error1,resabs,defab1)
-        if(keyf.eq.3) call dqk31(f,a1,b1,area1,error1,resabs,defab1)
-        if(keyf.eq.4) call dqk41(f,a1,b1,area1,error1,resabs,defab1)
-        if(keyf.eq.5) call dqk51(f,a1,b1,area1,error1,resabs,defab1)
-        if(keyf.eq.6) call dqk61(f,a1,b1,area1,error1,resabs,defab1)
-        if(keyf.eq.1) call dqk15(f,a2,b2,area2,error2,resabs,defab2)
-        if(keyf.eq.2) call dqk21(f,a2,b2,area2,error2,resabs,defab2)
-        if(keyf.eq.3) call dqk31(f,a2,b2,area2,error2,resabs,defab2)
-        if(keyf.eq.4) call dqk41(f,a2,b2,area2,error2,resabs,defab2)
-        if(keyf.eq.5) call dqk51(f,a2,b2,area2,error2,resabs,defab2)
-        if(keyf.eq.6) call dqk61(f,a2,b2,area2,error2,resabs,defab2)
-c
-c           improve previous approximations to integral
-c           and error and test for accuracy.
-c
-        neval = neval+1
-        area12 = area1+area2
-        erro12 = error1+error2
-        errsum = errsum+erro12-errmax
-        area = area+area12-rlist(maxerr)
-        if(defab1.eq.error1.or.defab2.eq.error2) go to 5
-        if(dabs(rlist(maxerr)-area12).le.0.1d-04*dabs(area12)
-     *  .and.erro12.ge.0.99d+00*errmax) iroff1 = iroff1+1
-        if(last.gt.10.and.erro12.gt.errmax) iroff2 = iroff2+1
-    5   rlist(maxerr) = area1
-        rlist(last) = area2
-        errbnd = dmax1(epsabs,epsrel*dabs(area))
-        if(errsum.le.errbnd) go to 8
-c
-c           test for roundoff error and eventually set error flag.
-c
-        if(iroff1.ge.6.or.iroff2.ge.20) ier = 2
-c
-c           set error flag in the case that the number of subintervals
-c           equals limit.
-c
-        if(last.eq.limit) ier = 1
-c
-c           set error flag in the case of bad integrand behaviour
-c           at a point of the integration range.
-c
-        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*
-     *  epmach)*(dabs(a2)+0.1d+04*uflow)) ier = 3
-c
-c           append the newly-created intervals to the list.
-c
-    8   if(error2.gt.error1) go to 10
-        alist(last) = a2
-        blist(maxerr) = b1
-        blist(last) = b2
-        elist(maxerr) = error1
-        elist(last) = error2
-        go to 20
-   10   alist(maxerr) = a2
-        alist(last) = a1
-        blist(last) = b1
-        rlist(maxerr) = area2
-        rlist(last) = area1
-        elist(maxerr) = error2
-        elist(last) = error1
-c
-c           call subroutine dqpsrt to maintain the descending ordering
-c           in the list of error estimates and select the subinterval
-c           with the largest error estimate (to be bisected next).
-c
-   20   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
-c ***jump out of do-loop
-        if(ier.ne.0.or.errsum.le.errbnd) go to 40
-   30 continue
-c
-c           compute final result.
-c           ---------------------
-c
-   40 result = 0.0d+00
-      do 50 k=1,last
-        result = result+rlist(k)
-   50 continue
-      abserr = errsum
-   60 if(keyf.ne.1) neval = (10*keyf+1)*(2*neval+1)
-      if(keyf.eq.1) neval = 30*neval+15
-  999 return
-      end
Index: scipy/scipy/integrate/quadpack/dqagi.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqagi.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,191 +0,0 @@
-      recursive subroutine dqagi(f,bound,inf,epsabs,epsrel,result,
-     *   abserr,neval,ier,limit,lenw,last,iwork,work)
-c***begin prologue  dqagi
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a3a1,h2a4a1
-c***keywords  automatic integrator, infinite intervals,
-c             general-purpose, transformation, extrapolation,
-c             globally adaptive
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. -k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            integral   i = integral of f over (bound,+infinity)
-c            or i = integral of f over (-infinity,bound)
-c            or i = integral of f over (-infinity,+infinity)
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c        integration over infinite intervals
-c        standard fortran subroutine
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            bound  - double precision
-c                     finite bound of integration range
-c                     (has no meaning if interval is doubly-infinite)
-c
-c            inf    - integer
-c                     indicating the kind of integration range involved
-c                     inf = 1 corresponds to  (bound,+infinity),
-c                     inf = -1            to  (-infinity,bound),
-c                     inf = 2             to (-infinity,+infinity).
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                   - ier.gt.0 abnormal termination of the routine. the
-c                             estimates for result and error are less
-c                             reliable. it is assumed that the requested
-c                             accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more
-c                             subdivisions by increasing the value of
-c                             limit (and taking the according dimension
-c                             adjustments into account). however, if
-c                             this yields no improvement it is advised
-c                             to analyze the integrand in order to
-c                             determine the integration difficulties. if
-c                             the position of a local difficulty can be
-c                             determined (e.g. singularity,
-c                             discontinuity within the interval) one
-c                             will probably gain from splitting up the
-c                             interval at this point and calling the
-c                             integrator on the subranges. if possible,
-c                             an appropriate special-purpose integrator
-c                             should be used, which is designed for
-c                             handling the type of difficulty involved.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                             the error may be under-estimated.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 4 the algorithm does not converge.
-c                             roundoff error is detected in the
-c                             extrapolation table.
-c                             it is assumed that the requested tolerance
-c                             cannot be achieved, and that the returned
-c                             result is the best which can be obtained.
-c                         = 5 the integral is probably divergent, or
-c                             slowly convergent. it must be noted that
-c                             divergence can occur with any other value
-c                             of ier.
-c                         = 6 the input is invalid, because
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
-c                              or limit.lt.1 or leniw.lt.limit*4.
-c                             result, abserr, neval, last are set to
-c                             zero. except when limit or leniw is
-c                             invalid, iwork(1), work(limit*2+1) and
-c                             work(limit*3+1) are set to zero, work(1)
-c                             is set to a and work(limit+1) to b.
-c
-c         dimensioning parameters
-c            limit - integer
-c                    dimensioning parameter for iwork
-c                    limit determines the maximum number of subintervals
-c                    in the partition of the given integration interval
-c                    (a,b), limit.ge.1.
-c                    if limit.lt.1, the routine will end with ier = 6.
-c
-c            lenw  - integer
-c                    dimensioning parameter for work
-c                    lenw must be at least limit*4.
-c                    if lenw.lt.limit*4, the routine will end
-c                    with ier = 6.
-c
-c            last  - integer
-c                    on return, last equals the number of subintervals
-c                    produced in the subdivision process, which
-c                    determines the number of significant elements
-c                    actually in the work arrays.
-c
-c         work arrays
-c            iwork - integer
-c                    vector of dimension at least limit, the first
-c                    k elements of which contain pointers
-c                    to the error estimates over the subintervals,
-c                    such that work(limit*3+iwork(1)),... ,
-c                    work(limit*3+iwork(k)) form a decreasing
-c                    sequence, with k = last if last.le.(limit/2+2), and
-c                    k = limit+1-last otherwise
-c
-c            work  - double precision
-c                    vector of dimension at least lenw
-c                    on return
-c                    work(1), ..., work(last) contain the left
-c                     end points of the subintervals in the
-c                     partition of (a,b),
-c                    work(limit+1), ..., work(limit+last) contain
-c                     the right end points,
-c                    work(limit*2+1), ...,work(limit*2+last) contain the
-c                     integral approximations over the subintervals,
-c                    work(limit*3+1), ..., work(limit*3+last)
-c                     contain the error estimates.
-c***references  (none)
-c***routines called  dqagie,xerror
-c***end prologue  dqagi
-c
-      double precision abserr,bound,epsabs,epsrel,f,result,work
-      integer ier,inf,iwork,last,lenw,limit,lvl,l1,l2,l3,neval
-c
-      dimension iwork(limit),work(lenw)
-c
-      external f
-c
-c         check validity of limit and lenw.
-c
-c***first executable statement  dqagi
-      ier = 6
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(limit.lt.1.or.lenw.lt.limit*4) go to 10
-c
-c         prepare call for dqagie.
-c
-      l1 = limit+1
-      l2 = limit+l1
-      l3 = limit+l2
-c
-      call dqagie(f,bound,inf,epsabs,epsrel,limit,result,abserr,
-     *  neval,ier,work(1),work(l1),work(l2),work(l3),iwork,last)
-c
-c         call error handler if necessary.
-c
-       lvl = 0
-10    if(ier.eq.6) lvl = 1
-      if(ier.ne.0) call xerror('abnormal return from dqagi',26,ier,lvl)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqagie.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqagie.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,452 +0,0 @@
-      recursive subroutine dqagie(f,bound,inf,epsabs,epsrel,limit,
-     *   result,abserr,neval,ier,alist,blist,rlist,elist,iord,last)
-c***begin prologue  dqagie
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a3a1,h2a4a1
-c***keywords  automatic integrator, infinite intervals,
-c             general-purpose, transformation, extrapolation,
-c             globally adaptive
-c***author  piessens,robert,appl. math & progr. div - k.u.leuven
-c           de doncker,elise,appl. math & progr. div - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            integral   i = integral of f over (bound,+infinity)
-c            or i = integral of f over (-infinity,bound)
-c            or i = integral of f over (-infinity,+infinity),
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.max(epsabs,epsrel*abs(i))
-c***description
-c
-c integration over infinite intervals
-c standard fortran subroutine
-c
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            bound  - double precision
-c                     finite bound of integration range
-c                     (has no meaning if interval is doubly-infinite)
-c
-c            inf    - double precision
-c                     indicating the kind of integration range involved
-c                     inf = 1 corresponds to  (bound,+infinity),
-c                     inf = -1            to  (-infinity,bound),
-c                     inf = 2             to (-infinity,+infinity).
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c            limit  - integer
-c                     gives an upper bound on the number of subintervals
-c                     in the partition of (a,b), limit.ge.1
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                   - ier.gt.0 abnormal termination of the routine. the
-c                             estimates for result and error are less
-c                             reliable. it is assumed that the requested
-c                             accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more
-c                             subdivisions by increasing the value of
-c                             limit (and taking the according dimension
-c                             adjustments into account). however,if
-c                             this yields no improvement it is advised
-c                             to analyze the integrand in order to
-c                             determine the integration difficulties.
-c                             if the position of a local difficulty can
-c                             be determined (e.g. singularity,
-c                             discontinuity within the interval) one
-c                             will probably gain from splitting up the
-c                             interval at this point and calling the
-c                             integrator on the subranges. if possible,
-c                             an appropriate special-purpose integrator
-c                             should be used, which is designed for
-c                             handling the type of difficulty involved.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                             the error may be under-estimated.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 4 the algorithm does not converge.
-c                             roundoff error is detected in the
-c                             extrapolation table.
-c                             it is assumed that the requested tolerance
-c                             cannot be achieved, and that the returned
-c                             result is the best which can be obtained.
-c                         = 5 the integral is probably divergent, or
-c                             slowly convergent. it must be noted that
-c                             divergence can occur with any other value
-c                             of ier.
-c                         = 6 the input is invalid, because
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                             result, abserr, neval, last, rlist(1),
-c                             elist(1) and iord(1) are set to zero.
-c                             alist(1) and blist(1) are set to 0
-c                             and 1 respectively.
-c
-c            alist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the left
-c                     end points of the subintervals in the partition
-c                     of the transformed integration range (0,1).
-c
-c            blist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the right
-c                     end points of the subintervals in the partition
-c                     of the transformed integration range (0,1).
-c
-c            rlist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the integral
-c                     approximations on the subintervals
-c
-c            elist  - double precision
-c                     vector of dimension at least limit,  the first
-c                     last elements of which are the moduli of the
-c                     absolute error estimates on the subintervals
-c
-c            iord   - integer
-c                     vector of dimension limit, the first k
-c                     elements of which are pointers to the
-c                     error estimates over the subintervals,
-c                     such that elist(iord(1)), ..., elist(iord(k))
-c                     form a decreasing sequence, with k = last
-c                     if last.le.(limit/2+2), and k = limit+1-last
-c                     otherwise
-c
-c            last   - integer
-c                     number of subintervals actually produced
-c                     in the subdivision process
-c
-c***references  (none)
-c***routines called  d1mach,dqelg,dqk15i,dqpsrt
-c***end prologue  dqagie
-      double precision abseps,abserr,alist,area,area1,area12,area2,a1,
-     *  a2,blist,boun,bound,b1,b2,correc,dabs,defabs,defab1,defab2,
-     *  dmax1,dres,d1mach,elist,epmach,epsabs,epsrel,erlarg,erlast,
-     *  errbnd,errmax,error1,error2,erro12,errsum,ertest,f,oflow,resabs,
-     *  reseps,result,res3la,rlist,rlist2,small,uflow
-      integer id,ier,ierro,inf,iord,iroff1,iroff2,iroff3,jupbnd,k,ksgn,
-     *  ktmin,last,limit,maxerr,neval,nres,nrmax,numrl2
-      logical extrap,noext
-c
-      dimension alist(limit),blist(limit),elist(limit),iord(limit),
-     *  res3la(3),rlist(limit),rlist2(52)
-c
-      external f
-c
-c            the dimension of rlist2 is determined by the value of
-c            limexp in subroutine dqelg.
-c
-c
-c            list of major variables
-c            -----------------------
-c
-c           alist     - list of left end points of all subintervals
-c                       considered up to now
-c           blist     - list of right end points of all subintervals
-c                       considered up to now
-c           rlist(i)  - approximation to the integral over
-c                       (alist(i),blist(i))
-c           rlist2    - array of dimension at least (limexp+2),
-c                       containing the part of the epsilon table
-c                       which is still needed for further computations
-c           elist(i)  - error estimate applying to rlist(i)
-c           maxerr    - pointer to the interval with largest error
-c                       estimate
-c           errmax    - elist(maxerr)
-c           erlast    - error on the interval currently subdivided
-c                       (before that subdivision has taken place)
-c           area      - sum of the integrals over the subintervals
-c           errsum    - sum of the errors over the subintervals
-c           errbnd    - requested accuracy max(epsabs,epsrel*
-c                       abs(result))
-c           *****1    - variable for the left subinterval
-c           *****2    - variable for the right subinterval
-c           last      - index for subdivision
-c           nres      - number of calls to the extrapolation routine
-c           numrl2    - number of elements currently in rlist2. if an
-c                       appropriate approximation to the compounded
-c                       integral has been obtained, it is put in
-c                       rlist2(numrl2) after numrl2 has been increased
-c                       by one.
-c           small     - length of the smallest interval considered up
-c                       to now, multiplied by 1.5
-c           erlarg    - sum of the errors over the intervals larger
-c                       than the smallest interval considered up to now
-c           extrap    - logical variable denoting that the routine
-c                       is attempting to perform extrapolation. i.e.
-c                       before subdividing the smallest interval we
-c                       try to decrease the value of erlarg.
-c           noext     - logical variable denoting that extrapolation
-c                       is no longer allowed (true-value)
-c
-c            machine dependent constants
-c            ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c           oflow is the largest positive magnitude.
-c
-c***first executable statement  dqagie
-       epmach = d1mach(4)
-c
-c           test on validity of parameters
-c           -----------------------------
-c
-      ier = 0
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      alist(1) = 0.0d+00
-      blist(1) = 0.1d+01
-      rlist(1) = 0.0d+00
-      elist(1) = 0.0d+00
-      iord(1) = 0
-      if(epsabs.le.0.0d+00.and.epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28))
-     *  ier = 6
-       if(ier.eq.6) go to 999
-c
-c
-c           first approximation to the integral
-c           -----------------------------------
-c
-c           determine the interval to be mapped onto (0,1).
-c           if inf = 2 the integral is computed as i = i1+i2, where
-c           i1 = integral of f over (-infinity,0),
-c           i2 = integral of f over (0,+infinity).
-c
-      boun = bound
-      if(inf.eq.2) boun = 0.0d+00
-      call dqk15i(f,boun,inf,0.0d+00,0.1d+01,result,abserr,
-     *  defabs,resabs)
-c
-c           test on accuracy
-c
-      last = 1
-      rlist(1) = result
-      elist(1) = abserr
-      iord(1) = 1
-      dres = dabs(result)
-      errbnd = dmax1(epsabs,epsrel*dres)
-      if(abserr.le.1.0d+02*epmach*defabs.and.abserr.gt.errbnd) ier = 2
-      if(limit.eq.1) ier = 1
-      if(ier.ne.0.or.(abserr.le.errbnd.and.abserr.ne.resabs).or.
-     *  abserr.eq.0.0d+00) go to 130
-c
-c           initialization
-c           --------------
-c
-      uflow = d1mach(1)
-      oflow = d1mach(2)
-      rlist2(1) = result
-      errmax = abserr
-      maxerr = 1
-      area = result
-      errsum = abserr
-      abserr = oflow
-      nrmax = 1
-      nres = 0
-      ktmin = 0
-      numrl2 = 2
-      extrap = .false.
-      noext = .false.
-      ierro = 0
-      iroff1 = 0
-      iroff2 = 0
-      iroff3 = 0
-      ksgn = -1
-      if(dres.ge.(0.1d+01-0.5d+02*epmach)*defabs) ksgn = 1
-c
-c           main do-loop
-c           ------------
-c
-      do 90 last = 2,limit
-c
-c           bisect the subinterval with nrmax-th largest error estimate.
-c
-        a1 = alist(maxerr)
-        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
-        a2 = b1
-        b2 = blist(maxerr)
-        erlast = errmax
-        call dqk15i(f,boun,inf,a1,b1,area1,error1,resabs,defab1)
-        call dqk15i(f,boun,inf,a2,b2,area2,error2,resabs,defab2)
-c
-c           improve previous approximations to integral
-c           and error and test for accuracy.
-c
-        area12 = area1+area2
-        erro12 = error1+error2
-        errsum = errsum+erro12-errmax
-        area = area+area12-rlist(maxerr)
-        if(defab1.eq.error1.or.defab2.eq.error2)go to 15
-        if(dabs(rlist(maxerr)-area12).gt.0.1d-04*dabs(area12)
-     *  .or.erro12.lt.0.99d+00*errmax) go to 10
-        if(extrap) iroff2 = iroff2+1
-        if(.not.extrap) iroff1 = iroff1+1
-   10   if(last.gt.10.and.erro12.gt.errmax) iroff3 = iroff3+1
-   15   rlist(maxerr) = area1
-        rlist(last) = area2
-        errbnd = dmax1(epsabs,epsrel*dabs(area))
-c
-c           test for roundoff error and eventually set error flag.
-c
-        if(iroff1+iroff2.ge.10.or.iroff3.ge.20) ier = 2
-        if(iroff2.ge.5) ierro = 3
-c
-c           set error flag in the case that the number of
-c           subintervals equals limit.
-c
-        if(last.eq.limit) ier = 1
-c
-c           set error flag in the case of bad integrand behaviour
-c           at some points of the integration range.
-c
-        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*epmach)*
-     *  (dabs(a2)+0.1d+04*uflow)) ier = 4
-c
-c           append the newly-created intervals to the list.
-c
-        if(error2.gt.error1) go to 20
-        alist(last) = a2
-        blist(maxerr) = b1
-        blist(last) = b2
-        elist(maxerr) = error1
-        elist(last) = error2
-        go to 30
-   20   alist(maxerr) = a2
-        alist(last) = a1
-        blist(last) = b1
-        rlist(maxerr) = area2
-        rlist(last) = area1
-        elist(maxerr) = error2
-        elist(last) = error1
-c
-c           call subroutine dqpsrt to maintain the descending ordering
-c           in the list of error estimates and select the subinterval
-c           with nrmax-th largest error estimate (to be bisected next).
-c
-   30   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
-        if(errsum.le.errbnd) go to 115
-        if(ier.ne.0) go to 100
-        if(last.eq.2) go to 80
-        if(noext) go to 90
-        erlarg = erlarg-erlast
-        if(dabs(b1-a1).gt.small) erlarg = erlarg+erro12
-        if(extrap) go to 40
-c
-c           test whether the interval to be bisected next is the
-c           smallest interval.
-c
-        if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 90
-        extrap = .true.
-        nrmax = 2
-   40   if(ierro.eq.3.or.erlarg.le.ertest) go to 60
-c
-c           the smallest interval has the largest error.
-c           before bisecting decrease the sum of the errors over the
-c           larger intervals (erlarg) and perform extrapolation.
-c
-        id = nrmax
-        jupbnd = last
-        if(last.gt.(2+limit/2)) jupbnd = limit+3-last
-        do 50 k = id,jupbnd
-          maxerr = iord(nrmax)
-          errmax = elist(maxerr)
-          if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 90
-          nrmax = nrmax+1
-   50   continue
-c
-c           perform extrapolation.
-c
-   60   numrl2 = numrl2+1
-        rlist2(numrl2) = area
-        call dqelg(numrl2,rlist2,reseps,abseps,res3la,nres)
-        ktmin = ktmin+1
-        if(ktmin.gt.5.and.abserr.lt.0.1d-02*errsum) ier = 5
-        if(abseps.ge.abserr) go to 70
-        ktmin = 0
-        abserr = abseps
-        result = reseps
-        correc = erlarg
-        ertest = dmax1(epsabs,epsrel*dabs(reseps))
-        if(abserr.le.ertest) go to 100
-c
-c            prepare bisection of the smallest interval.
-c
-   70   if(numrl2.eq.1) noext = .true.
-        if(ier.eq.5) go to 100
-        maxerr = iord(1)
-        errmax = elist(maxerr)
-        nrmax = 1
-        extrap = .false.
-        small = small*0.5d+00
-        erlarg = errsum
-        go to 90
-   80   small = 0.375d+00
-        erlarg = errsum
-        ertest = errbnd
-        rlist2(2) = area
-   90 continue
-c
-c           set final result and error estimate.
-c           ------------------------------------
-c
-  100 if(abserr.eq.oflow) go to 115
-      if((ier+ierro).eq.0) go to 110
-      if(ierro.eq.3) abserr = abserr+correc
-      if(ier.eq.0) ier = 3
-      if(result.ne.0.0d+00.and.area.ne.0.0d+00)go to 105
-      if(abserr.gt.errsum)go to 115
-      if(area.eq.0.0d+00) go to 130
-      go to 110
-  105 if(abserr/dabs(result).gt.errsum/dabs(area))go to 115
-c
-c           test on divergence
-c
-  110 if(ksgn.eq.(-1).and.dmax1(dabs(result),dabs(area)).le.
-     * defabs*0.1d-01) go to 130
-      if(0.1d-01.gt.(result/area).or.(result/area).gt.0.1d+03.
-     *or.errsum.gt.dabs(area)) ier = 6
-      go to 130
-c
-c           compute global integral sum.
-c
-  115 result = 0.0d+00
-      do 120 k = 1,last
-        result = result+rlist(k)
-  120 continue
-      abserr = errsum
-  130 neval = 30*last-15
-      if(inf.eq.2) neval = 2*neval
-      if(ier.gt.2) ier=ier-1
-  999 return
-      end
Index: scipy/scipy/integrate/quadpack/dqagp.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqagp.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,225 +0,0 @@
-      recursive subroutine dqagp(f,a,b,npts2,points,epsabs,epsrel,
-     *   result,abserr,neval,ier,leniw,lenw,last,iwork,work)
-c***begin prologue  dqagp
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a1
-c***keywords  automatic integrator, general-purpose,
-c             singularities at user specified points,
-c             extrapolation, globally adaptive
-c***author  piessens,robert,appl. math. & progr. div - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral i = integral of f over (a,b),
-c            hopefully satisfying following claim for accuracy
-c            break points of the integration interval, where local
-c            difficulties of the integrand may occur (e.g.
-c            singularities, discontinuities), are provided by the user.
-c***description
-c
-c        computation of a definite integral
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            npts2  - integer
-c                     number equal to two more than the number of
-c                     user-supplied break points within the integration
-c                     range, npts.ge.2.
-c                     if npts2.lt.2, the routine will end with ier = 6.
-c
-c            points - double precision
-c                     vector of dimension npts2, the first (npts2-2)
-c                     elements of which are the user provided break
-c                     points. if these points do not constitute an
-c                     ascending sequence there will be an automatic
-c                     sorting.
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine.
-c                             the estimates for integral and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more
-c                             subdivisions by increasing the value of
-c                             limit (and taking the according dimension
-c                             adjustments into account). however, if
-c                             this yields no improvement it is advised
-c                             to analyze the integrand in order to
-c                             determine the integration difficulties. if
-c                             the position of a local difficulty can be
-c                             determined (i.e. singularity,
-c                             discontinuity within the interval), it
-c                             should be supplied to the routine as an
-c                             element of the vector points. if necessary
-c                             an appropriate special-purpose integrator
-c                             must be used, which is designed for
-c                             handling the type of difficulty involved.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                             the error may be under-estimated.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 4 the algorithm does not converge.
-c                             roundoff error is detected in the
-c                             extrapolation table.
-c                             it is presumed that the requested
-c                             tolerance cannot be achieved, and that
-c                             the returned result is the best which
-c                             can be obtained.
-c                         = 5 the integral is probably divergent, or
-c                             slowly convergent. it must be noted that
-c                             divergence can occur with any other value
-c                             of ier.gt.0.
-c                         = 6 the input is invalid because
-c                             npts2.lt.2 or
-c                             break points are specified outside
-c                             the integration range or
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
-c                             result, abserr, neval, last are set to
-c                             zero. except when leniw or lenw or npts2 is
-c                             invalid, iwork(1), iwork(limit+1),
-c                             work(limit*2+1) and work(limit*3+1)
-c                             are set to zero.
-c                             work(1) is set to a and work(limit+1)
-c                             to b (where limit = (leniw-npts2)/2).
-c
-c         dimensioning parameters
-c            leniw - integer
-c                    dimensioning parameter for iwork
-c                    leniw determines limit = (leniw-npts2)/2,
-c                    which is the maximum number of subintervals in the
-c                    partition of the given integration interval (a,b),
-c                    leniw.ge.(3*npts2-2).
-c                    if leniw.lt.(3*npts2-2), the routine will end with
-c                    ier = 6.
-c
-c            lenw  - integer
-c                    dimensioning parameter for work
-c                    lenw must be at least leniw*2-npts2.
-c                    if lenw.lt.leniw*2-npts2, the routine will end
-c                    with ier = 6.
-c
-c            last  - integer
-c                    on return, last equals the number of subintervals
-c                    produced in the subdivision process, which
-c                    determines the number of significant elements
-c                    actually in the work arrays.
-c
-c         work arrays
-c            iwork - integer
-c                    vector of dimension at least leniw. on return,
-c                    the first k elements of which contain
-c                    pointers to the error estimates over the
-c                    subintervals, such that work(limit*3+iwork(1)),...,
-c                    work(limit*3+iwork(k)) form a decreasing
-c                    sequence, with k = last if last.le.(limit/2+2), and
-c                    k = limit+1-last otherwise
-c                    iwork(limit+1), ...,iwork(limit+last) contain the
-c                     subdivision levels of the subintervals, i.e.
-c                     if (aa,bb) is a subinterval of (p1,p2)
-c                     where p1 as well as p2 is a user-provided
-c                     break point or integration limit, then (aa,bb) has
-c                     level l if abs(bb-aa) = abs(p2-p1)*2**(-l),
-c                    iwork(limit*2+1), ..., iwork(limit*2+npts2) have
-c                     no significance for the user,
-c                    note that limit = (leniw-npts2)/2.
-c
-c            work  - double precision
-c                    vector of dimension at least lenw
-c                    on return
-c                    work(1), ..., work(last) contain the left
-c                     end points of the subintervals in the
-c                     partition of (a,b),
-c                    work(limit+1), ..., work(limit+last) contain
-c                     the right end points,
-c                    work(limit*2+1), ..., work(limit*2+last) contain
-c                     the integral approximations over the subintervals,
-c                    work(limit*3+1), ..., work(limit*3+last)
-c                     contain the corresponding error estimates,
-c                    work(limit*4+1), ..., work(limit*4+npts2)
-c                     contain the integration limits and the
-c                     break points sorted in an ascending sequence.
-c                    note that limit = (leniw-npts2)/2.
-c
-c***references  (none)
-c***routines called  dqagpe,xerror
-c***end prologue  dqagp
-c
-      double precision a,abserr,b,epsabs,epsrel,f,points,result,work
-      integer ier,iwork,last,leniw,lenw,limit,lvl,l1,l2,l3,l4,neval,
-     *  npts2
-c
-      dimension iwork(leniw),points(npts2),work(lenw)
-c
-      external f
-c
-c         check validity of limit and lenw.
-c
-c***first executable statement  dqagp
-      ier = 6
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(leniw.lt.(3*npts2-2).or.lenw.lt.(leniw*2-npts2).or.npts2.lt.2)
-     *  go to 10
-c
-c         prepare call for dqagpe.
-c
-      limit = (leniw-npts2)/2
-      l1 = limit+1
-      l2 = limit+l1
-      l3 = limit+l2
-      l4 = limit+l3
-c
-      call dqagpe(f,a,b,npts2,points,epsabs,epsrel,limit,result,abserr,
-     *  neval,ier,work(1),work(l1),work(l2),work(l3),work(l4),
-     *  iwork(1),iwork(l1),iwork(l2),last)
-c
-c         call error handler if necessary.
-c
-      lvl = 0
-10    if(ier.eq.6) lvl = 1
-      if(ier.ne.0) call xerror('abnormal return from dqagp',26,ier,lvl)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqagpe.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqagpe.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,550 +0,0 @@
-      recursive subroutine dqagpe(f,a,b,npts2,points,epsabs,epsrel,
-     *   limit,result,abserr,neval,ier,alist,blist,rlist,elist,pts,
-     *   iord,level,ndin,last)
-c***begin prologue  dqagpe
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a1
-c***keywords  automatic integrator, general-purpose,
-c             singularities at user specified points,
-c             extrapolation, globally adaptive.
-c***author  piessens,robert ,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral i = integral of f over (a,b), hopefully
-c            satisfying following claim for accuracy abs(i-result).le.
-c            max(epsabs,epsrel*abs(i)). break points of the integration
-c            interval, where local difficulties of the integrand may
-c            occur(e.g. singularities,discontinuities),provided by user.
-c***description
-c
-c        computation of a definite integral
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            npts2  - integer
-c                     number equal to two more than the number of
-c                     user-supplied break points within the integration
-c                     range, npts2.ge.2.
-c                     if npts2.lt.2, the routine will end with ier = 6.
-c
-c            points - double precision
-c                     vector of dimension npts2, the first (npts2-2)
-c                     elements of which are the user provided break
-c                     points. if these points do not constitute an
-c                     ascending sequence there will be an automatic
-c                     sorting.
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c            limit  - integer
-c                     gives an upper bound on the number of subintervals
-c                     in the partition of (a,b), limit.ge.npts2
-c                     if limit.lt.npts2, the routine will end with
-c                     ier = 6.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine.
-c                             the estimates for integral and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more
-c                             subdivisions by increasing the value of
-c                             limit (and taking the according dimension
-c                             adjustments into account). however, if
-c                             this yields no improvement it is advised
-c                             to analyze the integrand in order to
-c                             determine the integration difficulties. if
-c                             the position of a local difficulty can be
-c                             determined (i.e. singularity,
-c                             discontinuity within the interval), it
-c                             should be supplied to the routine as an
-c                             element of the vector points. if necessary
-c                             an appropriate special-purpose integrator
-c                             must be used, which is designed for
-c                             handling the type of difficulty involved.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                             the error may be under-estimated.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 4 the algorithm does not converge.
-c                             roundoff error is detected in the
-c                             extrapolation table. it is presumed that
-c                             the requested tolerance cannot be
-c                             achieved, and that the returned result is
-c                             the best which can be obtained.
-c                         = 5 the integral is probably divergent, or
-c                             slowly convergent. it must be noted that
-c                             divergence can occur with any other value
-c                             of ier.gt.0.
-c                         = 6 the input is invalid because
-c                             npts2.lt.2 or
-c                             break points are specified outside
-c                             the integration range or
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
-c                             or limit.lt.npts2.
-c                             result, abserr, neval, last, rlist(1),
-c                             and elist(1) are set to zero. alist(1) and
-c                             blist(1) are set to a and b respectively.
-c
-c            alist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the left end points
-c                     of the subintervals in the partition of the given
-c                     integration range (a,b)
-c
-c            blist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the right end points
-c                     of the subintervals in the partition of the given
-c                     integration range (a,b)
-c
-c            rlist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the integral
-c                     approximations on the subintervals
-c
-c            elist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the moduli of the
-c                     absolute error estimates on the subintervals
-c
-c            pts    - double precision
-c                     vector of dimension at least npts2, containing the
-c                     integration limits and the break points of the
-c                     interval in ascending sequence.
-c
-c            level  - integer
-c                     vector of dimension at least limit, containing the
-c                     subdivision levels of the subinterval, i.e. if
-c                     (aa,bb) is a subinterval of (p1,p2) where p1 as
-c                     well as p2 is a user-provided break point or
-c                     integration limit, then (aa,bb) has level l if
-c                     abs(bb-aa) = abs(p2-p1)*2**(-l).
-c
-c            ndin   - integer
-c                     vector of dimension at least npts2, after first
-c                     integration over the intervals (pts(i)),pts(i+1),
-c                     i = 0,1, ..., npts2-2, the error estimates over
-c                     some of the intervals may have been increased
-c                     artificially, in order to put their subdivision
-c                     forward. if this happens for the subinterval
-c                     numbered k, ndin(k) is put to 1, otherwise
-c                     ndin(k) = 0.
-c
-c            iord   - integer
-c                     vector of dimension at least limit, the first k
-c                     elements of which are pointers to the
-c                     error estimates over the subintervals,
-c                     such that elist(iord(1)), ..., elist(iord(k))
-c                     form a decreasing sequence, with k = last
-c                     if last.le.(limit/2+2), and k = limit+1-last
-c                     otherwise
-c
-c            last   - integer
-c                     number of subintervals actually produced in the
-c                     subdivisions process
-c
-c***references  (none)
-c***routines called  d1mach,dqelg,dqk21,dqpsrt
-c***end prologue  dqagpe
-      double precision a,abseps,abserr,alist,area,area1,area12,area2,a1,
-     *  a2,b,blist,b1,b2,correc,dabs,defabs,defab1,defab2,dmax1,dmin1,
-     *  dres,d1mach,elist,epmach,epsabs,epsrel,erlarg,erlast,errbnd,
-     *  errmax,error1,erro12,error2,errsum,ertest,f,oflow,points,pts,
-     *  resa,resabs,reseps,result,res3la,rlist,rlist2,sign,temp,uflow
-      integer i,id,ier,ierro,ind1,ind2,iord,ip1,iroff1,iroff2,iroff3,j,
-     *  jlow,jupbnd,k,ksgn,ktmin,last,levcur,level,levmax,limit,maxerr,
-     *  ndin,neval,nint,nintp1,npts,npts2,nres,nrmax,numrl2
-      logical extrap,noext
-c
-c
-      dimension alist(limit),blist(limit),elist(limit),iord(limit),
-     *  level(limit),ndin(npts2),points(npts2),pts(npts2),res3la(3),
-     *  rlist(limit),rlist2(52)
-c
-      external f
-c
-c            the dimension of rlist2 is determined by the value of
-c            limexp in subroutine epsalg (rlist2 should be of dimension
-c            (limexp+2) at least).
-c
-c
-c            list of major variables
-c            -----------------------
-c
-c           alist     - list of left end points of all subintervals
-c                       considered up to now
-c           blist     - list of right end points of all subintervals
-c                       considered up to now
-c           rlist(i)  - approximation to the integral over
-c                       (alist(i),blist(i))
-c           rlist2    - array of dimension at least limexp+2
-c                       containing the part of the epsilon table which
-c                       is still needed for further computations
-c           elist(i)  - error estimate applying to rlist(i)
-c           maxerr    - pointer to the interval with largest error
-c                       estimate
-c           errmax    - elist(maxerr)
-c           erlast    - error on the interval currently subdivided
-c                       (before that subdivision has taken place)
-c           area      - sum of the integrals over the subintervals
-c           errsum    - sum of the errors over the subintervals
-c           errbnd    - requested accuracy max(epsabs,epsrel*
-c                       abs(result))
-c           *****1    - variable for the left subinterval
-c           *****2    - variable for the right subinterval
-c           last      - index for subdivision
-c           nres      - number of calls to the extrapolation routine
-c           numrl2    - number of elements in rlist2. if an appropriate
-c                       approximation to the compounded integral has
-c                       been obtained, it is put in rlist2(numrl2) after
-c                       numrl2 has been increased by one.
-c           erlarg    - sum of the errors over the intervals larger
-c                       than the smallest interval considered up to now
-c           extrap    - logical variable denoting that the routine
-c                       is attempting to perform extrapolation. i.e.
-c                       before subdividing the smallest interval we
-c                       try to decrease the value of erlarg.
-c           noext     - logical variable denoting that extrapolation is
-c                       no longer allowed (true-value)
-c
-c            machine dependent constants
-c            ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c           oflow is the largest positive magnitude.
-c
-c***first executable statement  dqagpe
-      epmach = d1mach(4)
-c
-c            test on validity of parameters
-c            -----------------------------
-c
-      ier = 0
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      alist(1) = a
-      blist(1) = b
-      rlist(1) = 0.0d+00
-      elist(1) = 0.0d+00
-      iord(1) = 0
-      level(1) = 0
-      npts = npts2-2
-      if(npts2.lt.2.or.limit.le.npts.or.(epsabs.le.0.0d+00.and.
-     *  epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28))) ier = 6
-      if(ier.eq.6) go to 999
-c
-c            if any break points are provided, sort them into an
-c            ascending sequence.
-c
-      sign = 1.0d+00
-      if(a.gt.b) sign = -1.0d+00
-      pts(1) = dmin1(a,b)
-      if(npts.eq.0) go to 15
-      do 10 i = 1,npts
-        pts(i+1) = points(i)
-   10 continue
-   15 pts(npts+2) = dmax1(a,b)
-      nint = npts+1
-      a1 = pts(1)
-      if(npts.eq.0) go to 40
-      nintp1 = nint+1
-      do 20 i = 1,nint
-        ip1 = i+1
-        do 20 j = ip1,nintp1
-          if(pts(i).le.pts(j)) go to 20
-          temp = pts(i)
-          pts(i) = pts(j)
-          pts(j) = temp
-   20 continue
-      if(pts(1).ne.dmin1(a,b).or.pts(nintp1).ne.dmax1(a,b)) ier = 6
-      if(ier.eq.6) go to 999
-c
-c            compute first integral and error approximations.
-c            ------------------------------------------------
-c
-   40 resabs = 0.0d+00
-      do 50 i = 1,nint
-        b1 = pts(i+1)
-        call dqk21(f,a1,b1,area1,error1,defabs,resa)
-        abserr = abserr+error1
-        result = result+area1
-        ndin(i) = 0
-        if(error1.eq.resa.and.error1.ne.0.0d+00) ndin(i) = 1
-        resabs = resabs+defabs
-        level(i) = 0
-        elist(i) = error1
-        alist(i) = a1
-        blist(i) = b1
-        rlist(i) = area1
-        iord(i) = i
-        a1 = b1
-   50 continue
-      errsum = 0.0d+00
-      do 55 i = 1,nint
-        if(ndin(i).eq.1) elist(i) = abserr
-        errsum = errsum+elist(i)
-   55 continue
-c
-c           test on accuracy.
-c
-      last = nint
-      neval = 21*nint
-      dres = dabs(result)
-      errbnd = dmax1(epsabs,epsrel*dres)
-      if(abserr.le.0.1d+03*epmach*resabs.and.abserr.gt.errbnd) ier = 2
-      if(nint.eq.1) go to 80
-      do 70 i = 1,npts
-        jlow = i+1
-        ind1 = iord(i)
-        do 60 j = jlow,nint
-          ind2 = iord(j)
-          if(elist(ind1).gt.elist(ind2)) go to 60
-          ind1 = ind2
-          k = j
-   60   continue
-        if(ind1.eq.iord(i)) go to 70
-        iord(k) = iord(i)
-        iord(i) = ind1
-   70 continue
-      if(limit.lt.npts2) ier = 1
-   80 if(ier.ne.0.or.abserr.le.errbnd) go to 210
-c
-c           initialization
-c           --------------
-c
-      rlist2(1) = result
-      maxerr = iord(1)
-      errmax = elist(maxerr)
-      area = result
-      nrmax = 1
-      nres = 0
-      numrl2 = 1
-      ktmin = 0
-      extrap = .false.
-      noext = .false.
-      erlarg = errsum
-      ertest = errbnd
-      levmax = 1
-      iroff1 = 0
-      iroff2 = 0
-      iroff3 = 0
-      ierro = 0
-      uflow = d1mach(1)
-      oflow = d1mach(2)
-      abserr = oflow
-      ksgn = -1
-      if(dres.ge.(0.1d+01-0.5d+02*epmach)*resabs) ksgn = 1
-c
-c           main do-loop
-c           ------------
-c
-      do 160 last = npts2,limit
-c
-c           bisect the subinterval with the nrmax-th largest error
-c           estimate.
-c
-        levcur = level(maxerr)+1
-        a1 = alist(maxerr)
-        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
-        a2 = b1
-        b2 = blist(maxerr)
-        erlast = errmax
-        call dqk21(f,a1,b1,area1,error1,resa,defab1)
-        call dqk21(f,a2,b2,area2,error2,resa,defab2)
-c
-c           improve previous approximations to integral
-c           and error and test for accuracy.
-c
-        neval = neval+42
-        area12 = area1+area2
-        erro12 = error1+error2
-        errsum = errsum+erro12-errmax
-        area = area+area12-rlist(maxerr)
-        if(defab1.eq.error1.or.defab2.eq.error2) go to 95
-        if(dabs(rlist(maxerr)-area12).gt.0.1d-04*dabs(area12)
-     *  .or.erro12.lt.0.99d+00*errmax) go to 90
-        if(extrap) iroff2 = iroff2+1
-        if(.not.extrap) iroff1 = iroff1+1
-   90   if(last.gt.10.and.erro12.gt.errmax) iroff3 = iroff3+1
-   95   level(maxerr) = levcur
-        level(last) = levcur
-        rlist(maxerr) = area1
-        rlist(last) = area2
-        errbnd = dmax1(epsabs,epsrel*dabs(area))
-c
-c           test for roundoff error and eventually set error flag.
-c
-        if(iroff1+iroff2.ge.10.or.iroff3.ge.20) ier = 2
-        if(iroff2.ge.5) ierro = 3
-c
-c           set error flag in the case that the number of
-c           subintervals equals limit.
-c
-        if(last.eq.limit) ier = 1
-c
-c           set error flag in the case of bad integrand behaviour
-c           at a point of the integration range
-c
-        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*epmach)*
-     *  (dabs(a2)+0.1d+04*uflow)) ier = 4
-c
-c           append the newly-created intervals to the list.
-c
-        if(error2.gt.error1) go to 100
-        alist(last) = a2
-        blist(maxerr) = b1
-        blist(last) = b2
-        elist(maxerr) = error1
-        elist(last) = error2
-        go to 110
-  100   alist(maxerr) = a2
-        alist(last) = a1
-        blist(last) = b1
-        rlist(maxerr) = area2
-        rlist(last) = area1
-        elist(maxerr) = error2
-        elist(last) = error1
-c
-c           call subroutine dqpsrt to maintain the descending ordering
-c           in the list of error estimates and select the subinterval
-c           with nrmax-th largest error estimate (to be bisected next).
-c
-  110   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
-c ***jump out of do-loop
-        if(errsum.le.errbnd) go to 190
-c ***jump out of do-loop
-        if(ier.ne.0) go to 170
-        if(noext) go to 160
-        erlarg = erlarg-erlast
-        if(levcur+1.le.levmax) erlarg = erlarg+erro12
-        if(extrap) go to 120
-c
-c           test whether the interval to be bisected next is the
-c           smallest interval.
-c
-        if(level(maxerr)+1.le.levmax) go to 160
-        extrap = .true.
-        nrmax = 2
-  120   if(ierro.eq.3.or.erlarg.le.ertest) go to 140
-c
-c           the smallest interval has the largest error.
-c           before bisecting decrease the sum of the errors over
-c           the larger intervals (erlarg) and perform extrapolation.
-c
-        id = nrmax
-        jupbnd = last
-        if(last.gt.(2+limit/2)) jupbnd = limit+3-last
-        do 130 k = id,jupbnd
-          maxerr = iord(nrmax)
-          errmax = elist(maxerr)
-c ***jump out of do-loop
-          if(level(maxerr)+1.le.levmax) go to 160
-          nrmax = nrmax+1
-  130   continue
-c
-c           perform extrapolation.
-c
-  140   numrl2 = numrl2+1
-        rlist2(numrl2) = area
-        if(numrl2.le.2) go to 155
-        call dqelg(numrl2,rlist2,reseps,abseps,res3la,nres)
-        ktmin = ktmin+1
-        if(ktmin.gt.5.and.abserr.lt.0.1d-02*errsum) ier = 5
-        if(abseps.ge.abserr) go to 150
-        ktmin = 0
-        abserr = abseps
-        result = reseps
-        correc = erlarg
-        ertest = dmax1(epsabs,epsrel*dabs(reseps))
-c ***jump out of do-loop
-        if(abserr.lt.ertest) go to 170
-c
-c           prepare bisection of the smallest interval.
-c
-  150   if(numrl2.eq.1) noext = .true.
-        if(ier.ge.5) go to 170
-  155   maxerr = iord(1)
-        errmax = elist(maxerr)
-        nrmax = 1
-        extrap = .false.
-        levmax = levmax+1
-        erlarg = errsum
-  160 continue
-c
-c           set the final result.
-c           ---------------------
-c
-c
-  170 if(abserr.eq.oflow) go to 190
-      if((ier+ierro).eq.0) go to 180
-      if(ierro.eq.3) abserr = abserr+correc
-      if(ier.eq.0) ier = 3
-      if(result.ne.0.0d+00.and.area.ne.0.0d+00)go to 175
-      if(abserr.gt.errsum)go to 190
-      if(area.eq.0.0d+00) go to 210
-      go to 180
-  175 if(abserr/dabs(result).gt.errsum/dabs(area))go to 190
-c
-c           test on divergence.
-c
-  180 if(ksgn.eq.(-1).and.dmax1(dabs(result),dabs(area)).le.
-     *  resabs*0.1d-01) go to 210
-      if(0.1d-01.gt.(result/area).or.(result/area).gt.0.1d+03.or.
-     *  errsum.gt.dabs(area)) ier = 6
-      go to 210
-c
-c           compute global integral sum.
-c
-  190 result = 0.0d+00
-      do 200 k = 1,last
-        result = result+rlist(k)
-  200 continue
-      abserr = errsum
-  210 if(ier.gt.2) ier = ier-1
-      result = result*sign
-  999 return
-      end
Index: scipy/scipy/integrate/quadpack/dqags.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqags.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,188 +0,0 @@
-      recursive subroutine dqags(f,a,b,epsabs,epsrel,result,abserr,
-     *   neval,ier,limit,lenw,last,iwork,work)
-c***begin prologue  dqags
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a1
-c***keywords  automatic integrator, general-purpose,
-c             (end-point) singularities, extrapolation,
-c             globally adaptive
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & prog. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral  i = integral of f over (a,b),
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c        computation of a definite integral
-c        standard fortran subroutine
-c        double precision version
-c
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine
-c                             the estimates for integral and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more sub-
-c                             divisions by increasing the value of limit
-c                             (and taking the according dimension
-c                             adjustments into account. however, if
-c                             this yields no improvement it is advised
-c                             to analyze the integrand in order to
-c                             determine the integration difficulties. if
-c                             the position of a local difficulty can be
-c                             determined (e.g. singularity,
-c                             discontinuity within the interval) one
-c                             will probably gain from splitting up the
-c                             interval at this point and calling the
-c                             integrator on the subranges. if possible,
-c                             an appropriate special-purpose integrator
-c                             should be used, which is designed for
-c                             handling the type of difficulty involved.
-c                         = 2 the occurrence of roundoff error is detec-
-c                             ted, which prevents the requested
-c                             tolerance from being achieved.
-c                             the error may be under-estimated.
-c                         = 3 extremely bad integrand behaviour
-c                             occurs at some points of the integration
-c                             interval.
-c                         = 4 the algorithm does not converge.
-c                             roundoff error is detected in the
-c                             extrapolation table. it is presumed that
-c                             the requested tolerance cannot be
-c                             achieved, and that the returned result is
-c                             the best which can be obtained.
-c                         = 5 the integral is probably divergent, or
-c                             slowly convergent. it must be noted that
-c                             divergence can occur with any other value
-c                             of ier.
-c                         = 6 the input is invalid, because
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28)
-c                             or limit.lt.1 or lenw.lt.limit*4.
-c                             result, abserr, neval, last are set to
-c                             zero.except when limit or lenw is invalid,
-c                             iwork(1), work(limit*2+1) and
-c                             work(limit*3+1) are set to zero, work(1)
-c                             is set to a and work(limit+1) to b.
-c
-c         dimensioning parameters
-c            limit - integer
-c                    dimensioning parameter for iwork
-c                    limit determines the maximum number of subintervals
-c                    in the partition of the given integration interval
-c                    (a,b), limit.ge.1.
-c                    if limit.lt.1, the routine will end with ier = 6.
-c
-c            lenw  - integer
-c                    dimensioning parameter for work
-c                    lenw must be at least limit*4.
-c                    if lenw.lt.limit*4, the routine will end
-c                    with ier = 6.
-c
-c            last  - integer
-c                    on return, last equals the number of subintervals
-c                    produced in the subdivision process, determines the
-c                    number of significant elements actually in the work
-c                    arrays.
-c
-c         work arrays
-c            iwork - integer
-c                    vector of dimension at least limit, the first k
-c                    elements of which contain pointers
-c                    to the error estimates over the subintervals
-c                    such that work(limit*3+iwork(1)),... ,
-c                    work(limit*3+iwork(k)) form a decreasing
-c                    sequence, with k = last if last.le.(limit/2+2),
-c                    and k = limit+1-last otherwise
-c
-c            work  - double precision
-c                    vector of dimension at least lenw
-c                    on return
-c                    work(1), ..., work(last) contain the left
-c                     end-points of the subintervals in the
-c                     partition of (a,b),
-c                    work(limit+1), ..., work(limit+last) contain
-c                     the right end-points,
-c                    work(limit*2+1), ..., work(limit*2+last) contain
-c                     the integral approximations over the subintervals,
-c                    work(limit*3+1), ..., work(limit*3+last)
-c                     contain the error estimates.
-c
-c***references  (none)
-c***routines called  dqagse,xerror
-c***end prologue  dqags
-c
-c
-      double precision a,abserr,b,epsabs,epsrel,f,result,work
-      integer ier,iwork,last,lenw,limit,lvl,l1,l2,l3,neval
-c
-      dimension iwork(limit),work(lenw)
-c
-      external f
-c
-c         check validity of limit and lenw.
-c
-c***first executable statement  dqags
-      ier = 6
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(limit.lt.1.or.lenw.lt.limit*4) go to 10
-c
-c         prepare call for dqagse.
-c
-      l1 = limit+1
-      l2 = limit+l1
-      l3 = limit+l2
-c
-      call dqagse(f,a,b,epsabs,epsrel,limit,result,abserr,neval,
-     *  ier,work(1),work(l1),work(l2),work(l3),iwork,last)
-c
-c         call error handler if necessary.
-c
-      lvl = 0
-10    if(ier.eq.6) lvl = 1
-      if(ier.ne.0) call xerror('abnormal return from dqags',26,ier,lvl)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqagse.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqagse.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,444 +0,0 @@
-      recursive subroutine dqagse(f,a,b,epsabs,epsrel,limit,result,
-     *   abserr,neval,ier,alist,blist,rlist,elist,iord,last)
-c***begin prologue  dqagse
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a1
-c***keywords  automatic integrator, general-purpose,
-c             (end point) singularities, extrapolation,
-c             globally adaptive
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral i = integral of f over (a,b),
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c        computation of a definite integral
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c            limit  - integer
-c                     gives an upperbound on the number of subintervals
-c                     in the partition of (a,b)
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine
-c                             the estimates for integral and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                         = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more sub-
-c                             divisions by increasing the value of limit
-c                             (and taking the according dimension
-c                             adjustments into account). however, if
-c                             this yields no improvement it is advised
-c                             to analyze the integrand in order to
-c                             determine the integration difficulties. if
-c                             the position of a local difficulty can be
-c                             determined (e.g. singularity,
-c                             discontinuity within the interval) one
-c                             will probably gain from splitting up the
-c                             interval at this point and calling the
-c                             integrator on the subranges. if possible,
-c                             an appropriate special-purpose integrator
-c                             should be used, which is designed for
-c                             handling the type of difficulty involved.
-c                         = 2 the occurrence of roundoff error is detec-
-c                             ted, which prevents the requested
-c                             tolerance from being achieved.
-c                             the error may be under-estimated.
-c                         = 3 extremely bad integrand behaviour
-c                             occurs at some points of the integration
-c                             interval.
-c                         = 4 the algorithm does not converge.
-c                             roundoff error is detected in the
-c                             extrapolation table.
-c                             it is presumed that the requested
-c                             tolerance cannot be achieved, and that the
-c                             returned result is the best which can be
-c                             obtained.
-c                         = 5 the integral is probably divergent, or
-c                             slowly convergent. it must be noted that
-c                             divergence can occur with any other value
-c                             of ier.
-c                         = 6 the input is invalid, because
-c                             epsabs.le.0 and
-c                             epsrel.lt.max(50*rel.mach.acc.,0.5d-28).
-c                             result, abserr, neval, last, rlist(1),
-c                             iord(1) and elist(1) are set to zero.
-c                             alist(1) and blist(1) are set to a and b
-c                             respectively.
-c
-c            alist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the left end points
-c                     of the subintervals in the partition of the
-c                     given integration range (a,b)
-c
-c            blist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the right end points
-c                     of the subintervals in the partition of the given
-c                     integration range (a,b)
-c
-c            rlist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the integral
-c                     approximations on the subintervals
-c
-c            elist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the moduli of the
-c                     absolute error estimates on the subintervals
-c
-c            iord   - integer
-c                     vector of dimension at least limit, the first k
-c                     elements of which are pointers to the
-c                     error estimates over the subintervals,
-c                     such that elist(iord(1)), ..., elist(iord(k))
-c                     form a decreasing sequence, with k = last
-c                     if last.le.(limit/2+2), and k = limit+1-last
-c                     otherwise
-c
-c            last   - integer
-c                     number of subintervals actually produced in the
-c                     subdivision process
-c
-c***references  (none)
-c***routines called  d1mach,dqelg,dqk21,dqpsrt
-c***end prologue  dqagse
-c
-      double precision a,abseps,abserr,alist,area,area1,area12,area2,a1,
-     *  a2,b,blist,b1,b2,correc,dabs,defabs,defab1,defab2,d1mach,dmax1,
-     *  dres,elist,epmach,epsabs,epsrel,erlarg,erlast,errbnd,errmax,
-     *  error1,error2,erro12,errsum,ertest,f,oflow,resabs,reseps,result,
-     *  res3la,rlist,rlist2,small,uflow
-      integer id,ier,ierro,iord,iroff1,iroff2,iroff3,jupbnd,k,ksgn,
-     *  ktmin,last,limit,maxerr,neval,nres,nrmax,numrl2
-      logical extrap,noext
-c
-      dimension alist(limit),blist(limit),elist(limit),iord(limit),
-     * res3la(3),rlist(limit),rlist2(52)
-c
-      external f
-c
-c            the dimension of rlist2 is determined by the value of
-c            limexp in subroutine dqelg (rlist2 should be of dimension
-c            (limexp+2) at least).
-c
-c            list of major variables
-c            -----------------------
-c
-c           alist     - list of left end points of all subintervals
-c                       considered up to now
-c           blist     - list of right end points of all subintervals
-c                       considered up to now
-c           rlist(i)  - approximation to the integral over
-c                       (alist(i),blist(i))
-c           rlist2    - array of dimension at least limexp+2 containing
-c                       the part of the epsilon table which is still
-c                       needed for further computations
-c           elist(i)  - error estimate applying to rlist(i)
-c           maxerr    - pointer to the interval with largest error
-c                       estimate
-c           errmax    - elist(maxerr)
-c           erlast    - error on the interval currently subdivided
-c                       (before that subdivision has taken place)
-c           area      - sum of the integrals over the subintervals
-c           errsum    - sum of the errors over the subintervals
-c           errbnd    - requested accuracy max(epsabs,epsrel*
-c                       abs(result))
-c           *****1    - variable for the left interval
-c           *****2    - variable for the right interval
-c           last      - index for subdivision
-c           nres      - number of calls to the extrapolation routine
-c           numrl2    - number of elements currently in rlist2. if an
-c                       appropriate approximation to the compounded
-c                       integral has been obtained it is put in
-c                       rlist2(numrl2) after numrl2 has been increased
-c                       by one.
-c           small     - length of the smallest interval considered up
-c                       to now, multiplied by 1.5
-c           erlarg    - sum of the errors over the intervals larger
-c                       than the smallest interval considered up to now
-c           extrap    - logical variable denoting that the routine is
-c                       attempting to perform extrapolation i.e. before
-c                       subdividing the smallest interval we try to
-c                       decrease the value of erlarg.
-c           noext     - logical variable denoting that extrapolation
-c                       is no longer allowed (true value)
-c
-c            machine dependent constants
-c            ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c           oflow is the largest positive magnitude.
-c
-c***first executable statement  dqagse
-      epmach = d1mach(4)
-c
-c            test on validity of parameters
-c            ------------------------------
-      ier = 0
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      alist(1) = a
-      blist(1) = b
-      rlist(1) = 0.0d+00
-      elist(1) = 0.0d+00
-      if(epsabs.le.0.0d+00.and.epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28))
-     *   ier = 6
-      if(ier.eq.6) go to 999
-c
-c           first approximation to the integral
-c           -----------------------------------
-c
-      uflow = d1mach(1)
-      oflow = d1mach(2)
-      ierro = 0
-      call dqk21(f,a,b,result,abserr,defabs,resabs)
-c
-c           test on accuracy.
-c
-      dres = dabs(result)
-      errbnd = dmax1(epsabs,epsrel*dres)
-      last = 1
-      rlist(1) = result
-      elist(1) = abserr
-      iord(1) = 1
-      if(abserr.le.1.0d+02*epmach*defabs.and.abserr.gt.errbnd) ier = 2
-      if(limit.eq.1) ier = 1
-      if(ier.ne.0.or.(abserr.le.errbnd.and.abserr.ne.resabs).or.
-     *  abserr.eq.0.0d+00) go to 140
-c
-c           initialization
-c           --------------
-c
-      rlist2(1) = result
-      errmax = abserr
-      maxerr = 1
-      area = result
-      errsum = abserr
-      abserr = oflow
-      nrmax = 1
-      nres = 0
-      numrl2 = 2
-      ktmin = 0
-      extrap = .false.
-      noext = .false.
-      iroff1 = 0
-      iroff2 = 0
-      iroff3 = 0
-      ksgn = -1
-      if(dres.ge.(0.1d+01-0.5d+02*epmach)*defabs) ksgn = 1
-c
-c           main do-loop
-c           ------------
-c
-      do 90 last = 2,limit
-c
-c           bisect the subinterval with the nrmax-th largest error
-c           estimate.
-c
-        a1 = alist(maxerr)
-        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
-        a2 = b1
-        b2 = blist(maxerr)
-        erlast = errmax
-        call dqk21(f,a1,b1,area1,error1,resabs,defab1)
-        call dqk21(f,a2,b2,area2,error2,resabs,defab2)
-c
-c           improve previous approximations to integral
-c           and error and test for accuracy.
-c
-        area12 = area1+area2
-        erro12 = error1+error2
-        errsum = errsum+erro12-errmax
-        area = area+area12-rlist(maxerr)
-        if(defab1.eq.error1.or.defab2.eq.error2) go to 15
-        if(dabs(rlist(maxerr)-area12).gt.0.1d-04*dabs(area12)
-     *  .or.erro12.lt.0.99d+00*errmax) go to 10
-        if(extrap) iroff2 = iroff2+1
-        if(.not.extrap) iroff1 = iroff1+1
-   10   if(last.gt.10.and.erro12.gt.errmax) iroff3 = iroff3+1
-   15   rlist(maxerr) = area1
-        rlist(last) = area2
-        errbnd = dmax1(epsabs,epsrel*dabs(area))
-c
-c           test for roundoff error and eventually set error flag.
-c
-        if(iroff1+iroff2.ge.10.or.iroff3.ge.20) ier = 2
-        if(iroff2.ge.5) ierro = 3
-c
-c           set error flag in the case that the number of subintervals
-c           equals limit.
-c
-        if(last.eq.limit) ier = 1
-c
-c           set error flag in the case of bad integrand behaviour
-c           at a point of the integration range.
-c
-        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*epmach)*
-     *  (dabs(a2)+0.1d+04*uflow)) ier = 4
-c
-c           append the newly-created intervals to the list.
-c
-        if(error2.gt.error1) go to 20
-        alist(last) = a2
-        blist(maxerr) = b1
-        blist(last) = b2
-        elist(maxerr) = error1
-        elist(last) = error2
-        go to 30
-   20   alist(maxerr) = a2
-        alist(last) = a1
-        blist(last) = b1
-        rlist(maxerr) = area2
-        rlist(last) = area1
-        elist(maxerr) = error2
-        elist(last) = error1
-c
-c           call subroutine dqpsrt to maintain the descending ordering
-c           in the list of error estimates and select the subinterval
-c           with nrmax-th largest error estimate (to be bisected next).
-c
-   30   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
-c ***jump out of do-loop
-        if(errsum.le.errbnd) go to 115
-c ***jump out of do-loop
-        if(ier.ne.0) go to 100
-        if(last.eq.2) go to 80
-        if(noext) go to 90
-        erlarg = erlarg-erlast
-        if(dabs(b1-a1).gt.small) erlarg = erlarg+erro12
-        if(extrap) go to 40
-c
-c           test whether the interval to be bisected next is the
-c           smallest interval.
-c
-        if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 90
-        extrap = .true.
-        nrmax = 2
-   40   if(ierro.eq.3.or.erlarg.le.ertest) go to 60
-c
-c           the smallest interval has the largest error.
-c           before bisecting decrease the sum of the errors over the
-c           larger intervals (erlarg) and perform extrapolation.
-c
-        id = nrmax
-        jupbnd = last
-        if(last.gt.(2+limit/2)) jupbnd = limit+3-last
-        do 50 k = id,jupbnd
-          maxerr = iord(nrmax)
-          errmax = elist(maxerr)
-c ***jump out of do-loop
-          if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 90
-          nrmax = nrmax+1
-   50   continue
-c
-c           perform extrapolation.
-c
-   60   numrl2 = numrl2+1
-        rlist2(numrl2) = area
-        call dqelg(numrl2,rlist2,reseps,abseps,res3la,nres)
-        ktmin = ktmin+1
-        if(ktmin.gt.5.and.abserr.lt.0.1d-02*errsum) ier = 5
-        if(abseps.ge.abserr) go to 70
-        ktmin = 0
-        abserr = abseps
-        result = reseps
-        correc = erlarg
-        ertest = dmax1(epsabs,epsrel*dabs(reseps))
-c ***jump out of do-loop
-        if(abserr.le.ertest) go to 100
-c
-c           prepare bisection of the smallest interval.
-c
-   70   if(numrl2.eq.1) noext = .true.
-        if(ier.eq.5) go to 100
-        maxerr = iord(1)
-        errmax = elist(maxerr)
-        nrmax = 1
-        extrap = .false.
-        small = small*0.5d+00
-        erlarg = errsum
-        go to 90
-   80   small = dabs(b-a)*0.375d+00
-        erlarg = errsum
-        ertest = errbnd
-        rlist2(2) = area
-   90 continue
-c
-c           set final result and error estimate.
-c           ------------------------------------
-c
-  100 if(abserr.eq.oflow) go to 115
-      if(ier+ierro.eq.0) go to 110
-      if(ierro.eq.3) abserr = abserr+correc
-      if(ier.eq.0) ier = 3
-      if(result.ne.0.0d+00.and.area.ne.0.0d+00) go to 105
-      if(abserr.gt.errsum) go to 115
-      if(area.eq.0.0d+00) go to 130
-      go to 110
-  105 if(abserr/dabs(result).gt.errsum/dabs(area)) go to 115
-c
-c           test on divergence.
-c
-  110 if(ksgn.eq.(-1).and.dmax1(dabs(result),dabs(area)).le.
-     * defabs*0.1d-01) go to 130
-      if(0.1d-01.gt.(result/area).or.(result/area).gt.0.1d+03
-     * .or.errsum.gt.dabs(area)) ier = 6
-      go to 130
-c
-c           compute global integral sum.
-c
-  115 result = 0.0d+00
-      do 120 k = 1,last
-         result = result+rlist(k)
-  120 continue
-      abserr = errsum
-  130 if(ier.gt.2) ier = ier-1
-  140 neval = 42*last-21
-  999 return
-      end
Index: scipy/scipy/integrate/quadpack/dqawc.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqawc.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,178 +0,0 @@
-      recursive subroutine dqawc(f,a,b,c,epsabs,epsrel,result,abserr,
-     *   neval,ier,limit,lenw,last,iwork,work)
-c***begin prologue  dqawc
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a1,j4
-c***keywords  automatic integrator, special-purpose,
-c             cauchy principal value,
-c             clenshaw-curtis, globally adaptive
-c***author  piessens,robert ,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a
-c            cauchy principal value i = integral of f*w over (a,b)
-c            (w(x) = 1/((x-c), c.ne.a, c.ne.b), hopefully satisfying
-c            following claim for accuracy
-c            abs(i-result).le.max(epsabe,epsrel*abs(i)).
-c***description
-c
-c        computation of a cauchy principal value
-c        standard fortran subroutine
-c        double precision version
-c
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     under limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            c      - parameter in the weight function, c.ne.a, c.ne.b.
-c                     if c = a or c = b, the routine will end with
-c                     ier = 6 .
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate or the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine
-c                             the estimates for integral and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more sub-
-c                             divisions by increasing the value of limit
-c                             (and taking the according dimension
-c                             adjustments into account). however, if
-c                             this yields no improvement it is advised
-c                             to analyze the integrand in order to
-c                             determine the integration difficulties.
-c                             if the position of a local difficulty
-c                             can be determined (e.g. singularity,
-c                             discontinuity within the interval) one
-c                             will probably gain from splitting up the
-c                             interval at this point and calling
-c                             appropriate integrators on the subranges.
-c                         = 2 the occurrence of roundoff error is detec-
-c                             ted, which prevents the requested
-c                             tolerance from being achieved.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 6 the input is invalid, because
-c                             c = a or c = b or
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
-c                             or limit.lt.1 or lenw.lt.limit*4.
-c                             result, abserr, neval, last are set to
-c                             zero. except when lenw or limit is invalid,
-c                             iwork(1), work(limit*2+1) and
-c                             work(limit*3+1) are set to zero, work(1)
-c                             is set to a and work(limit+1) to b.
-c
-c         dimensioning parameters
-c            limit - integer
-c                    dimensioning parameter for iwork
-c                    limit determines the maximum number of subintervals
-c                    in the partition of the given integration interval
-c                    (a,b), limit.ge.1.
-c                    if limit.lt.1, the routine will end with ier = 6.
-c
-c           lenw   - integer
-c                    dimensioning parameter for work
-c                    lenw must be at least limit*4.
-c                    if lenw.lt.limit*4, the routine will end with
-c                    ier = 6.
-c
-c            last  - integer
-c                    on return, last equals the number of subintervals
-c                    produced in the subdivision process, which
-c                    determines the number of significant elements
-c                    actually in the work arrays.
-c
-c         work arrays
-c            iwork - integer
-c                    vector of dimension at least limit, the first k
-c                    elements of which contain pointers
-c                    to the error estimates over the subintervals,
-c                    such that work(limit*3+iwork(1)), ... ,
-c                    work(limit*3+iwork(k)) form a decreasing
-c                    sequence, with k = last if last.le.(limit/2+2),
-c                    and k = limit+1-last otherwise
-c
-c            work  - double precision
-c                    vector of dimension at least lenw
-c                    on return
-c                    work(1), ..., work(last) contain the left
-c                     end points of the subintervals in the
-c                     partition of (a,b),
-c                    work(limit+1), ..., work(limit+last) contain
-c                     the right end points,
-c                    work(limit*2+1), ..., work(limit*2+last) contain
-c                     the integral approximations over the subintervals,
-c                    work(limit*3+1), ..., work(limit*3+last)
-c                     contain the error estimates.
-c
-c***references  (none)
-c***routines called  dqawce,xerror
-c***end prologue  dqawc
-c
-      double precision a,abserr,b,c,epsabs,epsrel,f,result,work
-      integer ier,iwork,last,lenw,limit,lvl,l1,l2,l3,neval
-c
-      dimension iwork(limit),work(lenw)
-c
-      external f
-c
-c         check validity of limit and lenw.
-c
-c***first executable statement  dqawc
-      ier = 6
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(limit.lt.1.or.lenw.lt.limit*4) go to 10
-c
-c         prepare call for dqawce.
-c
-      l1 = limit+1
-      l2 = limit+l1
-      l3 = limit+l2
-      call dqawce(f,a,b,c,epsabs,epsrel,limit,result,abserr,neval,ier,
-     *  work(1),work(l1),work(l2),work(l3),iwork,last)
-c
-c         call error handler if necessary.
-c
-      lvl = 0
-10    if(ier.eq.6) lvl = 1
-      if(ier.ne.0) call xerror('abnormal return from dqawc',26,ier,lvl)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqawce.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqawce.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,326 +0,0 @@
-      recursive subroutine dqawce(f,a,b,c,epsabs,epsrel,limit,result,
-     *   abserr,neval,ier,alist,blist,rlist,elist,iord,last)
-c***begin prologue  dqawce
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a1,j4
-c***keywords  automatic integrator, special-purpose,
-c             cauchy principal value, clenshaw-curtis method
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***  purpose  the routine calculates an approximation result to a
-c              cauchy principal value i = integral of f*w over (a,b)
-c              (w(x) = 1/(x-c), (c.ne.a, c.ne.b), hopefully satisfying
-c              following claim for accuracy
-c              abs(i-result).le.max(epsabs,epsrel*abs(i))
-c***description
-c
-c        computation of a cauchy principal value
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            c      - double precision
-c                     parameter in the weight function, c.ne.a, c.ne.b
-c                     if c = a or c = b, the routine will end with
-c                     ier = 6.
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c            limit  - integer
-c                     gives an upper bound on the number of subintervals
-c                     in the partition of (a,b), limit.ge.1
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine
-c                             the estimates for integral and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more sub-
-c                             divisions by increasing the value of
-c                             limit. however, if this yields no
-c                             improvement it is advised to analyze the
-c                             the integrand, in order to determine the
-c                             the integration difficulties. if the
-c                             position of a local difficulty can be
-c                             determined (e.g. singularity,
-c                             discontinuity within the interval) one
-c                             will probably gain from splitting up the
-c                             interval at this point and calling
-c                             appropriate integrators on the subranges.
-c                         = 2 the occurrence of roundoff error is detec-
-c                             ted, which prevents the requested
-c                             tolerance from being achieved.
-c                         = 3 extremely bad integrand behaviour
-c                             occurs at some interior points of
-c                             the integration interval.
-c                         = 6 the input is invalid, because
-c                             c = a or c = b or
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
-c                             or limit.lt.1.
-c                             result, abserr, neval, rlist(1), elist(1),
-c                             iord(1) and last are set to zero. alist(1)
-c                             and blist(1) are set to a and b
-c                             respectively.
-c
-c            alist   - double precision
-c                      vector of dimension at least limit, the first
-c                       last  elements of which are the left
-c                      end points of the subintervals in the partition
-c                      of the given integration range (a,b)
-c
-c            blist   - double precision
-c                      vector of dimension at least limit, the first
-c                       last  elements of which are the right
-c                      end points of the subintervals in the partition
-c                      of the given integration range (a,b)
-c
-c            rlist   - double precision
-c                      vector of dimension at least limit, the first
-c                       last  elements of which are the integral
-c                      approximations on the subintervals
-c
-c            elist   - double precision
-c                      vector of dimension limit, the first  last
-c                      elements of which are the moduli of the absolute
-c                      error estimates on the subintervals
-c
-c            iord    - integer
-c                      vector of dimension at least limit, the first k
-c                      elements of which are pointers to the error
-c                      estimates over the subintervals, so that
-c                      elist(iord(1)), ..., elist(iord(k)) with k = last
-c                      if last.le.(limit/2+2), and k = limit+1-last
-c                      otherwise, form a decreasing sequence
-c
-c            last    - integer
-c                      number of subintervals actually produced in
-c                      the subdivision process
-c
-c***references  (none)
-c***routines called  d1mach,dqc25c,dqpsrt
-c***end prologue  dqawce
-c
-      double precision a,aa,abserr,alist,area,area1,area12,area2,a1,a2,
-     *  b,bb,blist,b1,b2,c,dabs,dmax1,d1mach,elist,epmach,epsabs,epsrel,
-     *  errbnd,errmax,error1,erro12,error2,errsum,f,result,rlist,uflow
-      integer ier,iord,iroff1,iroff2,k,krule,last,limit,maxerr,nev,
-     *  neval,nrmax
-c
-      dimension alist(limit),blist(limit),rlist(limit),elist(limit),
-     *  iord(limit)
-c
-      external f
-c
-c            list of major variables
-c            -----------------------
-c
-c           alist     - list of left end points of all subintervals
-c                       considered up to now
-c           blist     - list of right end points of all subintervals
-c                       considered up to now
-c           rlist(i)  - approximation to the integral over
-c                       (alist(i),blist(i))
-c           elist(i)  - error estimate applying to rlist(i)
-c           maxerr    - pointer to the interval with largest
-c                       error estimate
-c           errmax    - elist(maxerr)
-c           area      - sum of the integrals over the subintervals
-c           errsum    - sum of the errors over the subintervals
-c           errbnd    - requested accuracy max(epsabs,epsrel*
-c                       abs(result))
-c           *****1    - variable for the left subinterval
-c           *****2    - variable for the right subinterval
-c           last      - index for subdivision
-c
-c
-c            machine dependent constants
-c            ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-c***first executable statement  dqawce
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-c
-c           test on validity of parameters
-c           ------------------------------
-c
-      ier = 6
-      neval = 0
-      last = 0
-      alist(1) = a
-      blist(1) = b
-      rlist(1) = 0.0d+00
-      elist(1) = 0.0d+00
-      iord(1) = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(c.eq.a.or.c.eq.b.or.(epsabs.le.0.0d+00.and
-     *  .epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28))) go to 999
-c
-c           first approximation to the integral
-c           -----------------------------------
-c
-      aa=a
-      bb=b
-      if (a.le.b) go to 10
-      aa=b
-      bb=a
-10    ier=0
-      krule = 1
-      call dqc25c(f,aa,bb,c,result,abserr,krule,neval)
-      last = 1
-      rlist(1) = result
-      elist(1) = abserr
-      iord(1) = 1
-      alist(1) = a
-      blist(1) = b
-c
-c           test on accuracy
-c
-      errbnd = dmax1(epsabs,epsrel*dabs(result))
-      if(limit.eq.1) ier = 1
-      if(abserr.lt.dmin1(0.1d-01*dabs(result),errbnd)
-     *  .or.ier.eq.1) go to 70
-c
-c           initialization
-c           --------------
-c
-      alist(1) = aa
-      blist(1) = bb
-      rlist(1) = result
-      errmax = abserr
-      maxerr = 1
-      area = result
-      errsum = abserr
-      nrmax = 1
-      iroff1 = 0
-      iroff2 = 0
-c
-c           main do-loop
-c           ------------
-c
-      do 40 last = 2,limit
-c
-c           bisect the subinterval with nrmax-th largest
-c           error estimate.
-c
-        a1 = alist(maxerr)
-        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
-        b2 = blist(maxerr)
-        if(c.le.b1.and.c.gt.a1) b1 = 0.5d+00*(c+b2)
-        if(c.gt.b1.and.c.lt.b2) b1 = 0.5d+00*(a1+c)
-        a2 = b1
-        krule = 2
-        call dqc25c(f,a1,b1,c,area1,error1,krule,nev)
-        neval = neval+nev
-        call dqc25c(f,a2,b2,c,area2,error2,krule,nev)
-        neval = neval+nev
-c
-c           improve previous approximations to integral
-c           and error and test for accuracy.
-c
-        area12 = area1+area2
-        erro12 = error1+error2
-        errsum = errsum+erro12-errmax
-        area = area+area12-rlist(maxerr)
-        if(dabs(rlist(maxerr)-area12).lt.0.1d-04*dabs(area12)
-     *    .and.erro12.ge.0.99d+00*errmax.and.krule.eq.0)
-     *    iroff1 = iroff1+1
-        if(last.gt.10.and.erro12.gt.errmax.and.krule.eq.0)
-     *    iroff2 = iroff2+1
-        rlist(maxerr) = area1
-        rlist(last) = area2
-        errbnd = dmax1(epsabs,epsrel*dabs(area))
-        if(errsum.le.errbnd) go to 15
-c
-c           test for roundoff error and eventually set error flag.
-c
-        if(iroff1.ge.6.and.iroff2.gt.20) ier = 2
-c
-c           set error flag in the case that number of interval
-c           bisections exceeds limit.
-c
-        if(last.eq.limit) ier = 1
-c
-c           set error flag in the case of bad integrand behaviour
-c           at a point of the integration range.
-c
-        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*epmach)
-     *    *(dabs(a2)+0.1d+04*uflow)) ier = 3
-c
-c           append the newly-created intervals to the list.
-c
-   15   if(error2.gt.error1) go to 20
-        alist(last) = a2
-        blist(maxerr) = b1
-        blist(last) = b2
-        elist(maxerr) = error1
-        elist(last) = error2
-        go to 30
-   20   alist(maxerr) = a2
-        alist(last) = a1
-        blist(last) = b1
-        rlist(maxerr) = area2
-        rlist(last) = area1
-        elist(maxerr) = error2
-        elist(last) = error1
-c
-c           call subroutine dqpsrt to maintain the descending ordering
-c           in the list of error estimates and select the subinterval
-c           with nrmax-th largest error estimate (to be bisected next).
-c
-   30    call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
-c ***jump out of do-loop
-        if(ier.ne.0.or.errsum.le.errbnd) go to 50
-   40 continue
-c
-c           compute final result.
-c           ---------------------
-c
-   50 result = 0.0d+00
-      do 60 k=1,last
-        result = result+rlist(k)
-   60 continue
-      abserr = errsum
-   70 if (aa.eq.b) result=-result
-  999 return
-      end
Index: scipy/scipy/integrate/quadpack/dqawf.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqawf.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,231 +0,0 @@
-      recursive subroutine dqawf(f,a,omega,integr,epsabs,result,
-     *   abserr,neval,ier,limlst,lst,leniw,maxp1,lenw,iwork,work)
-c***begin prologue  dqawf
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a3a1
-c***keywords  automatic integrator, special-purpose,fourier
-c             integral, integration between zeros with dqawoe,
-c             convergence acceleration with dqelg
-c***author  piessens,robert ,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            fourier integral i=integral of f(x)*w(x) over (a,infinity)
-c            where w(x) = cos(omega*x) or w(x) = sin(omega*x).
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.epsabs.
-c***description
-c
-c        computation of fourier integrals
-c        standard fortran subroutine
-c        double precision version
-c
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            omega  - double precision
-c                     parameter in the integrand weight function
-c
-c            integr - integer
-c                     indicates which of the weight functions is used
-c                     integr = 1      w(x) = cos(omega*x)
-c                     integr = 2      w(x) = sin(omega*x)
-c                     if integr.ne.1.and.integr.ne.2, the routine
-c                     will end with ier = 6.
-c
-c            epsabs - double precision
-c                     absolute accuracy requested, epsabs.gt.0.
-c                     if epsabs.le.0, the routine will end with ier = 6.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine.
-c                             the estimates for integral and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                    if omega.ne.0
-c                     ier = 1 maximum number of cycles allowed
-c                             has been achieved, i.e. of subintervals
-c                             (a+(k-1)c,a+kc) where
-c                             c = (2*int(abs(omega))+1)*pi/abs(omega),
-c                             for k = 1, 2, ..., lst.
-c                             one can allow more cycles by increasing
-c                             the value of limlst (and taking the
-c                             according dimension adjustments into
-c                             account). examine the array iwork which
-c                             contains the error flags on the cycles, in
-c                             order to look for eventual local
-c                             integration difficulties.
-c                             if the position of a local difficulty
-c                             can be determined (e.g. singularity,
-c                             discontinuity within the interval) one
-c                             will probably gain from splitting up the
-c                             interval at this point and calling
-c                             appropriate integrators on the subranges.
-c                         = 4 the extrapolation table constructed for
-c                             convergence accelaration of the series
-c                             formed by the integral contributions over
-c                             the cycles, does not converge to within
-c                             the requested accuracy.
-c                             as in the case of ier = 1, it is advised
-c                             to examine the array iwork which contains
-c                             the error flags on the cycles.
-c                         = 6 the input is invalid because
-c                             (integr.ne.1 and integr.ne.2) or
-c                              epsabs.le.0 or limlst.lt.1 or
-c                              leniw.lt.(limlst+2) or maxp1.lt.1 or
-c                              lenw.lt.(leniw*2+maxp1*25).
-c                              result, abserr, neval, lst are set to
-c                              zero.
-c                         = 7 bad integrand behaviour occurs within
-c                             one or more of the cycles. location and
-c                             type of the difficulty involved can be
-c                             determined from the first lst elements of
-c                             vector iwork.  here lst is the number of
-c                             cycles actually needed (see below).
-c                             iwork(k) = 1 the maximum number of
-c                                          subdivisions (=(leniw-limlst)
-c                                          /2) has been achieved on the
-c                                          k th cycle.
-c                                      = 2 occurrence of roundoff error
-c                                          is detected and prevents the
-c                                          tolerance imposed on the k th
-c                                          cycle, from being achieved
-c                                          on this cycle.
-c                                      = 3 extremely bad integrand
-c                                          behaviour occurs at some
-c                                          points of the k th cycle.
-c                                      = 4 the integration procedure
-c                                          over the k th cycle does
-c                                          not converge (to within the
-c                                          required accuracy) due to
-c                                          roundoff in the extrapolation
-c                                          procedure invoked on this
-c                                          cycle. it is assumed that the
-c                                          result on this interval is
-c                                          the best which can be
-c                                          obtained.
-c                                      = 5 the integral over the k th
-c                                          cycle is probably divergent
-c                                          or slowly convergent. it must
-c                                          be noted that divergence can
-c                                          occur with any other value of
-c                                          iwork(k).
-c                    if omega = 0 and integr = 1,
-c                    the integral is calculated by means of dqagie,
-c                    and ier = iwork(1) (with meaning as described
-c                    for iwork(k),k = 1).
-c
-c         dimensioning parameters
-c            limlst - integer
-c                     limlst gives an upper bound on the number of
-c                     cycles, limlst.ge.3.
-c                     if limlst.lt.3, the routine will end with ier = 6.
-c
-c            lst    - integer
-c                     on return, lst indicates the number of cycles
-c                     actually needed for the integration.
-c                     if omega = 0, then lst is set to 1.
-c
-c            leniw  - integer
-c                     dimensioning parameter for iwork. on entry,
-c                     (leniw-limlst)/2 equals the maximum number of
-c                     subintervals allowed in the partition of each
-c                     cycle, leniw.ge.(limlst+2).
-c                     if leniw.lt.(limlst+2), the routine will end with
-c                     ier = 6.
-c
-c            maxp1  - integer
-c                     maxp1 gives an upper bound on the number of
-c                     chebyshev moments which can be stored, i.e. for
-c                     the intervals of lengths abs(b-a)*2**(-l),
-c                     l = 0,1, ..., maxp1-2, maxp1.ge.1.
-c                     if maxp1.lt.1, the routine will end with ier = 6.
-c            lenw   - integer
-c                     dimensioning parameter for work
-c                     lenw must be at least leniw*2+maxp1*25.
-c                     if lenw.lt.(leniw*2+maxp1*25), the routine will
-c                     end with ier = 6.
-c
-c         work arrays
-c            iwork  - integer
-c                     vector of dimension at least leniw
-c                     on return, iwork(k) for k = 1, 2, ..., lst
-c                     contain the error flags on the cycles.
-c
-c            work   - double precision
-c                     vector of dimension at least
-c                     on return,
-c                     work(1), ..., work(lst) contain the integral
-c                      approximations over the cycles,
-c                     work(limlst+1), ..., work(limlst+lst) contain
-c                      the error extimates over the cycles.
-c                     further elements of work have no specific
-c                     meaning for the user.
-c
-c***references  (none)
-c***routines called  dqawfe,xerror
-c***end prologue  dqawf
-c
-       double precision a,abserr,epsabs,f,omega,result,work
-       integer ier,integr,iwork,last,leniw,lenw,limit,limlst,ll2,lvl,
-     *  lst,l1,l2,l3,l4,l5,l6,maxp1,neval
-c
-       dimension iwork(leniw),work(lenw)
-c
-       external f
-c
-c         check validity of limlst, leniw, maxp1 and lenw.
-c
-c***first executable statement  dqawf
-      ier = 6
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(limlst.lt.3.or.leniw.lt.(limlst+2).or.maxp1.lt.1.or.lenw.lt.
-     *   (leniw*2+maxp1*25)) go to 10
-c
-c         prepare call for dqawfe
-c
-      limit = (leniw-limlst)/2
-      l1 = limlst+1
-      l2 = limlst+l1
-      l3 = limit+l2
-      l4 = limit+l3
-      l5 = limit+l4
-      l6 = limit+l5
-      ll2 = limit+l1
-      call dqawfe(f,a,omega,integr,epsabs,limlst,limit,maxp1,result,
-     *  abserr,neval,ier,work(1),work(l1),iwork(1),lst,work(l2),
-     *  work(l3),work(l4),work(l5),iwork(l1),iwork(ll2),work(l6))
-c
-c         call error handler if necessary
-c
-      lvl = 0
-10    if(ier.eq.6) lvl = 1
-      if(ier.ne.0) call xerror('abnormal return from dqawf',26,ier,lvl)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqawfe.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqawfe.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,363 +0,0 @@
-      recursive subroutine dqawfe(f,a,omega,integr,epsabs,limlst,
-     *   limit,maxp1,result,abserr,neval,ier,rslst,erlst,ierlst,lst,
-     *   alist,blist,rlist,elist,iord,nnlog,chebmo)
-c***begin prologue  dqawfe
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a3a1
-c***keywords  automatic integrator, special-purpose,
-c             fourier integrals,
-c             integration between zeros with dqawoe,
-c             convergence acceleration with dqelg
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           dedoncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a
-c            given fourier integal
-c            i = integral of f(x)*w(x) over (a,infinity)
-c            where w(x)=cos(omega*x) or w(x)=sin(omega*x),
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.epsabs.
-c***description
-c
-c        computation of fourier integrals
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to
-c                     be declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            omega  - double precision
-c                     parameter in the weight function
-c
-c            integr - integer
-c                     indicates which weight function is used
-c                     integr = 1      w(x) = cos(omega*x)
-c                     integr = 2      w(x) = sin(omega*x)
-c                     if integr.ne.1.and.integr.ne.2, the routine will
-c                     end with ier = 6.
-c
-c            epsabs - double precision
-c                     absolute accuracy requested, epsabs.gt.0
-c                     if epsabs.le.0, the routine will end with ier = 6.
-c
-c            limlst - integer
-c                     limlst gives an upper bound on the number of
-c                     cycles, limlst.ge.1.
-c                     if limlst.lt.3, the routine will end with ier = 6.
-c
-c            limit  - integer
-c                     gives an upper bound on the number of subintervals
-c                     allowed in the partition of each cycle, limit.ge.1
-c                     each cycle, limit.ge.1.
-c
-c            maxp1  - integer
-c                     gives an upper bound on the number of
-c                     chebyshev moments which can be stored, i.e.
-c                     for the intervals of lengths abs(b-a)*2**(-l),
-c                     l=0,1, ..., maxp1-2, maxp1.ge.1
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral x
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - ier = 0 normal and reliable termination of
-c                             the routine. it is assumed that the
-c                             requested accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine. the
-c                             estimates for integral and error are less
-c                             reliable. it is assumed that the requested
-c                             accuracy has not been achieved.
-c            error messages
-c                    if omega.ne.0
-c                     ier = 1 maximum number of  cycles  allowed
-c                             has been achieved., i.e. of subintervals
-c                             (a+(k-1)c,a+kc) where
-c                             c = (2*int(abs(omega))+1)*pi/abs(omega),
-c                             for k = 1, 2, ..., lst.
-c                             one can allow more cycles by increasing
-c                             the value of limlst (and taking the
-c                             according dimension adjustments into
-c                             account).
-c                             examine the array iwork which contains
-c                             the error flags on the cycles, in order to
-c                             look for eventual local integration
-c                             difficulties. if the position of a local
-c                             difficulty can be determined (e.g.
-c                             singularity, discontinuity within the
-c                             interval) one will probably gain from
-c                             splitting up the interval at this point
-c                             and calling appropriate integrators on
-c                             the subranges.
-c                         = 4 the extrapolation table constructed for
-c                             convergence acceleration of the series
-c                             formed by the integral contributions over
-c                             the cycles, does not converge to within
-c                             the requested accuracy. as in the case of
-c                             ier = 1, it is advised to examine the
-c                             array iwork which contains the error
-c                             flags on the cycles.
-c                         = 6 the input is invalid because
-c                             (integr.ne.1 and integr.ne.2) or
-c                              epsabs.le.0 or limlst.lt.3.
-c                              result, abserr, neval, lst are set
-c                              to zero.
-c                         = 7 bad integrand behaviour occurs within one
-c                             or more of the cycles. location and type
-c                             of the difficulty involved can be
-c                             determined from the vector ierlst. here
-c                             lst is the number of cycles actually
-c                             needed (see below).
-c                             ierlst(k) = 1 the maximum number of
-c                                           subdivisions (= limit) has
-c                                           been achieved on the k th
-c                                           cycle.
-c                                       = 2 occurrence of roundoff error
-c                                           is detected and prevents the
-c                                           tolerance imposed on the
-c                                           k th cycle, from being
-c                                           achieved.
-c                                       = 3 extremely bad integrand
-c                                           behaviour occurs at some
-c                                           points of the k th cycle.
-c                                       = 4 the integration procedure
-c                                           over the k th cycle does
-c                                           not converge (to within the
-c                                           required accuracy) due to
-c                                           roundoff in the
-c                                           extrapolation procedure
-c                                           invoked on this cycle. it
-c                                           is assumed that the result
-c                                           on this interval is the
-c                                           best which can be obtained.
-c                                       = 5 the integral over the k th
-c                                           cycle is probably divergent
-c                                           or slowly convergent. it
-c                                           must be noted that
-c                                           divergence can occur with
-c                                           any other value of
-c                                           ierlst(k).
-c                    if omega = 0 and integr = 1,
-c                    the integral is calculated by means of dqagie
-c                    and ier = ierlst(1) (with meaning as described
-c                    for ierlst(k), k = 1).
-c
-c            rslst  - double precision
-c                     vector of dimension at least limlst
-c                     rslst(k) contains the integral contribution
-c                     over the interval (a+(k-1)c,a+kc) where
-c                     c = (2*int(abs(omega))+1)*pi/abs(omega),
-c                     k = 1, 2, ..., lst.
-c                     note that, if omega = 0, rslst(1) contains
-c                     the value of the integral over (a,infinity).
-c
-c            erlst  - double precision
-c                     vector of dimension at least limlst
-c                     erlst(k) contains the error estimate corresponding
-c                     with rslst(k).
-c
-c            ierlst - integer
-c                     vector of dimension at least limlst
-c                     ierlst(k) contains the error flag corresponding
-c                     with rslst(k). for the meaning of the local error
-c                     flags see description of output parameter ier.
-c
-c            lst    - integer
-c                     number of subintervals needed for the integration
-c                     if omega = 0 then lst is set to 1.
-c
-c            alist, blist, rlist, elist - double precision
-c                     vector of dimension at least limit,
-c
-c            iord, nnlog - integer
-c                     vector of dimension at least limit, providing
-c                     space for the quantities needed in the subdivision
-c                     process of each cycle
-c
-c            chebmo - double precision
-c                     array of dimension at least (maxp1,25), providing
-c                     space for the chebyshev moments needed within the
-c                     cycles
-c
-c***references  (none)
-c***routines called  d1mach,dqagie,dqawoe,dqelg
-c***end prologue  dqawfe
-c
-      double precision a,abseps,abserr,alist,blist,chebmo,correc,cycle,
-     *  c1,c2,dabs,dl,dla,dmax1,drl,d1mach,elist,erlst,ep,eps,epsa,
-     *  epsabs,errsum,f,fact,omega,p,pi,p1,psum,reseps,result,res3la,
-     *  rlist,rslst,uflow
-      integer ier,ierlst,integr,iord,ktmin,l,last,lst,limit,limlst,ll,
-     *    maxp1,momcom,nev,neval,nnlog,nres,numrl2
-c
-      dimension alist(limit),blist(limit),chebmo(maxp1,25),elist(limit),
-     *  erlst(limlst),ierlst(limlst),iord(limit),nnlog(limit),psum(52),
-     *  res3la(3),rlist(limit),rslst(limlst)
-c
-      external f
-c
-c
-c            the dimension of  psum  is determined by the value of
-c            limexp in subroutine dqelg (psum must be of dimension
-c            (limexp+2) at least).
-c
-c           list of major variables
-c           -----------------------
-c
-c           c1, c2    - end points of subinterval (of length cycle)
-c           cycle     - (2*int(abs(omega))+1)*pi/abs(omega)
-c           psum      - vector of dimension at least (limexp+2)
-c                       (see routine dqelg)
-c                       psum contains the part of the epsilon table
-c                       which is still needed for further computations.
-c                       each element of psum is a partial sum of the
-c                       series which should sum to the value of the
-c                       integral.
-c           errsum    - sum of error estimates over the subintervals,
-c                       calculated cumulatively
-c           epsa      - absolute tolerance requested over current
-c                       subinterval
-c           chebmo    - array containing the modified chebyshev
-c                       moments (see also routine dqc25f)
-c
-      data p/0.9d+00/
-      data pi / 3.1415926535 8979323846 2643383279 50 d0 /
-c
-c           test on validity of parameters
-c           ------------------------------
-c
-c***first executable statement  dqawfe
-      result = 0.0d+00
-      abserr = 0.0d+00
-      neval = 0
-      lst = 0
-      ier = 0
-      if((integr.ne.1.and.integr.ne.2).or.epsabs.le.0.0d+00.or.
-     *  limlst.lt.3) ier = 6
-      if(ier.eq.6) go to 999
-      if(omega.ne.0.0d+00) go to 10
-c
-c           integration by dqagie if omega is zero
-c           --------------------------------------
-c
-      if(integr.eq.1) call dqagie(f,0.0d+00,1,epsabs,0.0d+00,limit,
-     *  result,abserr,neval,ier,alist,blist,rlist,elist,iord,last)
-      rslst(1) = result
-      erlst(1) = abserr
-      ierlst(1) = ier
-      lst = 1
-      go to 999
-c
-c           initializations
-c           ---------------
-c
-   10 l = dabs(omega)
-      dl = 2*l+1
-      cycle = dl*pi/dabs(omega)
-      ier = 0
-      ktmin = 0
-      neval = 0
-      numrl2 = 0
-      nres = 0
-      c1 = a
-      c2 = cycle+a
-      p1 = 0.1d+01-p
-      uflow = d1mach(1)
-      eps = epsabs
-      if(epsabs.gt.uflow/p1) eps = epsabs*p1
-      ep = eps
-      fact = 0.1d+01
-      correc = 0.0d+00
-      abserr = 0.0d+00
-      errsum = 0.0d+00
-c
-c           main do-loop
-c           ------------
-c
-      do 50 lst = 1,limlst
-c
-c           integrate over current subinterval.
-c
-        dla = lst
-        epsa = eps*fact
-        call dqawoe(f,c1,c2,omega,integr,epsa,0.0d+00,limit,lst,maxp1,
-     *  rslst(lst),erlst(lst),nev,ierlst(lst),last,alist,blist,rlist,
-     *  elist,iord,nnlog,momcom,chebmo)
-        neval = neval+nev
-        fact = fact*p
-        errsum = errsum+erlst(lst)
-        drl = 0.5d+02*dabs(rslst(lst))
-c
-c           test on accuracy with partial sum
-c
-        if((errsum+drl).le.epsabs.and.lst.ge.6) go to 80
-        correc = dmax1(correc,erlst(lst))
-        if(ierlst(lst).ne.0) eps = dmax1(ep,correc*p1)
-        if(ierlst(lst).ne.0) ier = 7
-        if(ier.eq.7.and.(errsum+drl).le.correc*0.1d+02.and.
-     *  lst.gt.5) go to 80
-        numrl2 = numrl2+1
-        if(lst.gt.1) go to 20
-        psum(1) = rslst(1)
-        go to 40
-   20   psum(numrl2) = psum(ll)+rslst(lst)
-        if(lst.eq.2) go to 40
-c
-c           test on maximum number of subintervals
-c
-        if(lst.eq.limlst) ier = 1
-c
-c           perform new extrapolation
-c
-        call dqelg(numrl2,psum,reseps,abseps,res3la,nres)
-c
-c           test whether extrapolated result is influenced by roundoff
-c
-        ktmin = ktmin+1
-        if(ktmin.ge.15.and.abserr.le.0.1d-02*(errsum+drl)) ier = 4
-        if(abseps.gt.abserr.and.lst.ne.3) go to 30
-        abserr = abseps
-        result = reseps
-        ktmin = 0
-c
-c           if ier is not 0, check whether direct result (partial sum)
-c           or extrapolated result yields the best integral
-c           approximation
-c
-        if((abserr+0.1d+02*correc).le.epsabs.or.
-     *  (abserr.le.epsabs.and.0.1d+02*correc.ge.epsabs)) go to 60
-   30   if(ier.ne.0.and.ier.ne.7) go to 60
-   40   ll = numrl2
-        c1 = c2
-        c2 = c2+cycle
-   50 continue
-c
-c         set final result and error estimate
-c         -----------------------------------
-c
-   60 abserr = abserr+0.1d+02*correc
-      if(ier.eq.0) go to 999
-      if(result.ne.0.0d+00.and.psum(numrl2).ne.0.0d+00) go to 70
-      if(abserr.gt.errsum) go to 80
-      if(psum(numrl2).eq.0.0d+00) go to 999
-   70 if(abserr/dabs(result).gt.(errsum+drl)/dabs(psum(numrl2)))
-     *  go to 80
-      if(ier.ge.1.and.ier.ne.7) abserr = abserr+drl
-      go to 999
-   80 result = psum(numrl2)
-      abserr = errsum+drl
-  999 return
-      end
Index: scipy/scipy/integrate/quadpack/dqawo.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqawo.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,225 +0,0 @@
-      recursive subroutine dqawo(f,a,b,omega,integr,epsabs,epsrel,
-     *   result,abserr,neval,ier,leniw,maxp1,lenw,last,iwork,work)
-c***begin prologue  dqawo
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a1
-c***keywords  automatic integrator, special-purpose,
-c             integrand with oscillatory cos or sin factor,
-c             clenshaw-curtis method, (end point) singularities,
-c             extrapolation, globally adaptive
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral i=integral of f(x)*w(x) over (a,b)
-c            where w(x) = cos(omega*x)
-c            or w(x) = sin(omega*x),
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c        computation of oscillatory integrals
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the function
-c                     f(x).  the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            omega  - double precision
-c                     parameter in the integrand weight function
-c
-c            integr - integer
-c                     indicates which of the weight functions is used
-c                     integr = 1      w(x) = cos(omega*x)
-c                     integr = 2      w(x) = sin(omega*x)
-c                     if integr.ne.1.and.integr.ne.2, the routine will
-c                     end with ier = 6.
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if epsabs.le.0 and
-c                     epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of  integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                   - ier.gt.0 abnormal termination of the routine.
-c                             the estimates for integral and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             (= leniw/2) has been achieved. one can
-c                             allow more subdivisions by increasing the
-c                             value of leniw (and taking the according
-c                             dimension adjustments into account).
-c                             however, if this yields no improvement it
-c                             is advised to analyze the integrand in
-c                             order to determine the integration
-c                             difficulties. if the position of a local
-c                             difficulty can be determined (e.g.
-c                             singularity, discontinuity within the
-c                             interval) one will probably gain from
-c                             splitting up the interval at this point
-c                             and calling the integrator on the
-c                             subranges. if possible, an appropriate
-c                             special-purpose integrator should be used
-c                             which is designed for handling the type of
-c                             difficulty involved.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                             the error may be under-estimated.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some interior points of the
-c                             integration interval.
-c                         = 4 the algorithm does not converge.
-c                             roundoff error is detected in the
-c                             extrapolation table. it is presumed that
-c                             the requested tolerance cannot be achieved
-c                             due to roundoff in the extrapolation
-c                             table, and that the returned result is
-c                             the best which can be obtained.
-c                         = 5 the integral is probably divergent, or
-c                             slowly convergent. it must be noted that
-c                             divergence can occur with any other value
-c                             of ier.
-c                         = 6 the input is invalid, because
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
-c                             or (integr.ne.1 and integr.ne.2),
-c                             or leniw.lt.2 or maxp1.lt.1 or
-c                             lenw.lt.leniw*2+maxp1*25.
-c                             result, abserr, neval, last are set to
-c                             zero. except when leniw, maxp1 or lenw are
-c                             invalid, work(limit*2+1), work(limit*3+1),
-c                             iwork(1), iwork(limit+1) are set to zero,
-c                             work(1) is set to a and work(limit+1) to
-c                             b.
-c
-c         dimensioning parameters
-c            leniw  - integer
-c                     dimensioning parameter for iwork.
-c                     leniw/2 equals the maximum number of subintervals
-c                     allowed in the partition of the given integration
-c                     interval (a,b), leniw.ge.2.
-c                     if leniw.lt.2, the routine will end with ier = 6.
-c
-c            maxp1  - integer
-c                     gives an upper bound on the number of chebyshev
-c                     moments which can be stored, i.e. for the
-c                     intervals of lengths abs(b-a)*2**(-l),
-c                     l=0,1, ..., maxp1-2, maxp1.ge.1
-c                     if maxp1.lt.1, the routine will end with ier = 6.
-c
-c            lenw   - integer
-c                     dimensioning parameter for work
-c                     lenw must be at least leniw*2+maxp1*25.
-c                     if lenw.lt.(leniw*2+maxp1*25), the routine will
-c                     end with ier = 6.
-c
-c            last   - integer
-c                     on return, last equals the number of subintervals
-c                     produced in the subdivision process, which
-c                     determines the number of significant elements
-c                     actually in the work arrays.
-c
-c         work arrays
-c            iwork  - integer
-c                     vector of dimension at least leniw
-c                     on return, the first k elements of which contain
-c                     pointers to the error estimates over the
-c                     subintervals, such that work(limit*3+iwork(1)), ..
-c                     work(limit*3+iwork(k)) form a decreasing
-c                     sequence, with limit = lenw/2 , and k = last
-c                     if last.le.(limit/2+2), and k = limit+1-last
-c                     otherwise.
-c                     furthermore, iwork(limit+1), ..., iwork(limit+
-c                     last) indicate the subdivision levels of the
-c                     subintervals, such that iwork(limit+i) = l means
-c                     that the subinterval numbered i is of length
-c                     abs(b-a)*2**(1-l).
-c
-c            work   - double precision
-c                     vector of dimension at least lenw
-c                     on return
-c                     work(1), ..., work(last) contain the left
-c                      end points of the subintervals in the
-c                      partition of (a,b),
-c                     work(limit+1), ..., work(limit+last) contain
-c                      the right end points,
-c                     work(limit*2+1), ..., work(limit*2+last) contain
-c                      the integral approximations over the
-c                      subintervals,
-c                     work(limit*3+1), ..., work(limit*3+last)
-c                      contain the error estimates.
-c                     work(limit*4+1), ..., work(limit*4+maxp1*25)
-c                      provide space for storing the chebyshev moments.
-c                     note that limit = lenw/2.
-c
-c***references  (none)
-c***routines called  dqawoe,xerror
-c***end prologue  dqawo
-c
-       double precision a,abserr,b,epsabs,epsrel,f,omega,result,work
-       integer ier,integr,iwork,last,limit,lenw,leniw,lvl,l1,l2,l3,l4,
-     *  maxp1,momcom,neval
-c
-       dimension iwork(leniw),work(lenw)
-c
-       external f
-c
-c         check validity of leniw, maxp1 and lenw.
-c
-c***first executable statement  dqawo
-      ier = 6
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(leniw.lt.2.or.maxp1.lt.1.or.lenw.lt.(leniw*2+maxp1*25))
-     *  go to 10
-c
-c         prepare call for dqawoe
-c
-      limit = leniw/2
-      l1 = limit+1
-      l2 = limit+l1
-      l3 = limit+l2
-      l4 = limit+l3
-      call dqawoe(f,a,b,omega,integr,epsabs,epsrel,limit,1,maxp1,result,
-     *   abserr,neval,ier,last,work(1),work(l1),work(l2),work(l3),
-     *   iwork(1),iwork(l1),momcom,work(l4))
-c
-c         call error handler if necessary
-c
-      lvl = 0
-10    if(ier.eq.6) lvl = 0
-      if(ier.ne.0) call xerror('abnormal return from dqawo',26,ier,lvl)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqawoe.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqawoe.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,531 +0,0 @@
-      recursive subroutine dqawoe (f,a,b,omega,integr,epsabs,epsrel,
-     *  limit,icall,maxp1,result,abserr,neval,ier,last,alist,blist,
-     *  rlist,elist,iord,nnlog,momcom,chebmo)
-c***begin prologue  dqawoe
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a1
-c***keywords  automatic integrator, special-purpose,
-c             integrand with oscillatory cos or sin factor,
-c             clenshaw-curtis method, (end point) singularities,
-c             extrapolation, globally adaptive
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral
-c            i = integral of f(x)*w(x) over (a,b)
-c            where w(x) = cos(omega*x) or w(x)=sin(omega*x),
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c        computation of oscillatory integrals
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration
-c
-c            omega  - double precision
-c                     parameter in the integrand weight function
-c
-c            integr - integer
-c                     indicates which of the weight functions is to be
-c                     used
-c                     integr = 1      w(x) = cos(omega*x)
-c                     integr = 2      w(x) = sin(omega*x)
-c                     if integr.ne.1 and integr.ne.2, the routine
-c                     will end with ier = 6.
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c            limit  - integer
-c                     gives an upper bound on the number of subdivisions
-c                     in the partition of (a,b), limit.ge.1.
-c
-c            icall  - integer
-c                     if dqawoe is to be used only once, icall must
-c                     be set to 1.  assume that during this call, the
-c                     chebyshev moments (for clenshaw-curtis integration
-c                     of degree 24) have been computed for intervals of
-c                     lengths (abs(b-a))*2**(-l), l=0,1,2,...momcom-1.
-c                     if icall.gt.1 this means that dqawoe has been
-c                     called twice or more on intervals of the same
-c                     length abs(b-a). the chebyshev moments already
-c                     computed are then re-used in subsequent calls.
-c                     if icall.lt.1, the routine will end with ier = 6.
-c
-c            maxp1  - integer
-c                     gives an upper bound on the number of chebyshev
-c                     moments which can be stored, i.e. for the
-c                     intervals of lengths abs(b-a)*2**(-l),
-c                     l=0,1, ..., maxp1-2, maxp1.ge.1.
-c                     if maxp1.lt.1, the routine will end with ier = 6.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the
-c                             requested accuracy has been achieved.
-c                   - ier.gt.0 abnormal termination of the routine.
-c                             the estimates for integral and error are
-c                             less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more
-c                             subdivisions by increasing the value of
-c                             limit (and taking according dimension
-c                             adjustments into account). however, if
-c                             this yields no improvement it is advised
-c                             to analyze the integrand, in order to
-c                             determine the integration difficulties.
-c                             if the position of a local difficulty can
-c                             be determined (e.g. singularity,
-c                             discontinuity within the interval) one
-c                             will probably gain from splitting up the
-c                             interval at this point and calling the
-c                             integrator on the subranges. if possible,
-c                             an appropriate special-purpose integrator
-c                             should be used which is designed for
-c                             handling the type of difficulty involved.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                             the error may be under-estimated.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 4 the algorithm does not converge.
-c                             roundoff error is detected in the
-c                             extrapolation table.
-c                             it is presumed that the requested
-c                             tolerance cannot be achieved due to
-c                             roundoff in the extrapolation table,
-c                             and that the returned result is the
-c                             best which can be obtained.
-c                         = 5 the integral is probably divergent, or
-c                             slowly convergent. it must be noted that
-c                             divergence can occur with any other value
-c                             of ier.gt.0.
-c                         = 6 the input is invalid, because
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
-c                             or (integr.ne.1 and integr.ne.2) or
-c                             icall.lt.1 or maxp1.lt.1.
-c                             result, abserr, neval, last, rlist(1),
-c                             elist(1), iord(1) and nnlog(1) are set
-c                             to zero. alist(1) and blist(1) are set
-c                             to a and b respectively.
-c
-c            last  -  integer
-c                     on return, last equals the number of
-c                     subintervals produces in the subdivision
-c                     process, which determines the number of
-c                     significant elements actually in the
-c                     work arrays.
-c            alist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the left
-c                     end points of the subintervals in the partition
-c                     of the given integration range (a,b)
-c
-c            blist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the right
-c                     end points of the subintervals in the partition
-c                     of the given integration range (a,b)
-c
-c            rlist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the integral
-c                     approximations on the subintervals
-c
-c            elist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the moduli of the
-c                     absolute error estimates on the subintervals
-c
-c            iord   - integer
-c                     vector of dimension at least limit, the first k
-c                     elements of which are pointers to the error
-c                     estimates over the subintervals,
-c                     such that elist(iord(1)), ...,
-c                     elist(iord(k)) form a decreasing sequence, with
-c                     k = last if last.le.(limit/2+2), and
-c                     k = limit+1-last otherwise.
-c
-c            nnlog  - integer
-c                     vector of dimension at least limit, containing the
-c                     subdivision levels of the subintervals, i.e.
-c                     iwork(i) = l means that the subinterval
-c                     numbered i is of length abs(b-a)*2**(1-l)
-c
-c         on entry and return
-c            momcom - integer
-c                     indicating that the chebyshev moments
-c                     have been computed for intervals of lengths
-c                     (abs(b-a))*2**(-l), l=0,1,2, ..., momcom-1,
-c                     momcom.lt.maxp1
-c
-c            chebmo - double precision
-c                     array of dimension (maxp1,25) containing the
-c                     chebyshev moments
-c
-c***references  (none)
-c***routines called  d1mach,dqc25f,dqelg,dqpsrt
-c***end prologue  dqawoe
-c
-      double precision a,abseps,abserr,alist,area,area1,area12,area2,a1,
-     *  a2,b,blist,b1,b2,chebmo,correc,dabs,defab1,defab2,defabs,dmax1,
-     *  domega,d1mach,dres,elist,epmach,epsabs,epsrel,erlarg,erlast,
-     *  errbnd,errmax,error1,erro12,error2,errsum,ertest,f,oflow,
-     *  omega,resabs,reseps,result,res3la,rlist,rlist2,small,uflow,width
-      integer icall,id,ier,ierro,integr,iord,iroff1,iroff2,iroff3,
-     *  jupbnd,k,ksgn,ktmin,last,limit,maxerr,maxp1,momcom,nev,neval,
-     *  nnlog,nres,nrmax,nrmom,numrl2
-      logical extrap,noext,extall
-c
-      dimension alist(limit),blist(limit),rlist(limit),elist(limit),
-     *  iord(limit),rlist2(52),res3la(3),chebmo(maxp1,25),nnlog(limit)
-c
-      external f
-c
-c            the dimension of rlist2 is determined by  the value of
-c            limexp in subroutine dqelg (rlist2 should be of
-c            dimension (limexp+2) at least).
-c
-c            list of major variables
-c            -----------------------
-c
-c           alist     - list of left end points of all subintervals
-c                       considered up to now
-c           blist     - list of right end points of all subintervals
-c                       considered up to now
-c           rlist(i)  - approximation to the integral over
-c                       (alist(i),blist(i))
-c           rlist2    - array of dimension at least limexp+2
-c                       containing the part of the epsilon table
-c                       which is still needed for further computations
-c           elist(i)  - error estimate applying to rlist(i)
-c           maxerr    - pointer to the interval with largest
-c                       error estimate
-c           errmax    - elist(maxerr)
-c           erlast    - error on the interval currently subdivided
-c           area      - sum of the integrals over the subintervals
-c           errsum    - sum of the errors over the subintervals
-c           errbnd    - requested accuracy max(epsabs,epsrel*
-c                       abs(result))
-c           *****1    - variable for the left subinterval
-c           *****2    - variable for the right subinterval
-c           last      - index for subdivision
-c           nres      - number of calls to the extrapolation routine
-c           numrl2    - number of elements in rlist2. if an appropriate
-c                       approximation to the compounded integral has
-c                       been obtained it is put in rlist2(numrl2) after
-c                       numrl2 has been increased by one
-c           small     - length of the smallest interval considered
-c                       up to now, multiplied by 1.5
-c           erlarg    - sum of the errors over the intervals larger
-c                       than the smallest interval considered up to now
-c           extrap    - logical variable denoting that the routine is
-c                       attempting to perform extrapolation, i.e. before
-c                       subdividing the smallest interval we try to
-c                       decrease the value of erlarg
-c           noext     - logical variable denoting that extrapolation
-c                       is no longer allowed (true  value)
-c
-c            machine dependent constants
-c            ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c           oflow is the largest positive magnitude.
-c
-c***first executable statement  dqawoe
-      epmach = d1mach(4)
-c
-c         test on validity of parameters
-c         ------------------------------
-c
-      ier = 0
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      alist(1) = a
-      blist(1) = b
-      rlist(1) = 0.0d+00
-      elist(1) = 0.0d+00
-      iord(1) = 0
-      nnlog(1) = 0
-      if((integr.ne.1.and.integr.ne.2).or.(epsabs.le.0.0d+00.and.
-     *  epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28)).or.icall.lt.1.or.
-     *  maxp1.lt.1) ier = 6
-      if(ier.eq.6) go to 999
-c
-c           first approximation to the integral
-c           -----------------------------------
-c
-      domega = dabs(omega)
-      nrmom = 0
-      if (icall.gt.1) go to 5
-      momcom = 0
-    5 call dqc25f(f,a,b,domega,integr,nrmom,maxp1,0,result,abserr,
-     *  neval,defabs,resabs,momcom,chebmo)
-c
-c           test on accuracy.
-c
-      dres = dabs(result)
-      errbnd = dmax1(epsabs,epsrel*dres)
-      rlist(1) = result
-      elist(1) = abserr
-      iord(1) = 1
-      if(abserr.le.0.1d+03*epmach*defabs.and.abserr.gt.errbnd) ier = 2
-      if(limit.eq.1) ier = 1
-      if(ier.ne.0.or.abserr.le.errbnd) go to 200
-c
-c           initializations
-c           ---------------
-c
-      uflow = d1mach(1)
-      oflow = d1mach(2)
-      errmax = abserr
-      maxerr = 1
-      area = result
-      errsum = abserr
-      abserr = oflow
-      nrmax = 1
-      extrap = .false.
-      noext = .false.
-      ierro = 0
-      iroff1 = 0
-      iroff2 = 0
-      iroff3 = 0
-      ktmin = 0
-      small = dabs(b-a)*0.75d+00
-      nres = 0
-      numrl2 = 0
-      extall = .false.
-      if(0.5d+00*dabs(b-a)*domega.gt.0.2d+01) go to 10
-      numrl2 = 1
-      extall = .true.
-      rlist2(1) = result
-   10 if(0.25d+00*dabs(b-a)*domega.le.0.2d+01) extall = .true.
-      ksgn = -1
-      if(dres.ge.(0.1d+01-0.5d+02*epmach)*defabs) ksgn = 1
-c
-c           main do-loop
-c           ------------
-c
-      do 140 last = 2,limit
-c
-c           bisect the subinterval with the nrmax-th largest
-c           error estimate.
-c
-        nrmom = nnlog(maxerr)+1
-        a1 = alist(maxerr)
-        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
-        a2 = b1
-        b2 = blist(maxerr)
-        erlast = errmax
-        call dqc25f(f,a1,b1,domega,integr,nrmom,maxp1,0,
-     *  area1,error1,nev,resabs,defab1,momcom,chebmo)
-        neval = neval+nev
-        call dqc25f(f,a2,b2,domega,integr,nrmom,maxp1,1,
-     *  area2,error2,nev,resabs,defab2,momcom,chebmo)
-        neval = neval+nev
-c
-c           improve previous approximations to integral
-c           and error and test for accuracy.
-c
-        area12 = area1+area2
-        erro12 = error1+error2
-        errsum = errsum+erro12-errmax
-        area = area+area12-rlist(maxerr)
-        if(defab1.eq.error1.or.defab2.eq.error2) go to 25
-        if(dabs(rlist(maxerr)-area12).gt.0.1d-04*dabs(area12)
-     *  .or.erro12.lt.0.99d+00*errmax) go to 20
-        if(extrap) iroff2 = iroff2+1
-        if(.not.extrap) iroff1 = iroff1+1
-   20   if(last.gt.10.and.erro12.gt.errmax) iroff3 = iroff3+1
-   25   rlist(maxerr) = area1
-        rlist(last) = area2
-        nnlog(maxerr) = nrmom
-        nnlog(last) = nrmom
-        errbnd = dmax1(epsabs,epsrel*dabs(area))
-c
-c           test for roundoff error and eventually set error flag.
-c
-        if(iroff1+iroff2.ge.10.or.iroff3.ge.20) ier = 2
-        if(iroff2.ge.5) ierro = 3
-c
-c           set error flag in the case that the number of
-c           subintervals equals limit.
-c
-        if(last.eq.limit) ier = 1
-c
-c           set error flag in the case of bad integrand behaviour
-c           at a point of the integration range.
-c
-        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*epmach)
-     *  *(dabs(a2)+0.1d+04*uflow)) ier = 4
-c
-c           append the newly-created intervals to the list.
-c
-        if(error2.gt.error1) go to 30
-        alist(last) = a2
-        blist(maxerr) = b1
-        blist(last) = b2
-        elist(maxerr) = error1
-        elist(last) = error2
-        go to 40
-   30   alist(maxerr) = a2
-        alist(last) = a1
-        blist(last) = b1
-        rlist(maxerr) = area2
-        rlist(last) = area1
-        elist(maxerr) = error2
-        elist(last) = error1
-c
-c           call subroutine dqpsrt to maintain the descending ordering
-c           in the list of error estimates and select the subinterval
-c           with nrmax-th largest error estimate (to bisected next).
-c
-   40   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
-c ***jump out of do-loop
-      if(errsum.le.errbnd) go to 170
-      if(ier.ne.0) go to 150
-        if(last.eq.2.and.extall) go to 120
-        if(noext) go to 140
-        if(.not.extall) go to 50
-        erlarg = erlarg-erlast
-        if(dabs(b1-a1).gt.small) erlarg = erlarg+erro12
-        if(extrap) go to 70
-c
-c           test whether the interval to be bisected next is the
-c           smallest interval.
-c
-   50   width = dabs(blist(maxerr)-alist(maxerr))
-        if(width.gt.small) go to 140
-        if(extall) go to 60
-c
-c           test whether we can start with the extrapolation procedure
-c           (we do this if we integrate over the next interval with
-c           use of a gauss-kronrod rule - see subroutine dqc25f).
-c
-        small = small*0.5d+00
-        if(0.25d+00*width*domega.gt.0.2d+01) go to 140
-        extall = .true.
-        go to 130
-   60   extrap = .true.
-        nrmax = 2
-   70   if(ierro.eq.3.or.erlarg.le.ertest) go to 90
-c
-c           the smallest interval has the largest error.
-c           before bisecting decrease the sum of the errors over
-c           the larger intervals (erlarg) and perform extrapolation.
-c
-        jupbnd = last
-        if (last.gt.(limit/2+2)) jupbnd = limit+3-last
-        id = nrmax
-        do 80 k = id,jupbnd
-          maxerr = iord(nrmax)
-          errmax = elist(maxerr)
-          if(dabs(blist(maxerr)-alist(maxerr)).gt.small) go to 140
-          nrmax = nrmax+1
-   80   continue
-c
-c           perform extrapolation.
-c
-   90   numrl2 = numrl2+1
-        rlist2(numrl2) = area
-        if(numrl2.lt.3) go to 110
-        call dqelg(numrl2,rlist2,reseps,abseps,res3la,nres)
-        ktmin = ktmin+1
-        if(ktmin.gt.5.and.abserr.lt.0.1d-02*errsum) ier = 5
-        if(abseps.ge.abserr) go to 100
-        ktmin = 0
-        abserr = abseps
-        result = reseps
-        correc = erlarg
-        ertest = dmax1(epsabs,epsrel*dabs(reseps))
-c ***jump out of do-loop
-        if(abserr.le.ertest) go to 150
-c
-c           prepare bisection of the smallest interval.
-c
-  100   if(numrl2.eq.1) noext = .true.
-        if(ier.eq.5) go to 150
-  110   maxerr = iord(1)
-        errmax = elist(maxerr)
-        nrmax = 1
-        extrap = .false.
-        small = small*0.5d+00
-        erlarg = errsum
-        go to 140
-  120   small = small*0.5d+00
-        numrl2 = numrl2+1
-        rlist2(numrl2) = area
-  130   ertest = errbnd
-        erlarg = errsum
-  140 continue
-c
-c           set the final result.
-c           ---------------------
-c
-  150 if(abserr.eq.oflow.or.nres.eq.0) go to 170
-      if(ier+ierro.eq.0) go to 165
-      if(ierro.eq.3) abserr = abserr+correc
-      if(ier.eq.0) ier = 3
-      if(result.ne.0.0d+00.and.area.ne.0.0d+00) go to 160
-      if(abserr.gt.errsum) go to 170
-      if(area.eq.0.0d+00) go to 190
-      go to 165
-  160 if(abserr/dabs(result).gt.errsum/dabs(area)) go to 170
-c
-c           test on divergence.
-c
-  165 if(ksgn.eq.(-1).and.dmax1(dabs(result),dabs(area)).le.
-     * defabs*0.1d-01) go to 190
-      if(0.1d-01.gt.(result/area).or.(result/area).gt.0.1d+03
-     * .or.errsum.ge.dabs(area)) ier = 6
-      go to 190
-c
-c           compute global integral sum.
-c
-  170 result = 0.0d+00
-      do 180 k=1,last
-        result = result+rlist(k)
-  180 continue
-      abserr = errsum
-  190 if (ier.gt.2) ier=ier-1
-  200 if (integr.eq.2.and.omega.lt.0.0d+00) result=-result
-  999 return
-      end
Index: scipy/scipy/integrate/quadpack/dqaws.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqaws.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,200 +0,0 @@
-      recursive subroutine dqaws(f,a,b,alfa,beta,integr,epsabs,epsrel,
-     *   result,abserr,neval,ier,limit,lenw,last,iwork,work)
-c***begin prologue  dqaws
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a1
-c***keywords  automatic integrator, special-purpose,
-c             algebraico-logarithmic end-point singularities,
-c             clenshaw-curtis, globally adaptive
-c***author  piessens,robert,appl. math. & progr. div. -k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral i = integral of f*w over (a,b),
-c            (where w shows a singular behaviour at the end points
-c            see parameter integr).
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c        integration of functions having algebraico-logarithmic
-c        end point singularities
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration, b.gt.a
-c                     if b.le.a, the routine will end with ier = 6.
-c
-c            alfa   - double precision
-c                     parameter in the integrand function, alfa.gt.(-1)
-c                     if alfa.le.(-1), the routine will end with
-c                     ier = 6.
-c
-c            beta   - double precision
-c                     parameter in the integrand function, beta.gt.(-1)
-c                     if beta.le.(-1), the routine will end with
-c                     ier = 6.
-c
-c            integr - integer
-c                     indicates which weight function is to be used
-c                     = 1  (x-a)**alfa*(b-x)**beta
-c                     = 2  (x-a)**alfa*(b-x)**beta*log(x-a)
-c                     = 3  (x-a)**alfa*(b-x)**beta*log(b-x)
-c                     = 4  (x-a)**alfa*(b-x)**beta*log(x-a)*log(b-x)
-c                     if integr.lt.1 or integr.gt.4, the routine
-c                     will end with ier = 6.
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine
-c                             the estimates for the integral and error
-c                             are less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                     ier = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more
-c                             subdivisions by increasing the value of
-c                             limit (and taking the according dimension
-c                             adjustments into account). however, if
-c                             this yields no improvement it is advised
-c                             to analyze the integrand, in order to
-c                             determine the integration difficulties
-c                             which prevent the requested tolerance from
-c                             being achieved. in case of a jump
-c                             discontinuity or a local singularity
-c                             of algebraico-logarithmic type at one or
-c                             more interior points of the integration
-c                             range, one should proceed by splitting up
-c                             the interval at these points and calling
-c                             the integrator on the subranges.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 6 the input is invalid, because
-c                             b.le.a or alfa.le.(-1) or beta.le.(-1) or
-c                             or integr.lt.1 or integr.gt.4 or
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
-c                             or limit.lt.2 or lenw.lt.limit*4.
-c                             result, abserr, neval, last are set to
-c                             zero. except when lenw or limit is invalid
-c                             iwork(1), work(limit*2+1) and
-c                             work(limit*3+1) are set to zero, work(1)
-c                             is set to a and work(limit+1) to b.
-c
-c         dimensioning parameters
-c            limit  - integer
-c                     dimensioning parameter for iwork
-c                     limit determines the maximum number of
-c                     subintervals in the partition of the given
-c                     integration interval (a,b), limit.ge.2.
-c                     if limit.lt.2, the routine will end with ier = 6.
-c
-c            lenw   - integer
-c                     dimensioning parameter for work
-c                     lenw must be at least limit*4.
-c                     if lenw.lt.limit*4, the routine will end
-c                     with ier = 6.
-c
-c            last   - integer
-c                     on return, last equals the number of
-c                     subintervals produced in the subdivision process,
-c                     which determines the significant number of
-c                     elements actually in the work arrays.
-c
-c         work arrays
-c            iwork  - integer
-c                     vector of dimension limit, the first k
-c                     elements of which contain pointers
-c                     to the error estimates over the subintervals,
-c                     such that work(limit*3+iwork(1)), ...,
-c                     work(limit*3+iwork(k)) form a decreasing
-c                     sequence with k = last if last.le.(limit/2+2),
-c                     and k = limit+1-last otherwise
-c
-c            work   - double precision
-c                     vector of dimension lenw
-c                     on return
-c                     work(1), ..., work(last) contain the left
-c                      end points of the subintervals in the
-c                      partition of (a,b),
-c                     work(limit+1), ..., work(limit+last) contain
-c                      the right end points,
-c                     work(limit*2+1), ..., work(limit*2+last)
-c                      contain the integral approximations over
-c                      the subintervals,
-c                     work(limit*3+1), ..., work(limit*3+last)
-c                      contain the error estimates.
-c
-c***references  (none)
-c***routines called  dqawse,xerror
-c***end prologue  dqaws
-c
-      double precision a,abserr,alfa,b,beta,epsabs,epsrel,f,result,work
-      integer ier,integr,iwork,last,lenw,limit,lvl,l1,l2,l3,neval
-c
-      dimension iwork(limit),work(lenw)
-c
-      external f
-c
-c         check validity of limit and lenw.
-c
-c***first executable statement  dqaws
-      ier = 6
-      neval = 0
-      last = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(limit.lt.2.or.lenw.lt.limit*4) go to 10
-c
-c         prepare call for dqawse.
-c
-      l1 = limit+1
-      l2 = limit+l1
-      l3 = limit+l2
-c
-      call dqawse(f,a,b,alfa,beta,integr,epsabs,epsrel,limit,result,
-     *  abserr,neval,ier,work(1),work(l1),work(l2),work(l3),iwork,last)
-c
-c         call error handler if necessary.
-c
-      lvl = 0
-10    if(ier.eq.6) lvl = 1
-      if(ier.ne.0) call xerror('abnormal return from dqaws',26,ier,lvl)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqawse.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqawse.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,370 +0,0 @@
-      recursive subroutine dqawse(f,a,b,alfa,beta,integr,epsabs,epsrel,
-     *   limit,result,abserr,neval,ier,alist,blist,rlist,elist,iord,
-     *   last)
-c***begin prologue  dqawse
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a1
-c***keywords  automatic integrator, special-purpose,
-c             algebraico-logarithmic end point singularities,
-c             clenshaw-curtis method
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the routine calculates an approximation result to a given
-c            definite integral i = integral of f*w over (a,b),
-c            (where w shows a singular behaviour at the end points,
-c            see parameter integr).
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c        integration of functions having algebraico-logarithmic
-c        end point singularities
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c            f      - double precision
-c                     function subprogram defining the integrand
-c                     function f(x). the actual name for f needs to be
-c                     declared e x t e r n a l in the driver program.
-c
-c            a      - double precision
-c                     lower limit of integration
-c
-c            b      - double precision
-c                     upper limit of integration, b.gt.a
-c                     if b.le.a, the routine will end with ier = 6.
-c
-c            alfa   - double precision
-c                     parameter in the weight function, alfa.gt.(-1)
-c                     if alfa.le.(-1), the routine will end with
-c                     ier = 6.
-c
-c            beta   - double precision
-c                     parameter in the weight function, beta.gt.(-1)
-c                     if beta.le.(-1), the routine will end with
-c                     ier = 6.
-c
-c            integr - integer
-c                     indicates which weight function is to be used
-c                     = 1  (x-a)**alfa*(b-x)**beta
-c                     = 2  (x-a)**alfa*(b-x)**beta*log(x-a)
-c                     = 3  (x-a)**alfa*(b-x)**beta*log(b-x)
-c                     = 4  (x-a)**alfa*(b-x)**beta*log(x-a)*log(b-x)
-c                     if integr.lt.1 or integr.gt.4, the routine
-c                     will end with ier = 6.
-c
-c            epsabs - double precision
-c                     absolute accuracy requested
-c            epsrel - double precision
-c                     relative accuracy requested
-c                     if  epsabs.le.0
-c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                     the routine will end with ier = 6.
-c
-c            limit  - integer
-c                     gives an upper bound on the number of subintervals
-c                     in the partition of (a,b), limit.ge.2
-c                     if limit.lt.2, the routine will end with ier = 6.
-c
-c         on return
-c            result - double precision
-c                     approximation to the integral
-c
-c            abserr - double precision
-c                     estimate of the modulus of the absolute error,
-c                     which should equal or exceed abs(i-result)
-c
-c            neval  - integer
-c                     number of integrand evaluations
-c
-c            ier    - integer
-c                     ier = 0 normal and reliable termination of the
-c                             routine. it is assumed that the requested
-c                             accuracy has been achieved.
-c                     ier.gt.0 abnormal termination of the routine
-c                             the estimates for the integral and error
-c                             are less reliable. it is assumed that the
-c                             requested accuracy has not been achieved.
-c            error messages
-c                         = 1 maximum number of subdivisions allowed
-c                             has been achieved. one can allow more
-c                             subdivisions by increasing the value of
-c                             limit. however, if this yields no
-c                             improvement, it is advised to analyze the
-c                             integrand in order to determine the
-c                             integration difficulties which prevent the
-c                             requested tolerance from being achieved.
-c                             in case of a jump discontinuity or a local
-c                             singularity of algebraico-logarithmic type
-c                             at one or more interior points of the
-c                             integration range, one should proceed by
-c                             splitting up the interval at these
-c                             points and calling the integrator on the
-c                             subranges.
-c                         = 2 the occurrence of roundoff error is
-c                             detected, which prevents the requested
-c                             tolerance from being achieved.
-c                         = 3 extremely bad integrand behaviour occurs
-c                             at some points of the integration
-c                             interval.
-c                         = 6 the input is invalid, because
-c                             b.le.a or alfa.le.(-1) or beta.le.(-1), or
-c                             integr.lt.1 or integr.gt.4, or
-c                             (epsabs.le.0 and
-c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                             or limit.lt.2.
-c                             result, abserr, neval, rlist(1), elist(1),
-c                             iord(1) and last are set to zero. alist(1)
-c                             and blist(1) are set to a and b
-c                             respectively.
-c
-c            alist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the left
-c                     end points of the subintervals in the partition
-c                     of the given integration range (a,b)
-c
-c            blist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the right
-c                     end points of the subintervals in the partition
-c                     of the given integration range (a,b)
-c
-c            rlist  - double precision
-c                     vector of dimension at least limit,the first
-c                      last  elements of which are the integral
-c                     approximations on the subintervals
-c
-c            elist  - double precision
-c                     vector of dimension at least limit, the first
-c                      last  elements of which are the moduli of the
-c                     absolute error estimates on the subintervals
-c
-c            iord   - integer
-c                     vector of dimension at least limit, the first k
-c                     of which are pointers to the error
-c                     estimates over the subintervals, so that
-c                     elist(iord(1)), ..., elist(iord(k)) with k = last
-c                     if last.le.(limit/2+2), and k = limit+1-last
-c                     otherwise form a decreasing sequence
-c
-c            last   - integer
-c                     number of subintervals actually produced in
-c                     the subdivision process
-c
-c***references  (none)
-c***routines called  d1mach,dqc25s,dqmomo,dqpsrt
-c***end prologue  dqawse
-c
-      double precision a,abserr,alfa,alist,area,area1,area12,area2,a1,
-     *  a2,b,beta,blist,b1,b2,centre,dabs,dmax1,d1mach,elist,epmach,
-     *  epsabs,epsrel,errbnd,errmax,error1,erro12,error2,errsum,f,
-     *  resas1,resas2,result,rg,rh,ri,rj,rlist,uflow
-      integer ier,integr,iord,iroff1,iroff2,k,last,limit,maxerr,nev,
-     *  neval,nrmax
-c
-      external f
-c
-      dimension alist(limit),blist(limit),rlist(limit),elist(limit),
-     *  iord(limit),ri(25),rj(25),rh(25),rg(25)
-c
-c            list of major variables
-c            -----------------------
-c
-c           alist     - list of left end points of all subintervals
-c                       considered up to now
-c           blist     - list of right end points of all subintervals
-c                       considered up to now
-c           rlist(i)  - approximation to the integral over
-c                       (alist(i),blist(i))
-c           elist(i)  - error estimate applying to rlist(i)
-c           maxerr    - pointer to the interval with largest
-c                       error estimate
-c           errmax    - elist(maxerr)
-c           area      - sum of the integrals over the subintervals
-c           errsum    - sum of the errors over the subintervals
-c           errbnd    - requested accuracy max(epsabs,epsrel*
-c                       abs(result))
-c           *****1    - variable for the left subinterval
-c           *****2    - variable for the right subinterval
-c           last      - index for subdivision
-c
-c
-c            machine dependent constants
-c            ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-c***first executable statement  dqawse
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-c           test on validity of parameters
-c           ------------------------------
-c
-      ier = 6
-      neval = 0
-      last = 0
-      rlist(1) = 0.0d+00
-      elist(1) = 0.0d+00
-      iord(1) = 0
-      result = 0.0d+00
-      abserr = 0.0d+00
-      if(b.le.a.or.(epsabs.eq.0.0d+00.and.
-     *  epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28)).or.alfa.le.(-0.1d+01).
-     *  or.beta.le.(-0.1d+01).or.integr.lt.1.or.integr.gt.4.or.
-     *  limit.lt.2) go to 999
-      ier = 0
-c
-c           compute the modified chebyshev moments.
-c
-      call dqmomo(alfa,beta,ri,rj,rg,rh,integr)
-c
-c           integrate over the intervals (a,(a+b)/2) and ((a+b)/2,b).
-c
-      centre = 0.5d+00*(b+a)
-      call dqc25s(f,a,b,a,centre,alfa,beta,ri,rj,rg,rh,area1,
-     *  error1,resas1,integr,nev)
-      neval = nev
-      call dqc25s(f,a,b,centre,b,alfa,beta,ri,rj,rg,rh,area2,
-     *  error2,resas2,integr,nev)
-      last = 2
-      neval = neval+nev
-      result = area1+area2
-      abserr = error1+error2
-c
-c           test on accuracy.
-c
-      errbnd = dmax1(epsabs,epsrel*dabs(result))
-c
-c           initialization
-c           --------------
-c
-      if(error2.gt.error1) go to 10
-      alist(1) = a
-      alist(2) = centre
-      blist(1) = centre
-      blist(2) = b
-      rlist(1) = area1
-      rlist(2) = area2
-      elist(1) = error1
-      elist(2) = error2
-      go to 20
-   10 alist(1) = centre
-      alist(2) = a
-      blist(1) = b
-      blist(2) = centre
-      rlist(1) = area2
-      rlist(2) = area1
-      elist(1) = error2
-      elist(2) = error1
-   20 iord(1) = 1
-      iord(2) = 2
-      if(limit.eq.2) ier = 1
-      if(abserr.le.errbnd.or.ier.eq.1) go to 999
-      errmax = elist(1)
-      maxerr = 1
-      nrmax = 1
-      area = result
-      errsum = abserr
-      iroff1 = 0
-      iroff2 = 0
-c
-c            main do-loop
-c            ------------
-c
-      do 60 last = 3,limit
-c
-c           bisect the subinterval with largest error estimate.
-c
-        a1 = alist(maxerr)
-        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))
-        a2 = b1
-        b2 = blist(maxerr)
-c
-        call dqc25s(f,a,b,a1,b1,alfa,beta,ri,rj,rg,rh,area1,
-     *  error1,resas1,integr,nev)
-        neval = neval+nev
-        call dqc25s(f,a,b,a2,b2,alfa,beta,ri,rj,rg,rh,area2,
-     *  error2,resas2,integr,nev)
-        neval = neval+nev
-c
-c           improve previous approximations integral and error
-c           and test for accuracy.
-c
-        area12 = area1+area2
-        erro12 = error1+error2
-        errsum = errsum+erro12-errmax
-        area = area+area12-rlist(maxerr)
-        if(a.eq.a1.or.b.eq.b2) go to 30
-        if(resas1.eq.error1.or.resas2.eq.error2) go to 30
-c
-c           test for roundoff error.
-c
-        if(dabs(rlist(maxerr)-area12).lt.0.1d-04*dabs(area12)
-     *  .and.erro12.ge.0.99d+00*errmax) iroff1 = iroff1+1
-        if(last.gt.10.and.erro12.gt.errmax) iroff2 = iroff2+1
-   30   rlist(maxerr) = area1
-        rlist(last) = area2
-c
-c           test on accuracy.
-c
-        errbnd = dmax1(epsabs,epsrel*dabs(area))
-        if(errsum.le.errbnd) go to 35
-c
-c           set error flag in the case that the number of interval
-c           bisections exceeds limit.
-c
-        if(last.eq.limit) ier = 1
-c
-c
-c           set error flag in the case of roundoff error.
-c
-        if(iroff1.ge.6.or.iroff2.ge.20) ier = 2
-c
-c           set error flag in the case of bad integrand behaviour
-c           at interior points of integration range.
-c
-        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*epmach)*
-     *  (dabs(a2)+0.1d+04*uflow)) ier = 3
-c
-c           append the newly-created intervals to the list.
-c
-   35   if(error2.gt.error1) go to 40
-        alist(last) = a2
-        blist(maxerr) = b1
-        blist(last) = b2
-        elist(maxerr) = error1
-        elist(last) = error2
-        go to 50
-   40   alist(maxerr) = a2
-        alist(last) = a1
-        blist(last) = b1
-        rlist(maxerr) = area2
-        rlist(last) = area1
-        elist(maxerr) = error2
-        elist(last) = error1
-c
-c           call subroutine dqpsrt to maintain the descending ordering
-c           in the list of error estimates and select the subinterval
-c           with largest error estimate (to be bisected next).
-c
-   50   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)
-c ***jump out of do-loop
-        if (ier.ne.0.or.errsum.le.errbnd) go to 70
-   60 continue
-c
-c           compute final result.
-c           ---------------------
-c
-   70 result = 0.0d+00
-      do 80 k=1,last
-        result = result+rlist(k)
-   80 continue
-      abserr = errsum
-  999 return
-      end
Index: scipy/scipy/integrate/quadpack/dqc25c.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqc25c.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,161 +0,0 @@
-      recursive subroutine dqc25c(f,a,b,c,result,abserr,krul,neval)
-c***begin prologue  dqc25c
-c***date written   810101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a2,j4
-c***keywords  25-point clenshaw-curtis integration
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  to compute i = integral of f*w over (a,b) with
-c            error estimate, where w(x) = 1/(x-c)
-c***description
-c
-c        integration rules for the computation of cauchy
-c        principal value integrals
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c           f      - double precision
-c                    function subprogram defining the integrand function
-c                    f(x). the actual name for f needs to be declared
-c                    e x t e r n a l  in the driver program.
-c
-c           a      - double precision
-c                    left end point of the integration interval
-c
-c           b      - double precision
-c                    right end point of the integration interval, b.gt.a
-c
-c           c      - double precision
-c                    parameter in the weight function
-c
-c           result - double precision
-c                    approximation to the integral
-c                    result is computed by using a generalized
-c                    clenshaw-curtis method if c lies within ten percent
-c                    of the integration interval. in the other case the
-c                    15-point kronrod rule obtained by optimal addition
-c                    of abscissae to the 7-point gauss rule, is applied.
-c
-c           abserr - double precision
-c                    estimate of the modulus of the absolute error,
-c                    which should equal or exceed abs(i-result)
-c
-c           krul   - integer
-c                    key which is decreased by 1 if the 15-point
-c                    gauss-kronrod scheme has been used
-c
-c           neval  - integer
-c                    number of integrand evaluations
-c
-c.......................................................................
-c***references  (none)
-c***routines called  dqcheb,dqk15w,dqwgtc
-c***end prologue  dqc25c
-c
-      double precision a,abserr,ak22,amom0,amom1,amom2,b,c,cc,centr,
-     *  cheb12,cheb24,dabs,dlog,dqwgtc,f,fval,hlgth,p2,p3,p4,resabs,
-     *  resasc,result,res12,res24,u,x
-      integer i,isym,k,kp,krul,neval
-c
-      dimension x(11),fval(25),cheb12(13),cheb24(25)
-c
-      external f,dqwgtc
-c
-c           the vector x contains the values cos(k*pi/24),
-c           k = 1, ..., 11, to be used for the chebyshev series
-c           expansion of f
-c
-      data x(1) / 0.9914448613 7381041114 4557526928 563d0 /
-      data x(2) / 0.9659258262 8906828674 9743199728 897d0 /
-      data x(3) / 0.9238795325 1128675612 8183189396 788d0 /
-      data x(4) / 0.8660254037 8443864676 3723170752 936d0 /
-      data x(5) / 0.7933533402 9123516457 9776961501 299d0 /
-      data x(6) / 0.7071067811 8654752440 0844362104 849d0 /
-      data x(7) / 0.6087614290 0872063941 6097542898 164d0 /
-      data x(8) / 0.5000000000 0000000000 0000000000 000d0 /
-      data x(9) / 0.3826834323 6508977172 8459984030 399d0 /
-      data x(10) / 0.2588190451 0252076234 8898837624 048d0 /
-      data x(11) / 0.1305261922 2005159154 8406227895 489d0 /
-c
-c           list of major variables
-c           ----------------------
-c           fval   - value of the function f at the points
-c                    cos(k*pi/24),  k = 0, ..., 24
-c           cheb12 - chebyshev series expansion coefficients,
-c                    for the function f, of degree 12
-c           cheb24 - chebyshev series expansion coefficients,
-c                    for the function f, of degree 24
-c           res12  - approximation to the integral corresponding
-c                    to the use of cheb12
-c           res24  - approximation to the integral corresponding
-c                    to the use of cheb24
-c           dqwgtc - external function subprogram defining
-c                    the weight function
-c           hlgth  - half-length of the interval
-c           centr  - mid point of the interval
-c
-c
-c           check the position of c.
-c
-c***first executable statement  dqc25c
-      cc = (0.2d+01*c-b-a)/(b-a)
-      if(dabs(cc).lt.0.11d+01) go to 10
-c
-c           apply the 15-point gauss-kronrod scheme.
-c
-      krul = krul-1
-      call dqk15w(f,dqwgtc,c,p2,p3,p4,kp,a,b,result,abserr,
-     *  resabs,resasc)
-      neval = 15
-      if (resasc.eq.abserr) krul = krul+1
-      go to 50
-c
-c           use the generalized clenshaw-curtis method.
-c
-   10 hlgth = 0.5d+00*(b-a)
-      centr = 0.5d+00*(b+a)
-      neval = 25
-      fval(1) = 0.5d+00*f(hlgth+centr)
-      fval(13) = f(centr)
-      fval(25) = 0.5d+00*f(centr-hlgth)
-      do 20 i=2,12
-        u = hlgth*x(i-1)
-        isym = 26-i
-        fval(i) = f(u+centr)
-        fval(isym) = f(centr-u)
-   20 continue
-c
-c           compute the chebyshev series expansion.
-c
-      call dqcheb(x,fval,cheb12,cheb24)
-c
-c           the modified chebyshev moments are computed by forward
-c           recursion, using amom0 and amom1 as starting values.
-c
-      amom0 = dlog(dabs((0.1d+01-cc)/(0.1d+01+cc)))
-      amom1 = 0.2d+01+cc*amom0
-      res12 = cheb12(1)*amom0+cheb12(2)*amom1
-      res24 = cheb24(1)*amom0+cheb24(2)*amom1
-      do 30 k=3,13
-        amom2 = 0.2d+01*cc*amom1-amom0
-        ak22 = (k-2)*(k-2)
-        if((k/2)*2.eq.k) amom2 = amom2-0.4d+01/(ak22-0.1d+01)
-        res12 = res12+cheb12(k)*amom2
-        res24 = res24+cheb24(k)*amom2
-        amom0 = amom1
-        amom1 = amom2
-   30 continue
-      do 40 k=14,25
-        amom2 = 0.2d+01*cc*amom1-amom0
-        ak22 = (k-2)*(k-2)
-        if((k/2)*2.eq.k) amom2 = amom2-0.4d+01/(ak22-0.1d+01)
-        res24 = res24+cheb24(k)*amom2
-        amom0 = amom1
-        amom1 = amom2
-   40 continue
-      result = res24
-      abserr = dabs(res24-res12)
-   50 return
-      end
Index: scipy/scipy/integrate/quadpack/dqc25f.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqc25f.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,355 +0,0 @@
-      recursive subroutine dqc25f(f,a,b,omega,integr,nrmom,maxp1,
-     *   ksave,result,abserr,neval,resabs,resasc,momcom,chebmo)
-c***begin prologue  dqc25f
-c***date written   810101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a2
-c***keywords  integration rules for functions with cos or sin
-c             factor, clenshaw-curtis, gauss-kronrod
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  to compute the integral i=integral of f(x) over (a,b)
-c            where w(x) = cos(omega*x) or w(x)=sin(omega*x) and to
-c            compute j = integral of abs(f) over (a,b). for small value
-c            of omega or small intervals (a,b) the 15-point gauss-kronro
-c            rule is used. otherwise a generalized clenshaw-curtis
-c            method is used.
-c***description
-c
-c        integration rules for functions with cos or sin factor
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c         on entry
-c           f      - double precision
-c                    function subprogram defining the integrand
-c                    function f(x). the actual name for f needs to
-c                    be declared e x t e r n a l in the calling program.
-c
-c           a      - double precision
-c                    lower limit of integration
-c
-c           b      - double precision
-c                    upper limit of integration
-c
-c           omega  - double precision
-c                    parameter in the weight function
-c
-c           integr - integer
-c                    indicates which weight function is to be used
-c                       integr = 1   w(x) = cos(omega*x)
-c                       integr = 2   w(x) = sin(omega*x)
-c
-c           nrmom  - integer
-c                    the length of interval (a,b) is equal to the length
-c                    of the original integration interval divided by
-c                    2**nrmom (we suppose that the routine is used in an
-c                    adaptive integration process, otherwise set
-c                    nrmom = 0). nrmom must be zero at the first call.
-c
-c           maxp1  - integer
-c                    gives an upper bound on the number of chebyshev
-c                    moments which can be stored, i.e. for the
-c                    intervals of lengths abs(bb-aa)*2**(-l),
-c                    l = 0,1,2, ..., maxp1-2.
-c
-c           ksave  - integer
-c                    key which is one when the moments for the
-c                    current interval have been computed
-c
-c         on return
-c           result - double precision
-c                    approximation to the integral i
-c
-c           abserr - double precision
-c                    estimate of the modulus of the absolute
-c                    error, which should equal or exceed abs(i-result)
-c
-c           neval  - integer
-c                    number of integrand evaluations
-c
-c           resabs - double precision
-c                    approximation to the integral j
-c
-c           resasc - double precision
-c                    approximation to the integral of abs(f-i/(b-a))
-c
-c         on entry and return
-c           momcom - integer
-c                    for each interval length we need to compute the
-c                    chebyshev moments. momcom counts the number of
-c                    intervals for which these moments have already been
-c                    computed. if nrmom.lt.momcom or ksave = 1, the
-c                    chebyshev moments for the interval (a,b) have
-c                    already been computed and stored, otherwise we
-c                    compute them and we increase momcom.
-c
-c           chebmo - double precision
-c                    array of dimension at least (maxp1,25) containing
-c                    the modified chebyshev moments for the first momcom
-c                    momcom interval lengths
-c
-c ......................................................................
-c***references  (none)
-c***routines called  d1mach,dgtsl,dqcheb,dqk15w,dqwgtf
-c***end prologue  dqc25f
-c
-      double precision a,abserr,ac,an,an2,as,asap,ass,b,centr,chebmo,
-     *  cheb12,cheb24,conc,cons,cospar,d,dabs,dcos,dsin,dqwgtf,d1,
-     *  d1mach,d2,estc,ests,f,fval,hlgth,oflow,omega,parint,par2,par22,
-     *  p2,p3,p4,resabs,resasc,resc12,resc24,ress12,ress24,result,
-     *  sinpar,v,x
-      integer i,iers,integr,isym,j,k,ksave,m,momcom,neval,maxp1,
-     *  noequ,noeq1,nrmom
-c
-      dimension chebmo(maxp1,25),cheb12(13),cheb24(25),d(25),d1(25),
-     *  d2(25),fval(25),v(28),x(11)
-c
-      external f,dqwgtf
-c
-c           the vector x contains the values cos(k*pi/24)
-c           k = 1, ...,11, to be used for the chebyshev expansion of f
-c
-      data x(1) / 0.9914448613 7381041114 4557526928 563d0 /
-      data x(2) / 0.9659258262 8906828674 9743199728 897d0 /
-      data x(3) / 0.9238795325 1128675612 8183189396 788d0 /
-      data x(4) / 0.8660254037 8443864676 3723170752 936d0 /
-      data x(5) / 0.7933533402 9123516457 9776961501 299d0 /
-      data x(6) / 0.7071067811 8654752440 0844362104 849d0 /
-      data x(7) / 0.6087614290 0872063941 6097542898 164d0 /
-      data x(8) / 0.5000000000 0000000000 0000000000 000d0 /
-      data x(9) / 0.3826834323 6508977172 8459984030 399d0 /
-      data x(10) / 0.2588190451 0252076234 8898837624 048d0 /
-      data x(11) / 0.1305261922 2005159154 8406227895 489d0 /
-c
-c           list of major variables
-c           -----------------------
-c
-c           centr  - mid point of the integration interval
-c           hlgth  - half-length of the integration interval
-c           fval   - value of the function f at the points
-c                    (b-a)*0.5*cos(k*pi/12) + (b+a)*0.5, k = 0, ..., 24
-c           cheb12 - coefficients of the chebyshev series expansion
-c                    of degree 12, for the function f, in the
-c                    interval (a,b)
-c           cheb24 - coefficients of the chebyshev series expansion
-c                    of degree 24, for the function f, in the
-c                    interval (a,b)
-c           resc12 - approximation to the integral of
-c                    cos(0.5*(b-a)*omega*x)*f(0.5*(b-a)*x+0.5*(b+a))
-c                    over (-1,+1), using the chebyshev series
-c                    expansion of degree 12
-c           resc24 - approximation to the same integral, using the
-c                    chebyshev series expansion of degree 24
-c           ress12 - the analogue of resc12 for the sine
-c           ress24 - the analogue of resc24 for the sine
-c
-c
-c           machine dependent constant
-c           --------------------------
-c
-c           oflow is the largest positive magnitude.
-c
-c***first executable statement  dqc25f
-      oflow = d1mach(2)
-c
-      centr = 0.5d+00*(b+a)
-      hlgth = 0.5d+00*(b-a)
-      parint = omega*hlgth
-c
-c           compute the integral using the 15-point gauss-kronrod
-c           formula if the value of the parameter in the integrand
-c           is small.
-c
-      if(dabs(parint).gt.0.2d+01) go to 10
-      call dqk15w(f,dqwgtf,omega,p2,p3,p4,integr,a,b,result,
-     *  abserr,resabs,resasc)
-      neval = 15
-      go to 170
-c
-c           compute the integral using the generalized clenshaw-
-c           curtis method.
-c
-   10 conc = hlgth*dcos(centr*omega)
-      cons = hlgth*dsin(centr*omega)
-      resasc = oflow
-      neval = 25
-c
-c           check whether the chebyshev moments for this interval
-c           have already been computed.
-c
-      if(nrmom.lt.momcom.or.ksave.eq.1) go to 120
-c
-c           compute a new set of chebyshev moments.
-c
-      m = momcom+1
-      par2 = parint*parint
-      par22 = par2+0.2d+01
-      sinpar = dsin(parint)
-      cospar = dcos(parint)
-c
-c           compute the chebyshev moments with respect to cosine.
-c
-      v(1) = 0.2d+01*sinpar/parint
-      v(2) = (0.8d+01*cospar+(par2+par2-0.8d+01)*sinpar/parint)/par2
-      v(3) = (0.32d+02*(par2-0.12d+02)*cospar+(0.2d+01*
-     *  ((par2-0.80d+02)*par2+0.192d+03)*sinpar)/parint)/(par2*par2)
-      ac = 0.8d+01*cospar
-      as = 0.24d+02*parint*sinpar
-      if(dabs(parint).gt.0.24d+02) go to 30
-c
-c           compute the chebyshev moments as the solutions of a
-c           boundary value problem with 1 initial value (v(3)) and 1
-c           end value (computed using an asymptotic formula).
-c
-      noequ = 25
-      noeq1 = noequ-1
-      an = 0.6d+01
-      do 20 k = 1,noeq1
-        an2 = an*an
-        d(k) = -0.2d+01*(an2-0.4d+01)*(par22-an2-an2)
-        d2(k) = (an-0.1d+01)*(an-0.2d+01)*par2
-        d1(k+1) = (an+0.3d+01)*(an+0.4d+01)*par2
-        v(k+3) = as-(an2-0.4d+01)*ac
-        an = an+0.2d+01
-   20 continue
-      an2 = an*an
-      d(noequ) = -0.2d+01*(an2-0.4d+01)*(par22-an2-an2)
-      v(noequ+3) = as-(an2-0.4d+01)*ac
-      v(4) = v(4)-0.56d+02*par2*v(3)
-      ass = parint*sinpar
-      asap = (((((0.210d+03*par2-0.1d+01)*cospar-(0.105d+03*par2
-     *  -0.63d+02)*ass)/an2-(0.1d+01-0.15d+02*par2)*cospar
-     *  +0.15d+02*ass)/an2-cospar+0.3d+01*ass)/an2-cospar)/an2
-      v(noequ+3) = v(noequ+3)-0.2d+01*asap*par2*(an-0.1d+01)*
-     *   (an-0.2d+01)
-c
-c           solve the tridiagonal system by means of gaussian
-c           elimination with partial pivoting.
-c
-c***        call to dgtsl has been replaced by call to
-c***        lapack routine dgtsv
-c
-c      call dgtsl(noequ,d1,d,d2,v(4),iers)
-      call dgtsv(noequ,1,d1(2),d,d2,v(4),noequ,iers)
-      go to 50
-c
-c           compute the chebyshev moments by means of forward
-c           recursion.
-c
-   30 an = 0.4d+01
-      do 40 i = 4,13
-        an2 = an*an
-        v(i) = ((an2-0.4d+01)*(0.2d+01*(par22-an2-an2)*v(i-1)-ac)
-     *  +as-par2*(an+0.1d+01)*(an+0.2d+01)*v(i-2))/
-     *  (par2*(an-0.1d+01)*(an-0.2d+01))
-        an = an+0.2d+01
-   40 continue
-   50 do 60 j = 1,13
-        chebmo(m,2*j-1) = v(j)
-   60 continue
-c
-c           compute the chebyshev moments with respect to sine.
-c
-      v(1) = 0.2d+01*(sinpar-parint*cospar)/par2
-      v(2) = (0.18d+02-0.48d+02/par2)*sinpar/par2
-     *  +(-0.2d+01+0.48d+02/par2)*cospar/parint
-      ac = -0.24d+02*parint*cospar
-      as = -0.8d+01*sinpar
-      if(dabs(parint).gt.0.24d+02) go to 80
-c
-c           compute the chebyshev moments as the solutions of a boundary
-c           value problem with 1 initial value (v(2)) and 1 end value
-c           (computed using an asymptotic formula).
-c
-      an = 0.5d+01
-      do 70 k = 1,noeq1
-        an2 = an*an
-        d(k) = -0.2d+01*(an2-0.4d+01)*(par22-an2-an2)
-        d2(k) = (an-0.1d+01)*(an-0.2d+01)*par2
-        d1(k+1) = (an+0.3d+01)*(an+0.4d+01)*par2
-        v(k+2) = ac+(an2-0.4d+01)*as
-        an = an+0.2d+01
-   70 continue
-      an2 = an*an
-      d(noequ) = -0.2d+01*(an2-0.4d+01)*(par22-an2-an2)
-      v(noequ+2) = ac+(an2-0.4d+01)*as
-      v(3) = v(3)-0.42d+02*par2*v(2)
-      ass = parint*cospar
-      asap = (((((0.105d+03*par2-0.63d+02)*ass+(0.210d+03*par2
-     *  -0.1d+01)*sinpar)/an2+(0.15d+02*par2-0.1d+01)*sinpar-
-     *  0.15d+02*ass)/an2-0.3d+01*ass-sinpar)/an2-sinpar)/an2
-      v(noequ+2) = v(noequ+2)-0.2d+01*asap*par2*(an-0.1d+01)
-     *  *(an-0.2d+01)
-c
-c           solve the tridiagonal system by means of gaussian
-c           elimination with partial pivoting.
-c
-c***        call to dgtsl has been replaced by call to
-c***        lapack routine dgtsv
-c
-c      call dgtsl(noequ,d1,d,d2,v(3),iers)
-      call dgtsv(noequ,1,d1(2),d,d2,v(3),noequ,iers)
-      go to 100
-c
-c           compute the chebyshev moments by means of forward recursion.
-c
-   80 an = 0.3d+01
-      do 90 i = 3,12
-        an2 = an*an
-        v(i) = ((an2-0.4d+01)*(0.2d+01*(par22-an2-an2)*v(i-1)+as)
-     *  +ac-par2*(an+0.1d+01)*(an+0.2d+01)*v(i-2))
-     *  /(par2*(an-0.1d+01)*(an-0.2d+01))
-        an = an+0.2d+01
-   90 continue
-  100 do 110 j = 1,12
-        chebmo(m,2*j) = v(j)
-  110 continue
-  120 if (nrmom.lt.momcom) m = nrmom+1
-       if (momcom.lt.(maxp1-1).and.nrmom.ge.momcom) momcom = momcom+1
-c
-c           compute the coefficients of the chebyshev expansions
-c           of degrees 12 and 24 of the function f.
-c
-      fval(1) = 0.5d+00*f(centr+hlgth)
-      fval(13) = f(centr)
-      fval(25) = 0.5d+00*f(centr-hlgth)
-      do 130 i = 2,12
-        isym = 26-i
-        fval(i) = f(hlgth*x(i-1)+centr)
-        fval(isym) = f(centr-hlgth*x(i-1))
-  130 continue
-      call dqcheb(x,fval,cheb12,cheb24)
-c
-c           compute the integral and error estimates.
-c
-      resc12 = cheb12(13)*chebmo(m,13)
-      ress12 = 0.0d+00
-      k = 11
-      do 140 j = 1,6
-        resc12 = resc12+cheb12(k)*chebmo(m,k)
-        ress12 = ress12+cheb12(k+1)*chebmo(m,k+1)
-        k = k-2
-  140 continue
-      resc24 = cheb24(25)*chebmo(m,25)
-      ress24 = 0.0d+00
-      resabs = dabs(cheb24(25))
-      k = 23
-      do 150 j = 1,12
-        resc24 = resc24+cheb24(k)*chebmo(m,k)
-        ress24 = ress24+cheb24(k+1)*chebmo(m,k+1)
-        resabs = resabs+dabs(cheb24(k))+dabs(cheb24(k+1))
-        k = k-2
-  150 continue
-      estc = dabs(resc24-resc12)
-      ests = dabs(ress24-ress12)
-      resabs = resabs*dabs(hlgth)
-      if(integr.eq.2) go to 160
-      result = conc*resc24-cons*ress24
-      abserr = dabs(conc*estc)+dabs(cons*ests)
-      go to 170
-  160 result = conc*ress24+cons*resc24
-      abserr = dabs(conc*ests)+dabs(cons*estc)
-  170 return
-      end
Index: scipy/scipy/integrate/quadpack/dqc25s.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqc25s.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,337 +0,0 @@
-      recursive subroutine dqc25s(f,a,b,bl,br,alfa,beta,ri,rj,rg,rh,
-     *   result,abserr,resasc,integr,nev)
-c***begin prologue  dqc25s
-c***date written   810101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a2
-c***keywords  25-point clenshaw-curtis integration
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  to compute i = integral of f*w over (bl,br), with error
-c            estimate, where the weight function w has a singular
-c            behaviour of algebraico-logarithmic type at the points
-c            a and/or b. (bl,br) is a part of (a,b).
-c***description
-c
-c        integration rules for integrands having algebraico-logarithmic
-c        end point singularities
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c           f      - double precision
-c                    function subprogram defining the integrand
-c                    f(x). the actual name for f needs to be declared
-c                    e x t e r n a l  in the driver program.
-c
-c           a      - double precision
-c                    left end point of the original interval
-c
-c           b      - double precision
-c                    right end point of the original interval, b.gt.a
-c
-c           bl     - double precision
-c                    lower limit of integration, bl.ge.a
-c
-c           br     - double precision
-c                    upper limit of integration, br.le.b
-c
-c           alfa   - double precision
-c                    parameter in the weight function
-c
-c           beta   - double precision
-c                    parameter in the weight function
-c
-c           ri,rj,rg,rh - double precision
-c                    modified chebyshev moments for the application
-c                    of the generalized clenshaw-curtis
-c                    method (computed in subroutine dqmomo)
-c
-c           result - double precision
-c                    approximation to the integral
-c                    result is computed by using a generalized
-c                    clenshaw-curtis method if b1 = a or br = b.
-c                    in all other cases the 15-point kronrod
-c                    rule is applied, obtained by optimal addition of
-c                    abscissae to the 7-point gauss rule.
-c
-c           abserr - double precision
-c                    estimate of the modulus of the absolute error,
-c                    which should equal or exceed abs(i-result)
-c
-c           resasc - double precision
-c                    approximation to the integral of abs(f*w-i/(b-a))
-c
-c           integr - integer
-c                    which determines the weight function
-c                    = 1   w(x) = (x-a)**alfa*(b-x)**beta
-c                    = 2   w(x) = (x-a)**alfa*(b-x)**beta*log(x-a)
-c                    = 3   w(x) = (x-a)**alfa*(b-x)**beta*log(b-x)
-c                    = 4   w(x) = (x-a)**alfa*(b-x)**beta*log(x-a)*
-c                                 log(b-x)
-c
-c           nev    - integer
-c                    number of integrand evaluations
-c***references  (none)
-c***routines called  dqcheb,dqk15w
-c***end prologue  dqc25s
-c
-      double precision a,abserr,alfa,b,beta,bl,br,centr,cheb12,cheb24,
-     *  dabs,dc,dlog,f,factor,fix,fval,hlgth,resabs,resasc,result,res12,
-     *  res24,rg,rh,ri,rj,u,dqwgts,x
-      integer i,integr,isym,nev
-c
-      dimension cheb12(13),cheb24(25),fval(25),rg(25),rh(25),ri(25),
-     *  rj(25),x(11)
-c
-      external f,dqwgts
-c
-c           the vector x contains the values cos(k*pi/24)
-c           k = 1, ..., 11, to be used for the computation of the
-c           chebyshev series expansion of f.
-c
-      data x(1) / 0.9914448613 7381041114 4557526928 563d0 /
-      data x(2) / 0.9659258262 8906828674 9743199728 897d0 /
-      data x(3) / 0.9238795325 1128675612 8183189396 788d0 /
-      data x(4) / 0.8660254037 8443864676 3723170752 936d0 /
-      data x(5) / 0.7933533402 9123516457 9776961501 299d0 /
-      data x(6) / 0.7071067811 8654752440 0844362104 849d0 /
-      data x(7) / 0.6087614290 0872063941 6097542898 164d0 /
-      data x(8) / 0.5000000000 0000000000 0000000000 000d0 /
-      data x(9) / 0.3826834323 6508977172 8459984030 399d0 /
-      data x(10) / 0.2588190451 0252076234 8898837624 048d0 /
-      data x(11) / 0.1305261922 2005159154 8406227895 489d0 /
-c
-c           list of major variables
-c           -----------------------
-c
-c           fval   - value of the function f at the points
-c                    (br-bl)*0.5*cos(k*pi/24)+(br+bl)*0.5
-c                    k = 0, ..., 24
-c           cheb12 - coefficients of the chebyshev series expansion
-c                    of degree 12, for the function f, in the
-c                    interval (bl,br)
-c           cheb24 - coefficients of the chebyshev series expansion
-c                    of degree 24, for the function f, in the
-c                    interval (bl,br)
-c           res12  - approximation to the integral obtained from cheb12
-c           res24  - approximation to the integral obtained from cheb24
-c           dqwgts - external function subprogram defining
-c                    the four possible weight functions
-c           hlgth  - half-length of the interval (bl,br)
-c           centr  - mid point of the interval (bl,br)
-c
-c***first executable statement  dqc25s
-      nev = 25
-      if(bl.eq.a.and.(alfa.ne.0.0d+00.or.integr.eq.2.or.integr.eq.4))
-     * go to 10
-      if(br.eq.b.and.(beta.ne.0.0d+00.or.integr.eq.3.or.integr.eq.4))
-     * go to 140
-c
-c           if a.gt.bl and b.lt.br, apply the 15-point gauss-kronrod
-c           scheme.
-c
-c
-      call dqk15w(f,dqwgts,a,b,alfa,beta,integr,bl,br,
-     *    result,abserr,resabs,resasc)
-      nev = 15
-      go to 270
-c
-c           this part of the program is executed only if a = bl.
-c           ----------------------------------------------------
-c
-c           compute the chebyshev series expansion of the
-c           following function
-c           f1 = (0.5*(b+b-br-a)-0.5*(br-a)*x)**beta
-c                  *f(0.5*(br-a)*x+0.5*(br+a))
-c
-   10 hlgth = 0.5d+00*(br-bl)
-      centr = 0.5d+00*(br+bl)
-      fix = b-centr
-      fval(1) = 0.5d+00*f(hlgth+centr)*(fix-hlgth)**beta
-      fval(13) = f(centr)*(fix**beta)
-      fval(25) = 0.5d+00*f(centr-hlgth)*(fix+hlgth)**beta
-      do 20 i=2,12
-        u = hlgth*x(i-1)
-        isym = 26-i
-        fval(i) = f(u+centr)*(fix-u)**beta
-        fval(isym) = f(centr-u)*(fix+u)**beta
-   20 continue
-      factor = hlgth**(alfa+0.1d+01)
-      result = 0.0d+00
-      abserr = 0.0d+00
-      res12 = 0.0d+00
-      res24 = 0.0d+00
-      if(integr.gt.2) go to 70
-      call dqcheb(x,fval,cheb12,cheb24)
-c
-c           integr = 1  (or 2)
-c
-      do 30 i=1,13
-        res12 = res12+cheb12(i)*ri(i)
-        res24 = res24+cheb24(i)*ri(i)
-   30 continue
-      do 40 i=14,25
-        res24 = res24+cheb24(i)*ri(i)
-   40 continue
-      if(integr.eq.1) go to 130
-c
-c           integr = 2
-c
-      dc = dlog(br-bl)
-      result = res24*dc
-      abserr = dabs((res24-res12)*dc)
-      res12 = 0.0d+00
-      res24 = 0.0d+00
-      do 50 i=1,13
-        res12 = res12+cheb12(i)*rg(i)
-        res24 = res12+cheb24(i)*rg(i)
-   50 continue
-      do 60 i=14,25
-        res24 = res24+cheb24(i)*rg(i)
-   60 continue
-      go to 130
-c
-c           compute the chebyshev series expansion of the
-c           following function
-c           f4 = f1*log(0.5*(b+b-br-a)-0.5*(br-a)*x)
-c
-   70 fval(1) = fval(1)*dlog(fix-hlgth)
-      fval(13) = fval(13)*dlog(fix)
-      fval(25) = fval(25)*dlog(fix+hlgth)
-      do 80 i=2,12
-        u = hlgth*x(i-1)
-        isym = 26-i
-        fval(i) = fval(i)*dlog(fix-u)
-        fval(isym) = fval(isym)*dlog(fix+u)
-   80 continue
-      call dqcheb(x,fval,cheb12,cheb24)
-c
-c           integr = 3  (or 4)
-c
-      do 90 i=1,13
-        res12 = res12+cheb12(i)*ri(i)
-        res24 = res24+cheb24(i)*ri(i)
-   90 continue
-      do 100 i=14,25
-        res24 = res24+cheb24(i)*ri(i)
-  100 continue
-      if(integr.eq.3) go to 130
-c
-c           integr = 4
-c
-      dc = dlog(br-bl)
-      result = res24*dc
-      abserr = dabs((res24-res12)*dc)
-      res12 = 0.0d+00
-      res24 = 0.0d+00
-      do 110 i=1,13
-        res12 = res12+cheb12(i)*rg(i)
-        res24 = res24+cheb24(i)*rg(i)
-  110 continue
-      do 120 i=14,25
-        res24 = res24+cheb24(i)*rg(i)
-  120 continue
-  130 result = (result+res24)*factor
-      abserr = (abserr+dabs(res24-res12))*factor
-      go to 270
-c
-c           this part of the program is executed only if b = br.
-c           ----------------------------------------------------
-c
-c           compute the chebyshev series expansion of the
-c           following function
-c           f2 = (0.5*(b+bl-a-a)+0.5*(b-bl)*x)**alfa
-c                *f(0.5*(b-bl)*x+0.5*(b+bl))
-c
-  140 hlgth = 0.5d+00*(br-bl)
-      centr = 0.5d+00*(br+bl)
-      fix = centr-a
-      fval(1) = 0.5d+00*f(hlgth+centr)*(fix+hlgth)**alfa
-      fval(13) = f(centr)*(fix**alfa)
-      fval(25) = 0.5d+00*f(centr-hlgth)*(fix-hlgth)**alfa
-      do 150 i=2,12
-        u = hlgth*x(i-1)
-        isym = 26-i
-        fval(i) = f(u+centr)*(fix+u)**alfa
-        fval(isym) = f(centr-u)*(fix-u)**alfa
-  150 continue
-      factor = hlgth**(beta+0.1d+01)
-      result = 0.0d+00
-      abserr = 0.0d+00
-      res12 = 0.0d+00
-      res24 = 0.0d+00
-      if(integr.eq.2.or.integr.eq.4) go to 200
-c
-c           integr = 1  (or 3)
-c
-      call dqcheb(x,fval,cheb12,cheb24)
-      do 160 i=1,13
-        res12 = res12+cheb12(i)*rj(i)
-        res24 = res24+cheb24(i)*rj(i)
-  160 continue
-      do 170 i=14,25
-        res24 = res24+cheb24(i)*rj(i)
-  170 continue
-      if(integr.eq.1) go to 260
-c
-c           integr = 3
-c
-      dc = dlog(br-bl)
-      result = res24*dc
-      abserr = dabs((res24-res12)*dc)
-      res12 = 0.0d+00
-      res24 = 0.0d+00
-      do 180 i=1,13
-        res12 = res12+cheb12(i)*rh(i)
-        res24 = res24+cheb24(i)*rh(i)
-  180 continue
-      do 190 i=14,25
-        res24 = res24+cheb24(i)*rh(i)
-  190 continue
-      go to 260
-c
-c           compute the chebyshev series expansion of the
-c           following function
-c           f3 = f2*log(0.5*(b-bl)*x+0.5*(b+bl-a-a))
-c
-  200 fval(1) = fval(1)*dlog(hlgth+fix)
-      fval(13) = fval(13)*dlog(fix)
-      fval(25) = fval(25)*dlog(fix-hlgth)
-      do 210 i=2,12
-        u = hlgth*x(i-1)
-        isym = 26-i
-        fval(i) = fval(i)*dlog(u+fix)
-        fval(isym) = fval(isym)*dlog(fix-u)
-  210 continue
-      call dqcheb(x,fval,cheb12,cheb24)
-c
-c           integr = 2  (or 4)
-c
-      do 220 i=1,13
-        res12 = res12+cheb12(i)*rj(i)
-        res24 = res24+cheb24(i)*rj(i)
-  220 continue
-      do 230 i=14,25
-        res24 = res24+cheb24(i)*rj(i)
-  230 continue
-      if(integr.eq.2) go to 260
-      dc = dlog(br-bl)
-      result = res24*dc
-      abserr = dabs((res24-res12)*dc)
-      res12 = 0.0d+00
-      res24 = 0.0d+00
-c
-c           integr = 4
-c
-      do 240 i=1,13
-        res12 = res12+cheb12(i)*rh(i)
-        res24 = res24+cheb24(i)*rh(i)
-  240 continue
-      do 250 i=14,25
-        res24 = res24+cheb24(i)*rh(i)
-  250 continue
-  260 result = (result+res24)*factor
-      abserr = (abserr+dabs(res24-res12))*factor
-  270 return
-      end
Index: scipy/scipy/integrate/quadpack/dqcheb.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqcheb.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,148 +0,0 @@
-      recursive subroutine dqcheb(x,fval,cheb12,cheb24)
-c***begin prologue  dqcheb
-c***refer to  dqc25c,dqc25f,dqc25s
-c***routines called  (none)
-c***revision date  830518   (yymmdd)
-c***keywords  chebyshev series expansion, fast fourier transform
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  this routine computes the chebyshev series expansion
-c            of degrees 12 and 24 of a function using a
-c            fast fourier transform method
-c            f(x) = sum(k=1,..,13) (cheb12(k)*t(k-1,x)),
-c            f(x) = sum(k=1,..,25) (cheb24(k)*t(k-1,x)),
-c            where t(k,x) is the chebyshev polynomial of degree k.
-c***description
-c
-c        chebyshev series expansion
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c          on entry
-c           x      - double precision
-c                    vector of dimension 11 containing the
-c                    values cos(k*pi/24), k = 1, ..., 11
-c
-c           fval   - double precision
-c                    vector of dimension 25 containing the
-c                    function values at the points
-c                    (b+a+(b-a)*cos(k*pi/24))/2, k = 0, ...,24,
-c                    where (a,b) is the approximation interval.
-c                    fval(1) and fval(25) are divided by two
-c                    (these values are destroyed at output).
-c
-c          on return
-c           cheb12 - double precision
-c                    vector of dimension 13 containing the
-c                    chebyshev coefficients for degree 12
-c
-c           cheb24 - double precision
-c                    vector of dimension 25 containing the
-c                    chebyshev coefficients for degree 24
-c
-c***end prologue  dqcheb
-c
-      double precision alam,alam1,alam2,cheb12,cheb24,fval,part1,part2,
-     *  part3,v,x
-      integer i,j
-c
-      dimension cheb12(13),cheb24(25),fval(25),v(12),x(11)
-c
-c***first executable statement  dqcheb
-      do 10 i=1,12
-        j = 26-i
-        v(i) = fval(i)-fval(j)
-        fval(i) = fval(i)+fval(j)
-   10 continue
-      alam1 = v(1)-v(9)
-      alam2 = x(6)*(v(3)-v(7)-v(11))
-      cheb12(4) = alam1+alam2
-      cheb12(10) = alam1-alam2
-      alam1 = v(2)-v(8)-v(10)
-      alam2 = v(4)-v(6)-v(12)
-      alam = x(3)*alam1+x(9)*alam2
-      cheb24(4) = cheb12(4)+alam
-      cheb24(22) = cheb12(4)-alam
-      alam = x(9)*alam1-x(3)*alam2
-      cheb24(10) = cheb12(10)+alam
-      cheb24(16) = cheb12(10)-alam
-      part1 = x(4)*v(5)
-      part2 = x(8)*v(9)
-      part3 = x(6)*v(7)
-      alam1 = v(1)+part1+part2
-      alam2 = x(2)*v(3)+part3+x(10)*v(11)
-      cheb12(2) = alam1+alam2
-      cheb12(12) = alam1-alam2
-      alam = x(1)*v(2)+x(3)*v(4)+x(5)*v(6)+x(7)*v(8)
-     *  +x(9)*v(10)+x(11)*v(12)
-      cheb24(2) = cheb12(2)+alam
-      cheb24(24) = cheb12(2)-alam
-      alam = x(11)*v(2)-x(9)*v(4)+x(7)*v(6)-x(5)*v(8)
-     *  +x(3)*v(10)-x(1)*v(12)
-      cheb24(12) = cheb12(12)+alam
-      cheb24(14) = cheb12(12)-alam
-      alam1 = v(1)-part1+part2
-      alam2 = x(10)*v(3)-part3+x(2)*v(11)
-      cheb12(6) = alam1+alam2
-      cheb12(8) = alam1-alam2
-      alam = x(5)*v(2)-x(9)*v(4)-x(1)*v(6)
-     *  -x(11)*v(8)+x(3)*v(10)+x(7)*v(12)
-      cheb24(6) = cheb12(6)+alam
-      cheb24(20) = cheb12(6)-alam
-      alam = x(7)*v(2)-x(3)*v(4)-x(11)*v(6)+x(1)*v(8)
-     *  -x(9)*v(10)-x(5)*v(12)
-      cheb24(8) = cheb12(8)+alam
-      cheb24(18) = cheb12(8)-alam
-      do 20 i=1,6
-        j = 14-i
-        v(i) = fval(i)-fval(j)
-        fval(i) = fval(i)+fval(j)
-   20 continue
-      alam1 = v(1)+x(8)*v(5)
-      alam2 = x(4)*v(3)
-      cheb12(3) = alam1+alam2
-      cheb12(11) = alam1-alam2
-      cheb12(7) = v(1)-v(5)
-      alam = x(2)*v(2)+x(6)*v(4)+x(10)*v(6)
-      cheb24(3) = cheb12(3)+alam
-      cheb24(23) = cheb12(3)-alam
-      alam = x(6)*(v(2)-v(4)-v(6))
-      cheb24(7) = cheb12(7)+alam
-      cheb24(19) = cheb12(7)-alam
-      alam = x(10)*v(2)-x(6)*v(4)+x(2)*v(6)
-      cheb24(11) = cheb12(11)+alam
-      cheb24(15) = cheb12(11)-alam
-      do 30 i=1,3
-        j = 8-i
-        v(i) = fval(i)-fval(j)
-        fval(i) = fval(i)+fval(j)
-   30 continue
-      cheb12(5) = v(1)+x(8)*v(3)
-      cheb12(9) = fval(1)-x(8)*fval(3)
-      alam = x(4)*v(2)
-      cheb24(5) = cheb12(5)+alam
-      cheb24(21) = cheb12(5)-alam
-      alam = x(8)*fval(2)-fval(4)
-      cheb24(9) = cheb12(9)+alam
-      cheb24(17) = cheb12(9)-alam
-      cheb12(1) = fval(1)+fval(3)
-      alam = fval(2)+fval(4)
-      cheb24(1) = cheb12(1)+alam
-      cheb24(25) = cheb12(1)-alam
-      cheb12(13) = v(1)-v(3)
-      cheb24(13) = cheb12(13)
-      alam = 0.1d+01/0.6d+01
-      do 40 i=2,12
-        cheb12(i) = cheb12(i)*alam
-   40 continue
-      alam = 0.5d+00*alam
-      cheb12(1) = cheb12(1)*alam
-      cheb12(13) = cheb12(13)*alam
-      do 50 i=2,24
-        cheb24(i) = cheb24(i)*alam
-   50 continue
-      cheb24(1) = 0.5d+00*alam*cheb24(1)
-      cheb24(25) = 0.5d+00*alam*cheb24(25)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqelg.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqelg.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,184 +0,0 @@
-      recursive subroutine dqelg(n,epstab,result,abserr,res3la,nres)
-c***begin prologue  dqelg
-c***refer to  dqagie,dqagoe,dqagpe,dqagse
-c***routines called  d1mach
-c***revision date  830518   (yymmdd)
-c***keywords  epsilon algorithm, convergence acceleration,
-c             extrapolation
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math & progr. div. - k.u.leuven
-c***purpose  the routine determines the limit of a given sequence of
-c            approximations, by means of the epsilon algorithm of
-c            p.wynn. an estimate of the absolute error is also given.
-c            the condensed epsilon table is computed. only those
-c            elements needed for the computation of the next diagonal
-c            are preserved.
-c***description
-c
-c           epsilon algorithm
-c           standard fortran subroutine
-c           double precision version
-c
-c           parameters
-c              n      - integer
-c                       epstab(n) contains the new element in the
-c                       first column of the epsilon table.
-c
-c              epstab - double precision
-c                       vector of dimension 52 containing the elements
-c                       of the two lower diagonals of the triangular
-c                       epsilon table. the elements are numbered
-c                       starting at the right-hand corner of the
-c                       triangle.
-c
-c              result - double precision
-c                       resulting approximation to the integral
-c
-c              abserr - double precision
-c                       estimate of the absolute error computed from
-c                       result and the 3 previous results
-c
-c              res3la - double precision
-c                       vector of dimension 3 containing the last 3
-c                       results
-c
-c              nres   - integer
-c                       number of calls to the routine
-c                       (should be zero at first call)
-c
-c***end prologue  dqelg
-c
-      double precision abserr,dabs,delta1,delta2,delta3,dmax1,d1mach,
-     *  epmach,epsinf,epstab,error,err1,err2,err3,e0,e1,e1abs,e2,e3,
-     *  oflow,res,result,res3la,ss,tol1,tol2,tol3
-      integer i,ib,ib2,ie,indx,k1,k2,k3,limexp,n,newelm,nres,num
-      dimension epstab(52),res3la(3)
-c
-c           list of major variables
-c           -----------------------
-c
-c           e0     - the 4 elements on which the computation of a new
-c           e1       element in the epsilon table is based
-c           e2
-c           e3                 e0
-c                        e3    e1    new
-c                              e2
-c           newelm - number of elements to be computed in the new
-c                    diagonal
-c           error  - error = abs(e1-e0)+abs(e2-e1)+abs(new-e2)
-c           result - the element in the new diagonal with least value
-c                    of error
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           oflow is the largest positive magnitude.
-c           limexp is the maximum number of elements the epsilon
-c           table can contain. if this number is reached, the upper
-c           diagonal of the epsilon table is deleted.
-c
-c***first executable statement  dqelg
-      epmach = d1mach(4)
-      oflow = d1mach(2)
-      nres = nres+1
-      abserr = oflow
-      result = epstab(n)
-      if(n.lt.3) go to 100
-      limexp = 50
-      epstab(n+2) = epstab(n)
-      newelm = (n-1)/2
-      epstab(n) = oflow
-      num = n
-      k1 = n
-      do 40 i = 1,newelm
-        k2 = k1-1
-        k3 = k1-2
-        res = epstab(k1+2)
-        e0 = epstab(k3)
-        e1 = epstab(k2)
-        e2 = res
-        e1abs = dabs(e1)
-        delta2 = e2-e1
-        err2 = dabs(delta2)
-        tol2 = dmax1(dabs(e2),e1abs)*epmach
-        delta3 = e1-e0
-        err3 = dabs(delta3)
-        tol3 = dmax1(e1abs,dabs(e0))*epmach
-        if(err2.gt.tol2.or.err3.gt.tol3) go to 10
-c
-c           if e0, e1 and e2 are equal to within machine
-c           accuracy, convergence is assumed.
-c           result = e2
-c           abserr = abs(e1-e0)+abs(e2-e1)
-c
-        result = res
-        abserr = err2+err3
-c ***jump out of do-loop
-        go to 100
-   10   e3 = epstab(k1)
-        epstab(k1) = e1
-        delta1 = e1-e3
-        err1 = dabs(delta1)
-        tol1 = dmax1(e1abs,dabs(e3))*epmach
-c
-c           if two elements are very close to each other, omit
-c           a part of the table by adjusting the value of n
-c
-        if(err1.le.tol1.or.err2.le.tol2.or.err3.le.tol3) go to 20
-        ss = 0.1d+01/delta1+0.1d+01/delta2-0.1d+01/delta3
-        epsinf = dabs(ss*e1)
-c
-c           test to detect irregular behaviour in the table, and
-c           eventually omit a part of the table adjusting the value
-c           of n.
-c
-        if(epsinf.gt.0.1d-03) go to 30
-   20   n = i+i-1
-c ***jump out of do-loop
-        go to 50
-c
-c           compute a new element and eventually adjust
-c           the value of result.
-c
-   30   res = e1+0.1d+01/ss
-        epstab(k1) = res
-        k1 = k1-2
-        error = err2+dabs(res-e2)+err3
-        if(error.gt.abserr) go to 40
-        abserr = error
-        result = res
-   40 continue
-c
-c           shift the table.
-c
-   50 if(n.eq.limexp) n = 2*(limexp/2)-1
-      ib = 1
-      if((num/2)*2.eq.num) ib = 2
-      ie = newelm+1
-      do 60 i=1,ie
-        ib2 = ib+2
-        epstab(ib) = epstab(ib2)
-        ib = ib2
-   60 continue
-      if(num.eq.n) go to 80
-      indx = num-n+1
-      do 70 i = 1,n
-        epstab(i)= epstab(indx)
-        indx = indx+1
-   70 continue
-   80 if(nres.ge.4) go to 90
-      res3la(nres) = result
-      abserr = oflow
-      go to 100
-c
-c           compute error estimate
-c
-   90 abserr = dabs(result-res3la(3))+dabs(result-res3la(2))
-     *  +dabs(result-res3la(1))
-      res3la(1) = res3la(2)
-      res3la(2) = res3la(3)
-      res3la(3) = result
-  100 abserr = dmax1(abserr,0.5d+01*epmach*dabs(result))
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqk15.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqk15.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,174 +0,0 @@
-      recursive subroutine dqk15(f,a,b,result,abserr,resabs,resasc)
-c***begin prologue  dqk15
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a2
-c***keywords  15-point gauss-kronrod rules
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div - k.u.leuven
-c***purpose  to compute i = integral of f over (a,b), with error
-c                           estimate
-c                       j = integral of abs(f) over (a,b)
-c***description
-c
-c           integration rules
-c           standard fortran subroutine
-c           double precision version
-c
-c           parameters
-c            on entry
-c              f      - double precision
-c                       function subprogram defining the integrand
-c                       function f(x). the actual name for f needs to be
-c                       declared e x t e r n a l in the calling program.
-c
-c              a      - double precision
-c                       lower limit of integration
-c
-c              b      - double precision
-c                       upper limit of integration
-c
-c            on return
-c              result - double precision
-c                       approximation to the integral i
-c                       result is computed by applying the 15-point
-c                       kronrod rule (resk) obtained by optimal addition
-c                       of abscissae to the7-point gauss rule(resg).
-c
-c              abserr - double precision
-c                       estimate of the modulus of the absolute error,
-c                       which should not exceed abs(i-result)
-c
-c              resabs - double precision
-c                       approximation to the integral j
-c
-c              resasc - double precision
-c                       approximation to the integral of abs(f-i/(b-a))
-c                       over (a,b)
-c
-c***references  (none)
-c***routines called  d1mach
-c***end prologue  dqk15
-c
-      double precision a,absc,abserr,b,centr,dabs,dhlgth,dmax1,dmin1,
-     *  d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,resabs,resasc,
-     *  resg,resk,reskh,result,uflow,wg,wgk,xgk
-      integer j,jtw,jtwm1
-      external f
-c
-      dimension fv1(7),fv2(7),wg(4),wgk(8),xgk(8)
-c
-c           the abscissae and weights are given for the interval (-1,1).
-c           because of symmetry only the positive abscissae and their
-c           corresponding weights are given.
-c
-c           xgk    - abscissae of the 15-point kronrod rule
-c                    xgk(2), xgk(4), ...  abscissae of the 7-point
-c                    gauss rule
-c                    xgk(1), xgk(3), ...  abscissae which are optimally
-c                    added to the 7-point gauss rule
-c
-c           wgk    - weights of the 15-point kronrod rule
-c
-c           wg     - weights of the 7-point gauss rule
-c
-c
-c gauss quadrature weights and kronron quadrature abscissae and weights
-c as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
-c bell labs, nov. 1981.
-c
-      data wg  (  1) / 0.1294849661 6886969327 0611432679 082 d0 /
-      data wg  (  2) / 0.2797053914 8927666790 1467771423 780 d0 /
-      data wg  (  3) / 0.3818300505 0511894495 0369775488 975 d0 /
-      data wg  (  4) / 0.4179591836 7346938775 5102040816 327 d0 /
-c
-      data xgk (  1) / 0.9914553711 2081263920 6854697526 329 d0 /
-      data xgk (  2) / 0.9491079123 4275852452 6189684047 851 d0 /
-      data xgk (  3) / 0.8648644233 5976907278 9712788640 926 d0 /
-      data xgk (  4) / 0.7415311855 9939443986 3864773280 788 d0 /
-      data xgk (  5) / 0.5860872354 6769113029 4144838258 730 d0 /
-      data xgk (  6) / 0.4058451513 7739716690 6606412076 961 d0 /
-      data xgk (  7) / 0.2077849550 0789846760 0689403773 245 d0 /
-      data xgk (  8) / 0.0000000000 0000000000 0000000000 000 d0 /
-c
-      data wgk (  1) / 0.0229353220 1052922496 3732008058 970 d0 /
-      data wgk (  2) / 0.0630920926 2997855329 0700663189 204 d0 /
-      data wgk (  3) / 0.1047900103 2225018383 9876322541 518 d0 /
-      data wgk (  4) / 0.1406532597 1552591874 5189590510 238 d0 /
-      data wgk (  5) / 0.1690047266 3926790282 6583426598 550 d0 /
-      data wgk (  6) / 0.1903505780 6478540991 3256402421 014 d0 /
-      data wgk (  7) / 0.2044329400 7529889241 4161999234 649 d0 /
-      data wgk (  8) / 0.2094821410 8472782801 2999174891 714 d0 /
-c
-c
-c           list of major variables
-c           -----------------------
-c
-c           centr  - mid point of the interval
-c           hlgth  - half-length of the interval
-c           absc   - abscissa
-c           fval*  - function value
-c           resg   - result of the 7-point gauss formula
-c           resk   - result of the 15-point kronrod formula
-c           reskh  - approximation to the mean value of f over (a,b),
-c                    i.e. to i/(b-a)
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-c***first executable statement  dqk15
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-      centr = 0.5d+00*(a+b)
-      hlgth = 0.5d+00*(b-a)
-      dhlgth = dabs(hlgth)
-c
-c           compute the 15-point kronrod approximation to
-c           the integral, and estimate the absolute error.
-c
-      fc = f(centr)
-      resg = fc*wg(4)
-      resk = fc*wgk(8)
-      resabs = dabs(resk)
-      do 10 j=1,3
-        jtw = j*2
-        absc = hlgth*xgk(jtw)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtw) = fval1
-        fv2(jtw) = fval2
-        fsum = fval1+fval2
-        resg = resg+wg(j)*fsum
-        resk = resk+wgk(jtw)*fsum
-        resabs = resabs+wgk(jtw)*(dabs(fval1)+dabs(fval2))
-   10 continue
-      do 15 j = 1,4
-        jtwm1 = j*2-1
-        absc = hlgth*xgk(jtwm1)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtwm1) = fval1
-        fv2(jtwm1) = fval2
-        fsum = fval1+fval2
-        resk = resk+wgk(jtwm1)*fsum
-        resabs = resabs+wgk(jtwm1)*(dabs(fval1)+dabs(fval2))
-   15 continue
-      reskh = resk*0.5d+00
-      resasc = wgk(8)*dabs(fc-reskh)
-      do 20 j=1,7
-        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
-   20 continue
-      result = resk*hlgth
-      resabs = resabs*dhlgth
-      resasc = resasc*dhlgth
-      abserr = dabs((resk-resg)*hlgth)
-      if(resasc.ne.0.0d+00.and.abserr.ne.0.0d+00)
-     *  abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
-      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
-     *  ((epmach*0.5d+02)*resabs,abserr)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqk15i.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqk15i.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,196 +0,0 @@
-      recursive subroutine dqk15i(f,boun,inf,a,b,result,abserr,resabs,
-     *   resasc)
-c***begin prologue  dqk15i
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a3a2,h2a4a2
-c***keywords  15-point transformed gauss-kronrod rules
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  the original (infinite integration range is mapped
-c            onto the interval (0,1) and (a,b) is a part of (0,1).
-c            it is the purpose to compute
-c            i = integral of transformed integrand over (a,b),
-c            j = integral of abs(transformed integrand) over (a,b).
-c***description
-c
-c           integration rule
-c           standard fortran subroutine
-c           double precision version
-c
-c           parameters
-c            on entry
-c              f      - double precision
-c                       function subprogram defining the integrand
-c                       function f(x). the actual name for f needs to be
-c                       declared e x t e r n a l in the calling program.
-c
-c              boun   - double precision
-c                       finite bound of original integration
-c                       range (set to zero if inf = +2)
-c
-c              inf    - integer
-c                       if inf = -1, the original interval is
-c                                   (-infinity,bound),
-c                       if inf = +1, the original interval is
-c                                   (bound,+infinity),
-c                       if inf = +2, the original interval is
-c                                   (-infinity,+infinity) and
-c                       the integral is computed as the sum of two
-c                       integrals, one over (-infinity,0) and one over
-c                       (0,+infinity).
-c
-c              a      - double precision
-c                       lower limit for integration over subrange
-c                       of (0,1)
-c
-c              b      - double precision
-c                       upper limit for integration over subrange
-c                       of (0,1)
-c
-c            on return
-c              result - double precision
-c                       approximation to the integral i
-c                       result is computed by applying the 15-point
-c                       kronrod rule(resk) obtained by optimal addition
-c                       of abscissae to the 7-point gauss rule(resg).
-c
-c              abserr - double precision
-c                       estimate of the modulus of the absolute error,
-c                       which should equal or exceed abs(i-result)
-c
-c              resabs - double precision
-c                       approximation to the integral j
-c
-c              resasc - double precision
-c                       approximation to the integral of
-c                       abs((transformed integrand)-i/(b-a)) over (a,b)
-c
-c***references  (none)
-c***routines called  d1mach
-c***end prologue  dqk15i
-c
-      double precision a,absc,absc1,absc2,abserr,b,boun,centr,dabs,dinf,
-     *  dmax1,dmin1,d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,
-     *  resabs,resasc,resg,resk,reskh,result,tabsc1,tabsc2,uflow,wg,wgk,
-     *  xgk
-      integer inf,j
-      external f
-c
-      dimension fv1(7),fv2(7),xgk(8),wgk(8),wg(8)
-c
-c           the abscissae and weights are supplied for the interval
-c           (-1,1).  because of symmetry only the positive abscissae and
-c           their corresponding weights are given.
-c
-c           xgk    - abscissae of the 15-point kronrod rule
-c                    xgk(2), xgk(4), ... abscissae of the 7-point
-c                    gauss rule
-c                    xgk(1), xgk(3), ...  abscissae which are optimally
-c                    added to the 7-point gauss rule
-c
-c           wgk    - weights of the 15-point kronrod rule
-c
-c           wg     - weights of the 7-point gauss rule, corresponding
-c                    to the abscissae xgk(2), xgk(4), ...
-c                    wg(1), wg(3), ... are set to zero.
-c
-      data wg(1) / 0.0d0 /
-      data wg(2) / 0.1294849661 6886969327 0611432679 082d0 /
-      data wg(3) / 0.0d0 /
-      data wg(4) / 0.2797053914 8927666790 1467771423 780d0 /
-      data wg(5) / 0.0d0 /
-      data wg(6) / 0.3818300505 0511894495 0369775488 975d0 /
-      data wg(7) / 0.0d0 /
-      data wg(8) / 0.4179591836 7346938775 5102040816 327d0 /
-c
-      data xgk(1) / 0.9914553711 2081263920 6854697526 329d0 /
-      data xgk(2) / 0.9491079123 4275852452 6189684047 851d0 /
-      data xgk(3) / 0.8648644233 5976907278 9712788640 926d0 /
-      data xgk(4) / 0.7415311855 9939443986 3864773280 788d0 /
-      data xgk(5) / 0.5860872354 6769113029 4144838258 730d0 /
-      data xgk(6) / 0.4058451513 7739716690 6606412076 961d0 /
-      data xgk(7) / 0.2077849550 0789846760 0689403773 245d0 /
-      data xgk(8) / 0.0000000000 0000000000 0000000000 000d0 /
-c
-      data wgk(1) / 0.0229353220 1052922496 3732008058 970d0 /
-      data wgk(2) / 0.0630920926 2997855329 0700663189 204d0 /
-      data wgk(3) / 0.1047900103 2225018383 9876322541 518d0 /
-      data wgk(4) / 0.1406532597 1552591874 5189590510 238d0 /
-      data wgk(5) / 0.1690047266 3926790282 6583426598 550d0 /
-      data wgk(6) / 0.1903505780 6478540991 3256402421 014d0 /
-      data wgk(7) / 0.2044329400 7529889241 4161999234 649d0 /
-      data wgk(8) / 0.2094821410 8472782801 2999174891 714d0 /
-c
-c
-c           list of major variables
-c           -----------------------
-c
-c           centr  - mid point of the interval
-c           hlgth  - half-length of the interval
-c           absc*  - abscissa
-c           tabsc* - transformed abscissa
-c           fval*  - function value
-c           resg   - result of the 7-point gauss formula
-c           resk   - result of the 15-point kronrod formula
-c           reskh  - approximation to the mean value of the transformed
-c                    integrand over (a,b), i.e. to i/(b-a)
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-c***first executable statement  dqk15i
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-      dinf = min0(1,inf)
-c
-      centr = 0.5d+00*(a+b)
-      hlgth = 0.5d+00*(b-a)
-      tabsc1 = boun+dinf*(0.1d+01-centr)/centr
-      fval1 = f(tabsc1)
-      if(inf.eq.2) fval1 = fval1+f(-tabsc1)
-      fc = (fval1/centr)/centr
-c
-c           compute the 15-point kronrod approximation to
-c           the integral, and estimate the error.
-c
-      resg = wg(8)*fc
-      resk = wgk(8)*fc
-      resabs = dabs(resk)
-      do 10 j=1,7
-        absc = hlgth*xgk(j)
-        absc1 = centr-absc
-        absc2 = centr+absc
-        tabsc1 = boun+dinf*(0.1d+01-absc1)/absc1
-        tabsc2 = boun+dinf*(0.1d+01-absc2)/absc2
-        fval1 = f(tabsc1)
-        fval2 = f(tabsc2)
-        if(inf.eq.2) fval1 = fval1+f(-tabsc1)
-        if(inf.eq.2) fval2 = fval2+f(-tabsc2)
-        fval1 = (fval1/absc1)/absc1
-        fval2 = (fval2/absc2)/absc2
-        fv1(j) = fval1
-        fv2(j) = fval2
-        fsum = fval1+fval2
-        resg = resg+wg(j)*fsum
-        resk = resk+wgk(j)*fsum
-        resabs = resabs+wgk(j)*(dabs(fval1)+dabs(fval2))
-   10 continue
-      reskh = resk*0.5d+00
-      resasc = wgk(8)*dabs(fc-reskh)
-      do 20 j=1,7
-        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
-   20 continue
-      result = resk*hlgth
-      resasc = resasc*hlgth
-      resabs = resabs*hlgth
-      abserr = dabs((resk-resg)*hlgth)
-      if(resasc.ne.0.0d+00.and.abserr.ne.0.d0) abserr = resasc*
-     * dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
-      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
-     * ((epmach*0.5d+02)*resabs,abserr)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqk15w.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqk15w.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,180 +0,0 @@
-      recursive subroutine dqk15w(f,w,p1,p2,p3,p4,kp,a,b,result,abserr,
-     *   resabs,resasc)
-c***begin prologue  dqk15w
-c***date written   810101   (yymmdd)
-c***revision date  830518   (mmddyy)
-c***category no.  h2a2a2
-c***keywords  15-point gauss-kronrod rules
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  to compute i = integral of f*w over (a,b), with error
-c                           estimate
-c                       j = integral of abs(f*w) over (a,b)
-c***description
-c
-c           integration rules
-c           standard fortran subroutine
-c           double precision version
-c
-c           parameters
-c             on entry
-c              f      - double precision
-c                       function subprogram defining the integrand
-c                       function f(x). the actual name for f needs to be
-c                       declared e x t e r n a l in the driver program.
-c
-c              w      - double precision
-c                       function subprogram defining the integrand
-c                       weight function w(x). the actual name for w
-c                       needs to be declared e x t e r n a l in the
-c                       calling program.
-c
-c              p1, p2, p3, p4 - double precision
-c                       parameters in the weight function
-c
-c              kp     - integer
-c                       key for indicating the type of weight function
-c
-c              a      - double precision
-c                       lower limit of integration
-c
-c              b      - double precision
-c                       upper limit of integration
-c
-c            on return
-c              result - double precision
-c                       approximation to the integral i
-c                       result is computed by applying the 15-point
-c                       kronrod rule (resk) obtained by optimal addition
-c                       of abscissae to the 7-point gauss rule (resg).
-c
-c              abserr - double precision
-c                       estimate of the modulus of the absolute error,
-c                       which should equal or exceed abs(i-result)
-c
-c              resabs - double precision
-c                       approximation to the integral of abs(f)
-c
-c              resasc - double precision
-c                       approximation to the integral of abs(f-i/(b-a))
-c
-c
-c***references  (none)
-c***routines called  d1mach
-c***end prologue  dqk15w
-c
-      double precision a,absc,absc1,absc2,abserr,b,centr,dabs,dhlgth,
-     *  dmax1,dmin1,d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,
-     *  p1,p2,p3,p4,resabs,resasc,resg,resk,reskh,result,uflow,w,wg,wgk,
-     *  xgk
-      integer j,jtw,jtwm1,kp
-      external f,w
-c
-      dimension fv1(7),fv2(7),xgk(8),wgk(8),wg(4)
-c
-c           the abscissae and weights are given for the interval (-1,1).
-c           because of symmetry only the positive abscissae and their
-c           corresponding weights are given.
-c
-c           xgk    - abscissae of the 15-point gauss-kronrod rule
-c                    xgk(2), xgk(4), ... abscissae of the 7-point
-c                    gauss rule
-c                    xgk(1), xgk(3), ... abscissae which are optimally
-c                    added to the 7-point gauss rule
-c
-c           wgk    - weights of the 15-point gauss-kronrod rule
-c
-c           wg     - weights of the 7-point gauss rule
-c
-      data xgk(1),xgk(2),xgk(3),xgk(4),xgk(5),xgk(6),xgk(7),xgk(8)/
-     *     0.9914553711208126d+00,     0.9491079123427585d+00,
-     *     0.8648644233597691d+00,     0.7415311855993944d+00,
-     *     0.5860872354676911d+00,     0.4058451513773972d+00,
-     *     0.2077849550078985d+00,     0.0000000000000000d+00/
-c
-      data wgk(1),wgk(2),wgk(3),wgk(4),wgk(5),wgk(6),wgk(7),wgk(8)/
-     *     0.2293532201052922d-01,     0.6309209262997855d-01,
-     *     0.1047900103222502d+00,     0.1406532597155259d+00,
-     *     0.1690047266392679d+00,     0.1903505780647854d+00,
-     *     0.2044329400752989d+00,     0.2094821410847278d+00/
-c
-      data wg(1),wg(2),wg(3),wg(4)/
-     *     0.1294849661688697d+00,    0.2797053914892767d+00,
-     *     0.3818300505051189d+00,    0.4179591836734694d+00/
-c
-c
-c           list of major variables
-c           -----------------------
-c
-c           centr  - mid point of the interval
-c           hlgth  - half-length of the interval
-c           absc*  - abscissa
-c           fval*  - function value
-c           resg   - result of the 7-point gauss formula
-c           resk   - result of the 15-point kronrod formula
-c           reskh  - approximation to the mean value of f*w over (a,b),
-c                    i.e. to i/(b-a)
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-c***first executable statement  dqk15w
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-      centr = 0.5d+00*(a+b)
-      hlgth = 0.5d+00*(b-a)
-      dhlgth = dabs(hlgth)
-c
-c           compute the 15-point kronrod approximation to the
-c           integral, and estimate the error.
-c
-      fc = f(centr)*w(centr,p1,p2,p3,p4,kp)
-      resg = wg(4)*fc
-      resk = wgk(8)*fc
-      resabs = dabs(resk)
-      do 10 j=1,3
-        jtw = j*2
-        absc = hlgth*xgk(jtw)
-        absc1 = centr-absc
-        absc2 = centr+absc
-        fval1 = f(absc1)*w(absc1,p1,p2,p3,p4,kp)
-        fval2 = f(absc2)*w(absc2,p1,p2,p3,p4,kp)
-        fv1(jtw) = fval1
-        fv2(jtw) = fval2
-        fsum = fval1+fval2
-        resg = resg+wg(j)*fsum
-        resk = resk+wgk(jtw)*fsum
-        resabs = resabs+wgk(jtw)*(dabs(fval1)+dabs(fval2))
-   10 continue
-      do 15 j=1,4
-        jtwm1 = j*2-1
-        absc = hlgth*xgk(jtwm1)
-        absc1 = centr-absc
-        absc2 = centr+absc
-        fval1 = f(absc1)*w(absc1,p1,p2,p3,p4,kp)
-        fval2 = f(absc2)*w(absc2,p1,p2,p3,p4,kp)
-        fv1(jtwm1) = fval1
-        fv2(jtwm1) = fval2
-        fsum = fval1+fval2
-        resk = resk+wgk(jtwm1)*fsum
-        resabs = resabs+wgk(jtwm1)*(dabs(fval1)+dabs(fval2))
-   15 continue
-      reskh = resk*0.5d+00
-      resasc = wgk(8)*dabs(fc-reskh)
-      do 20 j=1,7
-        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
-   20 continue
-      result = resk*hlgth
-      resabs = resabs*dhlgth
-      resasc = resasc*dhlgth
-      abserr = dabs((resk-resg)*hlgth)
-      if(resasc.ne.0.0d+00.and.abserr.ne.0.0d+00)
-     *  abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
-      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1((epmach*
-     *  0.5d+02)*resabs,abserr)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqk21.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqk21.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,182 +0,0 @@
-      recursive subroutine dqk21(f,a,b,result,abserr,resabs,resasc)
-c***begin prologue  dqk21
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a2
-c***keywords  21-point gauss-kronrod rules
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  to compute i = integral of f over (a,b), with error
-c                           estimate
-c                       j = integral of abs(f) over (a,b)
-c***description
-c
-c           integration rules
-c           standard fortran subroutine
-c           double precision version
-c
-c           parameters
-c            on entry
-c              f      - double precision
-c                       function subprogram defining the integrand
-c                       function f(x). the actual name for f needs to be
-c                       declared e x t e r n a l in the driver program.
-c
-c              a      - double precision
-c                       lower limit of integration
-c
-c              b      - double precision
-c                       upper limit of integration
-c
-c            on return
-c              result - double precision
-c                       approximation to the integral i
-c                       result is computed by applying the 21-point
-c                       kronrod rule (resk) obtained by optimal addition
-c                       of abscissae to the 10-point gauss rule (resg).
-c
-c              abserr - double precision
-c                       estimate of the modulus of the absolute error,
-c                       which should not exceed abs(i-result)
-c
-c              resabs - double precision
-c                       approximation to the integral j
-c
-c              resasc - double precision
-c                       approximation to the integral of abs(f-i/(b-a))
-c                       over (a,b)
-c
-c***references  (none)
-c***routines called  d1mach
-c***end prologue  dqk21
-c
-      double precision a,absc,abserr,b,centr,dabs,dhlgth,dmax1,dmin1,
-     *  d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,resabs,resasc,
-     *  resg,resk,reskh,result,uflow,wg,wgk,xgk
-      integer j,jtw,jtwm1
-      external f
-c
-      dimension fv1(10),fv2(10),wg(5),wgk(11),xgk(11)
-c
-c           the abscissae and weights are given for the interval (-1,1).
-c           because of symmetry only the positive abscissae and their
-c           corresponding weights are given.
-c
-c           xgk    - abscissae of the 21-point kronrod rule
-c                    xgk(2), xgk(4), ...  abscissae of the 10-point
-c                    gauss rule
-c                    xgk(1), xgk(3), ...  abscissae which are optimally
-c                    added to the 10-point gauss rule
-c
-c           wgk    - weights of the 21-point kronrod rule
-c
-c           wg     - weights of the 10-point gauss rule
-c
-c
-c gauss quadrature weights and kronron quadrature abscissae and weights
-c as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
-c bell labs, nov. 1981.
-c
-      data wg  (  1) / 0.0666713443 0868813759 3568809893 332 d0 /
-      data wg  (  2) / 0.1494513491 5058059314 5776339657 697 d0 /
-      data wg  (  3) / 0.2190863625 1598204399 5534934228 163 d0 /
-      data wg  (  4) / 0.2692667193 0999635509 1226921569 469 d0 /
-      data wg  (  5) / 0.2955242247 1475287017 3892994651 338 d0 /
-c
-      data xgk (  1) / 0.9956571630 2580808073 5527280689 003 d0 /
-      data xgk (  2) / 0.9739065285 1717172007 7964012084 452 d0 /
-      data xgk (  3) / 0.9301574913 5570822600 1207180059 508 d0 /
-      data xgk (  4) / 0.8650633666 8898451073 2096688423 493 d0 /
-      data xgk (  5) / 0.7808177265 8641689706 3717578345 042 d0 /
-      data xgk (  6) / 0.6794095682 9902440623 4327365114 874 d0 /
-      data xgk (  7) / 0.5627571346 6860468333 9000099272 694 d0 /
-      data xgk (  8) / 0.4333953941 2924719079 9265943165 784 d0 /
-      data xgk (  9) / 0.2943928627 0146019813 1126603103 866 d0 /
-      data xgk ( 10) / 0.1488743389 8163121088 4826001129 720 d0 /
-      data xgk ( 11) / 0.0000000000 0000000000 0000000000 000 d0 /
-c
-      data wgk (  1) / 0.0116946388 6737187427 8064396062 192 d0 /
-      data wgk (  2) / 0.0325581623 0796472747 8818972459 390 d0 /
-      data wgk (  3) / 0.0547558965 7435199603 1381300244 580 d0 /
-      data wgk (  4) / 0.0750396748 1091995276 7043140916 190 d0 /
-      data wgk (  5) / 0.0931254545 8369760553 5065465083 366 d0 /
-      data wgk (  6) / 0.1093871588 0229764189 9210590325 805 d0 /
-      data wgk (  7) / 0.1234919762 6206585107 7958109831 074 d0 /
-      data wgk (  8) / 0.1347092173 1147332592 8054001771 707 d0 /
-      data wgk (  9) / 0.1427759385 7706008079 7094273138 717 d0 /
-      data wgk ( 10) / 0.1477391049 0133849137 4841515972 068 d0 /
-      data wgk ( 11) / 0.1494455540 0291690566 4936468389 821 d0 /
-c
-c
-c           list of major variables
-c           -----------------------
-c
-c           centr  - mid point of the interval
-c           hlgth  - half-length of the interval
-c           absc   - abscissa
-c           fval*  - function value
-c           resg   - result of the 10-point gauss formula
-c           resk   - result of the 21-point kronrod formula
-c           reskh  - approximation to the mean value of f over (a,b),
-c                    i.e. to i/(b-a)
-c
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-c***first executable statement  dqk21
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-      centr = 0.5d+00*(a+b)
-      hlgth = 0.5d+00*(b-a)
-      dhlgth = dabs(hlgth)
-c
-c           compute the 21-point kronrod approximation to
-c           the integral, and estimate the absolute error.
-c
-      resg = 0.0d+00
-      fc = f(centr)
-      resk = wgk(11)*fc
-      resabs = dabs(resk)
-      do 10 j=1,5
-        jtw = 2*j
-        absc = hlgth*xgk(jtw)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtw) = fval1
-        fv2(jtw) = fval2
-        fsum = fval1+fval2
-        resg = resg+wg(j)*fsum
-        resk = resk+wgk(jtw)*fsum
-        resabs = resabs+wgk(jtw)*(dabs(fval1)+dabs(fval2))
-   10 continue
-      do 15 j = 1,5
-        jtwm1 = 2*j-1
-        absc = hlgth*xgk(jtwm1)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtwm1) = fval1
-        fv2(jtwm1) = fval2
-        fsum = fval1+fval2
-        resk = resk+wgk(jtwm1)*fsum
-        resabs = resabs+wgk(jtwm1)*(dabs(fval1)+dabs(fval2))
-   15 continue
-      reskh = resk*0.5d+00
-      resasc = wgk(11)*dabs(fc-reskh)
-      do 20 j=1,10
-        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
-   20 continue
-      result = resk*hlgth
-      resabs = resabs*dhlgth
-      resasc = resasc*dhlgth
-      abserr = dabs((resk-resg)*hlgth)
-      if(resasc.ne.0.0d+00.and.abserr.ne.0.0d+00)
-     *  abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
-      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
-     *  ((epmach*0.5d+02)*resabs,abserr)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqk31.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqk31.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,191 +0,0 @@
-      recursive subroutine dqk31(f,a,b,result,abserr,resabs,resasc)
-c***begin prologue  dqk31
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a2
-c***keywords  31-point gauss-kronrod rules
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  to compute i = integral of f over (a,b) with error
-c                           estimate
-c                       j = integral of abs(f) over (a,b)
-c***description
-c
-c           integration rules
-c           standard fortran subroutine
-c           double precision version
-c
-c           parameters
-c            on entry
-c              f      - double precision
-c                       function subprogram defining the integrand
-c                       function f(x). the actual name for f needs to be
-c                       declared e x t e r n a l in the calling program.
-c
-c              a      - double precision
-c                       lower limit of integration
-c
-c              b      - double precision
-c                       upper limit of integration
-c
-c            on return
-c              result - double precision
-c                       approximation to the integral i
-c                       result is computed by applying the 31-point
-c                       gauss-kronrod rule (resk), obtained by optimal
-c                       addition of abscissae to the 15-point gauss
-c                       rule (resg).
-c
-c              abserr - double precision
-c                       estimate of the modulus of the modulus,
-c                       which should not exceed abs(i-result)
-c
-c              resabs - double precision
-c                       approximation to the integral j
-c
-c              resasc - double precision
-c                       approximation to the integral of abs(f-i/(b-a))
-c                       over (a,b)
-c
-c***references  (none)
-c***routines called  d1mach
-c***end prologue  dqk31
-      double precision a,absc,abserr,b,centr,dabs,dhlgth,dmax1,dmin1,
-     *  d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,resabs,resasc,
-     *  resg,resk,reskh,result,uflow,wg,wgk,xgk
-      integer j,jtw,jtwm1
-      external f
-c
-      dimension fv1(15),fv2(15),xgk(16),wgk(16),wg(8)
-c
-c           the abscissae and weights are given for the interval (-1,1).
-c           because of symmetry only the positive abscissae and their
-c           corresponding weights are given.
-c
-c           xgk    - abscissae of the 31-point kronrod rule
-c                    xgk(2), xgk(4), ...  abscissae of the 15-point
-c                    gauss rule
-c                    xgk(1), xgk(3), ...  abscissae which are optimally
-c                    added to the 15-point gauss rule
-c
-c           wgk    - weights of the 31-point kronrod rule
-c
-c           wg     - weights of the 15-point gauss rule
-c
-c
-c gauss quadrature weights and kronron quadrature abscissae and weights
-c as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
-c bell labs, nov. 1981.
-c
-      data wg  (  1) / 0.0307532419 9611726835 4628393577 204 d0 /
-      data wg  (  2) / 0.0703660474 8810812470 9267416450 667 d0 /
-      data wg  (  3) / 0.1071592204 6717193501 1869546685 869 d0 /
-      data wg  (  4) / 0.1395706779 2615431444 7804794511 028 d0 /
-      data wg  (  5) / 0.1662692058 1699393355 3200860481 209 d0 /
-      data wg  (  6) / 0.1861610000 1556221102 6800561866 423 d0 /
-      data wg  (  7) / 0.1984314853 2711157645 6118326443 839 d0 /
-      data wg  (  8) / 0.2025782419 2556127288 0620199967 519 d0 /
-c
-      data xgk (  1) / 0.9980022986 9339706028 5172840152 271 d0 /
-      data xgk (  2) / 0.9879925180 2048542848 9565718586 613 d0 /
-      data xgk (  3) / 0.9677390756 7913913425 7347978784 337 d0 /
-      data xgk (  4) / 0.9372733924 0070590430 7758947710 209 d0 /
-      data xgk (  5) / 0.8972645323 4408190088 2509656454 496 d0 /
-      data xgk (  6) / 0.8482065834 1042721620 0648320774 217 d0 /
-      data xgk (  7) / 0.7904185014 4246593296 7649294817 947 d0 /
-      data xgk (  8) / 0.7244177313 6017004741 6186054613 938 d0 /
-      data xgk (  9) / 0.6509967412 9741697053 3735895313 275 d0 /
-      data xgk ( 10) / 0.5709721726 0853884753 7226737253 911 d0 /
-      data xgk ( 11) / 0.4850818636 4023968069 3655740232 351 d0 /
-      data xgk ( 12) / 0.3941513470 7756336989 7207370981 045 d0 /
-      data xgk ( 13) / 0.2991800071 5316881216 6780024266 389 d0 /
-      data xgk ( 14) / 0.2011940939 9743452230 0628303394 596 d0 /
-      data xgk ( 15) / 0.1011420669 1871749902 7074231447 392 d0 /
-      data xgk ( 16) / 0.0000000000 0000000000 0000000000 000 d0 /
-c
-      data wgk (  1) / 0.0053774798 7292334898 7792051430 128 d0 /
-      data wgk (  2) / 0.0150079473 2931612253 8374763075 807 d0 /
-      data wgk (  3) / 0.0254608473 2671532018 6874001019 653 d0 /
-      data wgk (  4) / 0.0353463607 9137584622 2037948478 360 d0 /
-      data wgk (  5) / 0.0445897513 2476487660 8227299373 280 d0 /
-      data wgk (  6) / 0.0534815246 9092808726 5343147239 430 d0 /
-      data wgk (  7) / 0.0620095678 0067064028 5139230960 803 d0 /
-      data wgk (  8) / 0.0698541213 1872825870 9520077099 147 d0 /
-      data wgk (  9) / 0.0768496807 5772037889 4432777482 659 d0 /
-      data wgk ( 10) / 0.0830805028 2313302103 8289247286 104 d0 /
-      data wgk ( 11) / 0.0885644430 5621177064 7275443693 774 d0 /
-      data wgk ( 12) / 0.0931265981 7082532122 5486872747 346 d0 /
-      data wgk ( 13) / 0.0966427269 8362367850 5179907627 589 d0 /
-      data wgk ( 14) / 0.0991735987 2179195933 2393173484 603 d0 /
-      data wgk ( 15) / 0.1007698455 2387559504 4946662617 570 d0 /
-      data wgk ( 16) / 0.1013300070 1479154901 7374792767 493 d0 /
-c
-c
-c           list of major variables
-c           -----------------------
-c           centr  - mid point of the interval
-c           hlgth  - half-length of the interval
-c           absc   - abscissa
-c           fval*  - function value
-c           resg   - result of the 15-point gauss formula
-c           resk   - result of the 31-point kronrod formula
-c           reskh  - approximation to the mean value of f over (a,b),
-c                    i.e. to i/(b-a)
-c
-c           machine dependent constants
-c           ---------------------------
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c***first executable statement  dqk31
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-      centr = 0.5d+00*(a+b)
-      hlgth = 0.5d+00*(b-a)
-      dhlgth = dabs(hlgth)
-c
-c           compute the 31-point kronrod approximation to
-c           the integral, and estimate the absolute error.
-c
-      fc = f(centr)
-      resg = wg(8)*fc
-      resk = wgk(16)*fc
-      resabs = dabs(resk)
-      do 10 j=1,7
-        jtw = j*2
-        absc = hlgth*xgk(jtw)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtw) = fval1
-        fv2(jtw) = fval2
-        fsum = fval1+fval2
-        resg = resg+wg(j)*fsum
-        resk = resk+wgk(jtw)*fsum
-        resabs = resabs+wgk(jtw)*(dabs(fval1)+dabs(fval2))
-   10 continue
-      do 15 j = 1,8
-        jtwm1 = j*2-1
-        absc = hlgth*xgk(jtwm1)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtwm1) = fval1
-        fv2(jtwm1) = fval2
-        fsum = fval1+fval2
-        resk = resk+wgk(jtwm1)*fsum
-        resabs = resabs+wgk(jtwm1)*(dabs(fval1)+dabs(fval2))
-   15 continue
-      reskh = resk*0.5d+00
-      resasc = wgk(16)*dabs(fc-reskh)
-      do 20 j=1,15
-        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
-   20 continue
-      result = resk*hlgth
-      resabs = resabs*dhlgth
-      resasc = resasc*dhlgth
-      abserr = dabs((resk-resg)*hlgth)
-      if(resasc.ne.0.0d+00.and.abserr.ne.0.0d+00)
-     *  abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
-      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
-     *  ((epmach*0.5d+02)*resabs,abserr)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqk41.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqk41.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,207 +0,0 @@
-      recursive subroutine dqk41(f,a,b,result,abserr,resabs,resasc)
-c***begin prologue  dqk41
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a2
-c***keywords  41-point gauss-kronrod rules
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  to compute i = integral of f over (a,b), with error
-c                           estimate
-c                       j = integral of abs(f) over (a,b)
-c***description
-c
-c           integration rules
-c           standard fortran subroutine
-c           double precision version
-c
-c           parameters
-c            on entry
-c              f      - double precision
-c                       function subprogram defining the integrand
-c                       function f(x). the actual name for f needs to be
-c                       declared e x t e r n a l in the calling program.
-c
-c              a      - double precision
-c                       lower limit of integration
-c
-c              b      - double precision
-c                       upper limit of integration
-c
-c            on return
-c              result - double precision
-c                       approximation to the integral i
-c                       result is computed by applying the 41-point
-c                       gauss-kronrod rule (resk) obtained by optimal
-c                       addition of abscissae to the 20-point gauss
-c                       rule (resg).
-c
-c              abserr - double precision
-c                       estimate of the modulus of the absolute error,
-c                       which should not exceed abs(i-result)
-c
-c              resabs - double precision
-c                       approximation to the integral j
-c
-c              resasc - double precision
-c                       approximation to the integal of abs(f-i/(b-a))
-c                       over (a,b)
-c
-c***references  (none)
-c***routines called  d1mach
-c***end prologue  dqk41
-c
-      double precision a,absc,abserr,b,centr,dabs,dhlgth,dmax1,dmin1,
-     *  d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,resabs,resasc,
-     *  resg,resk,reskh,result,uflow,wg,wgk,xgk
-      integer j,jtw,jtwm1
-      external f
-c
-      dimension fv1(20),fv2(20),xgk(21),wgk(21),wg(10)
-c
-c           the abscissae and weights are given for the interval (-1,1).
-c           because of symmetry only the positive abscissae and their
-c           corresponding weights are given.
-c
-c           xgk    - abscissae of the 41-point gauss-kronrod rule
-c                    xgk(2), xgk(4), ...  abscissae of the 20-point
-c                    gauss rule
-c                    xgk(1), xgk(3), ...  abscissae which are optimally
-c                    added to the 20-point gauss rule
-c
-c           wgk    - weights of the 41-point gauss-kronrod rule
-c
-c           wg     - weights of the 20-point gauss rule
-c
-c
-c gauss quadrature weights and kronron quadrature abscissae and weights
-c as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
-c bell labs, nov. 1981.
-c
-      data wg  (  1) / 0.0176140071 3915211831 1861962351 853 d0 /
-      data wg  (  2) / 0.0406014298 0038694133 1039952274 932 d0 /
-      data wg  (  3) / 0.0626720483 3410906356 9506535187 042 d0 /
-      data wg  (  4) / 0.0832767415 7670474872 4758143222 046 d0 /
-      data wg  (  5) / 0.1019301198 1724043503 6750135480 350 d0 /
-      data wg  (  6) / 0.1181945319 6151841731 2377377711 382 d0 /
-      data wg  (  7) / 0.1316886384 4917662689 8494499748 163 d0 /
-      data wg  (  8) / 0.1420961093 1838205132 9298325067 165 d0 /
-      data wg  (  9) / 0.1491729864 7260374678 7828737001 969 d0 /
-      data wg  ( 10) / 0.1527533871 3072585069 8084331955 098 d0 /
-c
-      data xgk (  1) / 0.9988590315 8827766383 8315576545 863 d0 /
-      data xgk (  2) / 0.9931285991 8509492478 6122388471 320 d0 /
-      data xgk (  3) / 0.9815078774 5025025919 3342994720 217 d0 /
-      data xgk (  4) / 0.9639719272 7791379126 7666131197 277 d0 /
-      data xgk (  5) / 0.9408226338 3175475351 9982722212 443 d0 /
-      data xgk (  6) / 0.9122344282 5132590586 7752441203 298 d0 /
-      data xgk (  7) / 0.8782768112 5228197607 7442995113 078 d0 /
-      data xgk (  8) / 0.8391169718 2221882339 4529061701 521 d0 /
-      data xgk (  9) / 0.7950414288 3755119835 0638833272 788 d0 /
-      data xgk ( 10) / 0.7463319064 6015079261 4305070355 642 d0 /
-      data xgk ( 11) / 0.6932376563 3475138480 5490711845 932 d0 /
-      data xgk ( 12) / 0.6360536807 2651502545 2836696226 286 d0 /
-      data xgk ( 13) / 0.5751404468 1971031534 2946036586 425 d0 /
-      data xgk ( 14) / 0.5108670019 5082709800 4364050955 251 d0 /
-      data xgk ( 15) / 0.4435931752 3872510319 9992213492 640 d0 /
-      data xgk ( 16) / 0.3737060887 1541956067 2548177024 927 d0 /
-      data xgk ( 17) / 0.3016278681 1491300432 0555356858 592 d0 /
-      data xgk ( 18) / 0.2277858511 4164507808 0496195368 575 d0 /
-      data xgk ( 19) / 0.1526054652 4092267550 5220241022 678 d0 /
-      data xgk ( 20) / 0.0765265211 3349733375 4640409398 838 d0 /
-      data xgk ( 21) / 0.0000000000 0000000000 0000000000 000 d0 /
-c
-      data wgk (  1) / 0.0030735837 1852053150 1218293246 031 d0 /
-      data wgk (  2) / 0.0086002698 5564294219 8661787950 102 d0 /
-      data wgk (  3) / 0.0146261692 5697125298 3787960308 868 d0 /
-      data wgk (  4) / 0.0203883734 6126652359 8010231432 755 d0 /
-      data wgk (  5) / 0.0258821336 0495115883 4505067096 153 d0 /
-      data wgk (  6) / 0.0312873067 7703279895 8543119323 801 d0 /
-      data wgk (  7) / 0.0366001697 5820079803 0557240707 211 d0 /
-      data wgk (  8) / 0.0416688733 2797368626 3788305936 895 d0 /
-      data wgk (  9) / 0.0464348218 6749767472 0231880926 108 d0 /
-      data wgk ( 10) / 0.0509445739 2372869193 2707670050 345 d0 /
-      data wgk ( 11) / 0.0551951053 4828599474 4832372419 777 d0 /
-      data wgk ( 12) / 0.0591114008 8063957237 4967220648 594 d0 /
-      data wgk ( 13) / 0.0626532375 5478116802 5870122174 255 d0 /
-      data wgk ( 14) / 0.0658345971 3361842211 1563556969 398 d0 /
-      data wgk ( 15) / 0.0686486729 2852161934 5623411885 368 d0 /
-      data wgk ( 16) / 0.0710544235 5344406830 5790361723 210 d0 /
-      data wgk ( 17) / 0.0730306903 3278666749 5189417658 913 d0 /
-      data wgk ( 18) / 0.0745828754 0049918898 6581418362 488 d0 /
-      data wgk ( 19) / 0.0757044976 8455667465 9542775376 617 d0 /
-      data wgk ( 20) / 0.0763778676 7208073670 5502835038 061 d0 /
-      data wgk ( 21) / 0.0766007119 1799965644 5049901530 102 d0 /
-c
-c
-c           list of major variables
-c           -----------------------
-c
-c           centr  - mid point of the interval
-c           hlgth  - half-length of the interval
-c           absc   - abscissa
-c           fval*  - function value
-c           resg   - result of the 20-point gauss formula
-c           resk   - result of the 41-point kronrod formula
-c           reskh  - approximation to mean value of f over (a,b), i.e.
-c                    to i/(b-a)
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-c***first executable statement  dqk41
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-      centr = 0.5d+00*(a+b)
-      hlgth = 0.5d+00*(b-a)
-      dhlgth = dabs(hlgth)
-c
-c           compute the 41-point gauss-kronrod approximation to
-c           the integral, and estimate the absolute error.
-c
-      resg = 0.0d+00
-      fc = f(centr)
-      resk = wgk(21)*fc
-      resabs = dabs(resk)
-      do 10 j=1,10
-        jtw = j*2
-        absc = hlgth*xgk(jtw)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtw) = fval1
-        fv2(jtw) = fval2
-        fsum = fval1+fval2
-        resg = resg+wg(j)*fsum
-        resk = resk+wgk(jtw)*fsum
-        resabs = resabs+wgk(jtw)*(dabs(fval1)+dabs(fval2))
-   10 continue
-      do 15 j = 1,10
-        jtwm1 = j*2-1
-        absc = hlgth*xgk(jtwm1)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtwm1) = fval1
-        fv2(jtwm1) = fval2
-        fsum = fval1+fval2
-        resk = resk+wgk(jtwm1)*fsum
-        resabs = resabs+wgk(jtwm1)*(dabs(fval1)+dabs(fval2))
-   15 continue
-      reskh = resk*0.5d+00
-      resasc = wgk(21)*dabs(fc-reskh)
-      do 20 j=1,20
-        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
-   20 continue
-      result = resk*hlgth
-      resabs = resabs*dhlgth
-      resasc = resasc*dhlgth
-      abserr = dabs((resk-resg)*hlgth)
-      if(resasc.ne.0.0d+00.and.abserr.ne.0.d+00)
-     *  abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
-      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
-     *  ((epmach*0.5d+02)*resabs,abserr)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqk51.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqk51.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,220 +0,0 @@
-      recursive subroutine dqk51(f,a,b,result,abserr,resabs,resasc)
-c***begin prologue  dqk51
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a2
-c***keywords  51-point gauss-kronrod rules
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math & progr. div. - k.u.leuven
-c***purpose  to compute i = integral of f over (a,b) with error
-c                           estimate
-c                       j = integral of abs(f) over (a,b)
-c***description
-c
-c           integration rules
-c           standard fortran subroutine
-c           double precision version
-c
-c           parameters
-c            on entry
-c              f      - double precision
-c                       function subroutine defining the integrand
-c                       function f(x). the actual name for f needs to be
-c                       declared e x t e r n a l in the calling program.
-c
-c              a      - double precision
-c                       lower limit of integration
-c
-c              b      - double precision
-c                       upper limit of integration
-c
-c            on return
-c              result - double precision
-c                       approximation to the integral i
-c                       result is computed by applying the 51-point
-c                       kronrod rule (resk) obtained by optimal addition
-c                       of abscissae to the 25-point gauss rule (resg).
-c
-c              abserr - double precision
-c                       estimate of the modulus of the absolute error,
-c                       which should not exceed abs(i-result)
-c
-c              resabs - double precision
-c                       approximation to the integral j
-c
-c              resasc - double precision
-c                       approximation to the integral of abs(f-i/(b-a))
-c                       over (a,b)
-c
-c***references  (none)
-c***routines called  d1mach
-c***end prologue  dqk51
-c
-      double precision a,absc,abserr,b,centr,dabs,dhlgth,dmax1,dmin1,
-     *  d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,resabs,resasc,
-     *  resg,resk,reskh,result,uflow,wg,wgk,xgk
-      integer j,jtw,jtwm1
-      external f
-c
-      dimension fv1(25),fv2(25),xgk(26),wgk(26),wg(13)
-c
-c           the abscissae and weights are given for the interval (-1,1).
-c           because of symmetry only the positive abscissae and their
-c           corresponding weights are given.
-c
-c           xgk    - abscissae of the 51-point kronrod rule
-c                    xgk(2), xgk(4), ...  abscissae of the 25-point
-c                    gauss rule
-c                    xgk(1), xgk(3), ...  abscissae which are optimally
-c                    added to the 25-point gauss rule
-c
-c           wgk    - weights of the 51-point kronrod rule
-c
-c           wg     - weights of the 25-point gauss rule
-c
-c
-c gauss quadrature weights and kronron quadrature abscissae and weights
-c as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
-c bell labs, nov. 1981.
-c
-      data wg  (  1) / 0.0113937985 0102628794 7902964113 235 d0 /
-      data wg  (  2) / 0.0263549866 1503213726 1901815295 299 d0 /
-      data wg  (  3) / 0.0409391567 0130631265 5623487711 646 d0 /
-      data wg  (  4) / 0.0549046959 7583519192 5936891540 473 d0 /
-      data wg  (  5) / 0.0680383338 1235691720 7187185656 708 d0 /
-      data wg  (  6) / 0.0801407003 3500101801 3234959669 111 d0 /
-      data wg  (  7) / 0.0910282619 8296364981 1497220702 892 d0 /
-      data wg  (  8) / 0.1005359490 6705064420 2206890392 686 d0 /
-      data wg  (  9) / 0.1085196244 7426365311 6093957050 117 d0 /
-      data wg  ( 10) / 0.1148582591 4571164833 9325545869 556 d0 /
-      data wg  ( 11) / 0.1194557635 3578477222 8178126512 901 d0 /
-      data wg  ( 12) / 0.1222424429 9031004168 8959518945 852 d0 /
-      data wg  ( 13) / 0.1231760537 2671545120 3902873079 050 d0 /
-c
-      data xgk (  1) / 0.9992621049 9260983419 3457486540 341 d0 /
-      data xgk (  2) / 0.9955569697 9049809790 8784946893 902 d0 /
-      data xgk (  3) / 0.9880357945 3407724763 7331014577 406 d0 /
-      data xgk (  4) / 0.9766639214 5951751149 8315386479 594 d0 /
-      data xgk (  5) / 0.9616149864 2584251241 8130033660 167 d0 /
-      data xgk (  6) / 0.9429745712 2897433941 4011169658 471 d0 /
-      data xgk (  7) / 0.9207471152 8170156174 6346084546 331 d0 /
-      data xgk (  8) / 0.8949919978 7827536885 1042006782 805 d0 /
-      data xgk (  9) / 0.8658470652 9327559544 8996969588 340 d0 /
-      data xgk ( 10) / 0.8334426287 6083400142 1021108693 570 d0 /
-      data xgk ( 11) / 0.7978737979 9850005941 0410904994 307 d0 /
-      data xgk ( 12) / 0.7592592630 3735763057 7282865204 361 d0 /
-      data xgk ( 13) / 0.7177664068 1308438818 6654079773 298 d0 /
-      data xgk ( 14) / 0.6735663684 7346836448 5120633247 622 d0 /
-      data xgk ( 15) / 0.6268100990 1031741278 8122681624 518 d0 /
-      data xgk ( 16) / 0.5776629302 4122296772 3689841612 654 d0 /
-      data xgk ( 17) / 0.5263252843 3471918259 9623778158 010 d0 /
-      data xgk ( 18) / 0.4730027314 4571496052 2182115009 192 d0 /
-      data xgk ( 19) / 0.4178853821 9303774885 1814394594 572 d0 /
-      data xgk ( 20) / 0.3611723058 0938783773 5821730127 641 d0 /
-      data xgk ( 21) / 0.3030895389 3110783016 7478909980 339 d0 /
-      data xgk ( 22) / 0.2438668837 2098843204 5190362797 452 d0 /
-      data xgk ( 23) / 0.1837189394 2104889201 5969888759 528 d0 /
-      data xgk ( 24) / 0.1228646926 1071039638 7359818808 037 d0 /
-      data xgk ( 25) / 0.0615444830 0568507888 6546392366 797 d0 /
-      data xgk ( 26) / 0.0000000000 0000000000 0000000000 000 d0 /
-c
-      data wgk (  1) / 0.0019873838 9233031592 6507851882 843 d0 /
-      data wgk (  2) / 0.0055619321 3535671375 8040236901 066 d0 /
-      data wgk (  3) / 0.0094739733 8617415160 7207710523 655 d0 /
-      data wgk (  4) / 0.0132362291 9557167481 3656405846 976 d0 /
-      data wgk (  5) / 0.0168478177 0912829823 1516667536 336 d0 /
-      data wgk (  6) / 0.0204353711 4588283545 6568292235 939 d0 /
-      data wgk (  7) / 0.0240099456 0695321622 0092489164 881 d0 /
-      data wgk (  8) / 0.0274753175 8785173780 2948455517 811 d0 /
-      data wgk (  9) / 0.0307923001 6738748889 1109020215 229 d0 /
-      data wgk ( 10) / 0.0340021302 7432933783 6748795229 551 d0 /
-      data wgk ( 11) / 0.0371162714 8341554356 0330625367 620 d0 /
-      data wgk ( 12) / 0.0400838255 0403238207 4839284467 076 d0 /
-      data wgk ( 13) / 0.0428728450 2017004947 6895792439 495 d0 /
-      data wgk ( 14) / 0.0455029130 4992178890 9870584752 660 d0 /
-      data wgk ( 15) / 0.0479825371 3883671390 6392255756 915 d0 /
-      data wgk ( 16) / 0.0502776790 8071567196 3325259433 440 d0 /
-      data wgk ( 17) / 0.0523628858 0640747586 4366712137 873 d0 /
-      data wgk ( 18) / 0.0542511298 8854549014 4543370459 876 d0 /
-      data wgk ( 19) / 0.0559508112 2041231730 8240686382 747 d0 /
-      data wgk ( 20) / 0.0574371163 6156783285 3582693939 506 d0 /
-      data wgk ( 21) / 0.0586896800 2239420796 1974175856 788 d0 /
-      data wgk ( 22) / 0.0597203403 2417405997 9099291932 562 d0 /
-      data wgk ( 23) / 0.0605394553 7604586294 5360267517 565 d0 /
-      data wgk ( 24) / 0.0611285097 1705304830 5859030416 293 d0 /
-      data wgk ( 25) / 0.0614711898 7142531666 1544131965 264 d0 /
-c       note: wgk (26) was calculated from the values of wgk(1..25)
-      data wgk ( 26) / 0.0615808180 6783293507 8759824240 066 d0 /
-c
-c
-c           list of major variables
-c           -----------------------
-c
-c           centr  - mid point of the interval
-c           hlgth  - half-length of the interval
-c           absc   - abscissa
-c           fval*  - function value
-c           resg   - result of the 25-point gauss formula
-c           resk   - result of the 51-point kronrod formula
-c           reskh  - approximation to the mean value of f over (a,b),
-c                    i.e. to i/(b-a)
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-c***first executable statement  dqk51
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-      centr = 0.5d+00*(a+b)
-      hlgth = 0.5d+00*(b-a)
-      dhlgth = dabs(hlgth)
-c
-c           compute the 51-point kronrod approximation to
-c           the integral, and estimate the absolute error.
-c
-      fc = f(centr)
-      resg = wg(13)*fc
-      resk = wgk(26)*fc
-      resabs = dabs(resk)
-      do 10 j=1,12
-        jtw = j*2
-        absc = hlgth*xgk(jtw)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtw) = fval1
-        fv2(jtw) = fval2
-        fsum = fval1+fval2
-        resg = resg+wg(j)*fsum
-        resk = resk+wgk(jtw)*fsum
-        resabs = resabs+wgk(jtw)*(dabs(fval1)+dabs(fval2))
-   10 continue
-      do 15 j = 1,13
-        jtwm1 = j*2-1
-        absc = hlgth*xgk(jtwm1)
-        fval1 = f(centr-absc)
-        fval2 = f(centr+absc)
-        fv1(jtwm1) = fval1
-        fv2(jtwm1) = fval2
-        fsum = fval1+fval2
-        resk = resk+wgk(jtwm1)*fsum
-        resabs = resabs+wgk(jtwm1)*(dabs(fval1)+dabs(fval2))
-   15 continue
-      reskh = resk*0.5d+00
-      resasc = wgk(26)*dabs(fc-reskh)
-      do 20 j=1,25
-        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
-   20 continue
-      result = resk*hlgth
-      resabs = resabs*dhlgth
-      resasc = resasc*dhlgth
-      abserr = dabs((resk-resg)*hlgth)
-      if(resasc.ne.0.0d+00.and.abserr.ne.0.0d+00)
-     *  abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
-      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
-     *  ((epmach*0.5d+02)*resabs,abserr)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqk61.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqk61.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,231 +0,0 @@
-      recursive subroutine dqk61(f,a,b,result,abserr,resabs,resasc)
-c***begin prologue  dqk61
-c***date written   800101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a1a2
-c***keywords  61-point gauss-kronrod rules
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  to compute i = integral of f over (a,b) with error
-c                           estimate
-c                       j = integral of dabs(f) over (a,b)
-c***description
-c
-c        integration rule
-c        standard fortran subroutine
-c        double precision version
-c
-c
-c        parameters
-c         on entry
-c           f      - double precision
-c                    function subprogram defining the integrand
-c                    function f(x). the actual name for f needs to be
-c                    declared e x t e r n a l in the calling program.
-c
-c           a      - double precision
-c                    lower limit of integration
-c
-c           b      - double precision
-c                    upper limit of integration
-c
-c         on return
-c           result - double precision
-c                    approximation to the integral i
-c                    result is computed by applying the 61-point
-c                    kronrod rule (resk) obtained by optimal addition of
-c                    abscissae to the 30-point gauss rule (resg).
-c
-c           abserr - double precision
-c                    estimate of the modulus of the absolute error,
-c                    which should equal or exceed dabs(i-result)
-c
-c           resabs - double precision
-c                    approximation to the integral j
-c
-c           resasc - double precision
-c                    approximation to the integral of dabs(f-i/(b-a))
-c
-c
-c***references  (none)
-c***routines called  d1mach
-c***end prologue  dqk61
-c
-      double precision a,dabsc,abserr,b,centr,dabs,dhlgth,dmax1,dmin1,
-     *  d1mach,epmach,f,fc,fsum,fval1,fval2,fv1,fv2,hlgth,resabs,resasc,
-     *  resg,resk,reskh,result,uflow,wg,wgk,xgk
-      integer j,jtw,jtwm1
-      external f
-c
-      dimension fv1(30),fv2(30),xgk(31),wgk(31),wg(15)
-c
-c           the abscissae and weights are given for the
-c           interval (-1,1). because of symmetry only the positive
-c           abscissae and their corresponding weights are given.
-c
-c           xgk   - abscissae of the 61-point kronrod rule
-c                   xgk(2), xgk(4)  ... abscissae of the 30-point
-c                   gauss rule
-c                   xgk(1), xgk(3)  ... optimally added abscissae
-c                   to the 30-point gauss rule
-c
-c           wgk   - weights of the 61-point kronrod rule
-c
-c           wg    - weigths of the 30-point gauss rule
-c
-c
-c gauss quadrature weights and kronron quadrature abscissae and weights
-c as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
-c bell labs, nov. 1981.
-c
-      data wg  (  1) / 0.0079681924 9616660561 5465883474 674 d0 /
-      data wg  (  2) / 0.0184664683 1109095914 2302131912 047 d0 /
-      data wg  (  3) / 0.0287847078 8332336934 9719179611 292 d0 /
-      data wg  (  4) / 0.0387991925 6962704959 6801936446 348 d0 /
-      data wg  (  5) / 0.0484026728 3059405290 2938140422 808 d0 /
-      data wg  (  6) / 0.0574931562 1761906648 1721689402 056 d0 /
-      data wg  (  7) / 0.0659742298 8218049512 8128515115 962 d0 /
-      data wg  (  8) / 0.0737559747 3770520626 8243850022 191 d0 /
-      data wg  (  9) / 0.0807558952 2942021535 4694938460 530 d0 /
-      data wg  ( 10) / 0.0868997872 0108297980 2387530715 126 d0 /
-      data wg  ( 11) / 0.0921225222 3778612871 7632707087 619 d0 /
-      data wg  ( 12) / 0.0963687371 7464425963 9468626351 810 d0 /
-      data wg  ( 13) / 0.0995934205 8679526706 2780282103 569 d0 /
-      data wg  ( 14) / 0.1017623897 4840550459 6428952168 554 d0 /
-      data wg  ( 15) / 0.1028526528 9355884034 1285636705 415 d0 /
-c
-      data xgk (  1) / 0.9994844100 5049063757 1325895705 811 d0 /
-      data xgk (  2) / 0.9968934840 7464954027 1630050918 695 d0 /
-      data xgk (  3) / 0.9916309968 7040459485 8628366109 486 d0 /
-      data xgk (  4) / 0.9836681232 7974720997 0032581605 663 d0 /
-      data xgk (  5) / 0.9731163225 0112626837 4693868423 707 d0 /
-      data xgk (  6) / 0.9600218649 6830751221 6871025581 798 d0 /
-      data xgk (  7) / 0.9443744447 4855997941 5831324037 439 d0 /
-      data xgk (  8) / 0.9262000474 2927432587 9324277080 474 d0 /
-      data xgk (  9) / 0.9055733076 9990779854 6522558925 958 d0 /
-      data xgk ( 10) / 0.8825605357 9205268154 3116462530 226 d0 /
-      data xgk ( 11) / 0.8572052335 4606109895 8658510658 944 d0 /
-      data xgk ( 12) / 0.8295657623 8276839744 2898119732 502 d0 /
-      data xgk ( 13) / 0.7997278358 2183908301 3668942322 683 d0 /
-      data xgk ( 14) / 0.7677774321 0482619491 7977340974 503 d0 /
-      data xgk ( 15) / 0.7337900624 5322680472 6171131369 528 d0 /
-      data xgk ( 16) / 0.6978504947 9331579693 2292388026 640 d0 /
-      data xgk ( 17) / 0.6600610641 2662696137 0053668149 271 d0 /
-      data xgk ( 18) / 0.6205261829 8924286114 0477556431 189 d0 /
-      data xgk ( 19) / 0.5793452358 2636169175 6024932172 540 d0 /
-      data xgk ( 20) / 0.5366241481 4201989926 4169793311 073 d0 /
-      data xgk ( 21) / 0.4924804678 6177857499 3693061207 709 d0 /
-      data xgk ( 22) / 0.4470337695 3808917678 0609900322 854 d0 /
-      data xgk ( 23) / 0.4004012548 3039439253 5476211542 661 d0 /
-      data xgk ( 24) / 0.3527047255 3087811347 1037207089 374 d0 /
-      data xgk ( 25) / 0.3040732022 7362507737 2677107199 257 d0 /
-      data xgk ( 26) / 0.2546369261 6788984643 9805129817 805 d0 /
-      data xgk ( 27) / 0.2045251166 8230989143 8957671002 025 d0 /
-      data xgk ( 28) / 0.1538699136 0858354696 3794672743 256 d0 /
-      data xgk ( 29) / 0.1028069379 6673703014 7096751318 001 d0 /
-      data xgk ( 30) / 0.0514718425 5531769583 3025213166 723 d0 /
-      data xgk ( 31) / 0.0000000000 0000000000 0000000000 000 d0 /
-c
-      data wgk (  1) / 0.0013890136 9867700762 4551591226 760 d0 /
-      data wgk (  2) / 0.0038904611 2709988405 1267201844 516 d0 /
-      data wgk (  3) / 0.0066307039 1593129217 3319826369 750 d0 /
-      data wgk (  4) / 0.0092732796 5951776342 8441146892 024 d0 /
-      data wgk (  5) / 0.0118230152 5349634174 2232898853 251 d0 /
-      data wgk (  6) / 0.0143697295 0704580481 2451432443 580 d0 /
-      data wgk (  7) / 0.0169208891 8905327262 7572289420 322 d0 /
-      data wgk (  8) / 0.0194141411 9394238117 3408951050 128 d0 /
-      data wgk (  9) / 0.0218280358 2160919229 7167485738 339 d0 /
-      data wgk ( 10) / 0.0241911620 7808060136 5686370725 232 d0 /
-      data wgk ( 11) / 0.0265099548 8233310161 0601709335 075 d0 /
-      data wgk ( 12) / 0.0287540487 6504129284 3978785354 334 d0 /
-      data wgk ( 13) / 0.0309072575 6238776247 2884252943 092 d0 /
-      data wgk ( 14) / 0.0329814470 5748372603 1814191016 854 d0 /
-      data wgk ( 15) / 0.0349793380 2806002413 7499670731 468 d0 /
-      data wgk ( 16) / 0.0368823646 5182122922 3911065617 136 d0 /
-      data wgk ( 17) / 0.0386789456 2472759295 0348651532 281 d0 /
-      data wgk ( 18) / 0.0403745389 5153595911 1995279752 468 d0 /
-      data wgk ( 19) / 0.0419698102 1516424614 7147541285 970 d0 /
-      data wgk ( 20) / 0.0434525397 0135606931 6831728117 073 d0 /
-      data wgk ( 21) / 0.0448148001 3316266319 2355551616 723 d0 /
-      data wgk ( 22) / 0.0460592382 7100698811 6271735559 374 d0 /
-      data wgk ( 23) / 0.0471855465 6929915394 5261478181 099 d0 /
-      data wgk ( 24) / 0.0481858617 5708712914 0779492298 305 d0 /
-      data wgk ( 25) / 0.0490554345 5502977888 7528165367 238 d0 /
-      data wgk ( 26) / 0.0497956834 2707420635 7811569379 942 d0 /
-      data wgk ( 27) / 0.0504059214 0278234684 0893085653 585 d0 /
-      data wgk ( 28) / 0.0508817958 9874960649 2297473049 805 d0 /
-      data wgk ( 29) / 0.0512215478 4925877217 0656282604 944 d0 /
-      data wgk ( 30) / 0.0514261285 3745902593 3862879215 781 d0 /
-      data wgk ( 31) / 0.0514947294 2945156755 8340433647 099 d0 /
-c
-c           list of major variables
-c           -----------------------
-c
-c           centr  - mid point of the interval
-c           hlgth  - half-length of the interval
-c           dabsc  - abscissa
-c           fval*  - function value
-c           resg   - result of the 30-point gauss rule
-c           resk   - result of the 61-point kronrod rule
-c           reskh  - approximation to the mean value of f
-c                    over (a,b), i.e. to i/(b-a)
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-      centr = 0.5d+00*(b+a)
-      hlgth = 0.5d+00*(b-a)
-      dhlgth = dabs(hlgth)
-c
-c           compute the 61-point kronrod approximation to the
-c           integral, and estimate the absolute error.
-c
-c***first executable statement  dqk61
-      resg = 0.0d+00
-      fc = f(centr)
-      resk = wgk(31)*fc
-      resabs = dabs(resk)
-      do 10 j=1,15
-        jtw = j*2
-        dabsc = hlgth*xgk(jtw)
-        fval1 = f(centr-dabsc)
-        fval2 = f(centr+dabsc)
-        fv1(jtw) = fval1
-        fv2(jtw) = fval2
-        fsum = fval1+fval2
-        resg = resg+wg(j)*fsum
-        resk = resk+wgk(jtw)*fsum
-        resabs = resabs+wgk(jtw)*(dabs(fval1)+dabs(fval2))
-   10 continue
-      do 15 j=1,15
-        jtwm1 = j*2-1
-        dabsc = hlgth*xgk(jtwm1)
-        fval1 = f(centr-dabsc)
-        fval2 = f(centr+dabsc)
-        fv1(jtwm1) = fval1
-        fv2(jtwm1) = fval2
-        fsum = fval1+fval2
-        resk = resk+wgk(jtwm1)*fsum
-        resabs = resabs+wgk(jtwm1)*(dabs(fval1)+dabs(fval2))
-  15    continue
-      reskh = resk*0.5d+00
-      resasc = wgk(31)*dabs(fc-reskh)
-      do 20 j=1,30
-        resasc = resasc+wgk(j)*(dabs(fv1(j)-reskh)+dabs(fv2(j)-reskh))
-   20 continue
-      result = resk*hlgth
-      resabs = resabs*dhlgth
-      resasc = resasc*dhlgth
-      abserr = dabs((resk-resg)*hlgth)
-      if(resasc.ne.0.0d+00.and.abserr.ne.0.0d+00)
-     *  abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
-      if(resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
-     *  ((epmach*0.5d+02)*resabs,abserr)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqmomo.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqmomo.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,127 +0,0 @@
-      recursive subroutine dqmomo(alfa,beta,ri,rj,rg,rh,integr)
-c***begin prologue  dqmomo
-c***date written   820101   (yymmdd)
-c***revision date  830518   (yymmdd)
-c***category no.  h2a2a1,c3a2
-c***keywords  modified chebyshev moments
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  this routine computes modified chebsyshev moments. the k-th
-c            modified chebyshev moment is defined as the integral over
-c            (-1,1) of w(x)*t(k,x), where t(k,x) is the chebyshev
-c            polynomial of degree k.
-c***description
-c
-c        modified chebyshev moments
-c        standard fortran subroutine
-c        double precision version
-c
-c        parameters
-c           alfa   - double precision
-c                    parameter in the weight function w(x), alfa.gt.(-1)
-c
-c           beta   - double precision
-c                    parameter in the weight function w(x), beta.gt.(-1)
-c
-c           ri     - double precision
-c                    vector of dimension 25
-c                    ri(k) is the integral over (-1,1) of
-c                    (1+x)**alfa*t(k-1,x), k = 1, ..., 25.
-c
-c           rj     - double precision
-c                    vector of dimension 25
-c                    rj(k) is the integral over (-1,1) of
-c                    (1-x)**beta*t(k-1,x), k = 1, ..., 25.
-c
-c           rg     - double precision
-c                    vector of dimension 25
-c                    rg(k) is the integral over (-1,1) of
-c                    (1+x)**alfa*log((1+x)/2)*t(k-1,x), k = 1, ..., 25.
-c
-c           rh     - double precision
-c                    vector of dimension 25
-c                    rh(k) is the integral over (-1,1) of
-c                    (1-x)**beta*log((1-x)/2)*t(k-1,x), k = 1, ..., 25.
-c
-c           integr - integer
-c                    input parameter indicating the modified
-c                    moments to be computed
-c                    integr = 1 compute ri, rj
-c                           = 2 compute ri, rj, rg
-c                           = 3 compute ri, rj, rh
-c                           = 4 compute ri, rj, rg, rh
-c
-c***references  (none)
-c***routines called  (none)
-c***end prologue  dqmomo
-c
-      double precision alfa,alfp1,alfp2,an,anm1,beta,betp1,betp2,ralf,
-     *  rbet,rg,rh,ri,rj
-      integer i,im1,integr
-c
-      dimension rg(25),rh(25),ri(25),rj(25)
-c
-c
-c***first executable statement  dqmomo
-      alfp1 = alfa+0.1d+01
-      betp1 = beta+0.1d+01
-      alfp2 = alfa+0.2d+01
-      betp2 = beta+0.2d+01
-      ralf = 0.2d+01**alfp1
-      rbet = 0.2d+01**betp1
-c
-c           compute ri, rj using a forward recurrence relation.
-c
-      ri(1) = ralf/alfp1
-      rj(1) = rbet/betp1
-      ri(2) = ri(1)*alfa/alfp2
-      rj(2) = rj(1)*beta/betp2
-      an = 0.2d+01
-      anm1 = 0.1d+01
-      do 20 i=3,25
-        ri(i) = -(ralf+an*(an-alfp2)*ri(i-1))/(anm1*(an+alfp1))
-        rj(i) = -(rbet+an*(an-betp2)*rj(i-1))/(anm1*(an+betp1))
-        anm1 = an
-        an = an+0.1d+01
-   20 continue
-      if(integr.eq.1) go to 70
-      if(integr.eq.3) go to 40
-c
-c           compute rg using a forward recurrence relation.
-c
-      rg(1) = -ri(1)/alfp1
-      rg(2) = -(ralf+ralf)/(alfp2*alfp2)-rg(1)
-      an = 0.2d+01
-      anm1 = 0.1d+01
-      im1 = 2
-      do 30 i=3,25
-        rg(i) = -(an*(an-alfp2)*rg(im1)-an*ri(im1)+anm1*ri(i))/
-     *  (anm1*(an+alfp1))
-        anm1 = an
-        an = an+0.1d+01
-        im1 = i
-   30 continue
-      if(integr.eq.2) go to 70
-c
-c           compute rh using a forward recurrence relation.
-c
-   40 rh(1) = -rj(1)/betp1
-      rh(2) = -(rbet+rbet)/(betp2*betp2)-rh(1)
-      an = 0.2d+01
-      anm1 = 0.1d+01
-      im1 = 2
-      do 50 i=3,25
-        rh(i) = -(an*(an-betp2)*rh(im1)-an*rj(im1)+
-     *  anm1*rj(i))/(anm1*(an+betp1))
-        anm1 = an
-        an = an+0.1d+01
-        im1 = i
-   50 continue
-      do 60 i=2,25,2
-        rh(i) = -rh(i)
-   60 continue
-   70 do 80 i=2,25,2
-        rj(i) = -rj(i)
-   80 continue
-   90 return
-      end
Index: scipy/scipy/integrate/quadpack/dqng.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqng.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,375 +0,0 @@
-      recursive subroutine dqng(f,a,b,epsabs,epsrel,result,abserr,
-     *   neval,ier)
-c***begin prologue  dqng
-c***date written   800101   (yymmdd)
-c***revision date  810101   (yymmdd)
-c***category no.  h2a1a1
-c***keywords  automatic integrator, smooth integrand,
-c             non-adaptive, gauss-kronrod(patterson)
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl math & progr. div. - k.u.leuven
-c           kahaner,david,nbs - modified (2/82)
-c***purpose  the routine calculates an approximation result to a
-c            given definite integral i = integral of f over (a,b),
-c            hopefully satisfying following claim for accuracy
-c            abs(i-result).le.max(epsabs,epsrel*abs(i)).
-c***description
-c
-c non-adaptive integration
-c standard fortran subroutine
-c double precision version
-c
-c           f      - double precision
-c                    function subprogram defining the integrand function
-c                    f(x). the actual name for f needs to be declared
-c                    e x t e r n a l in the driver program.
-c
-c           a      - double precision
-c                    lower limit of integration
-c
-c           b      - double precision
-c                    upper limit of integration
-c
-c           epsabs - double precision
-c                    absolute accuracy requested
-c           epsrel - double precision
-c                    relative accuracy requested
-c                    if  epsabs.le.0
-c                    and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
-c                    the routine will end with ier = 6.
-c
-c         on return
-c           result - double precision
-c                    approximation to the integral i
-c                    result is obtained by applying the 21-point
-c                    gauss-kronrod rule (res21) obtained by optimal
-c                    addition of abscissae to the 10-point gauss rule
-c                    (res10), or by applying the 43-point rule (res43)
-c                    obtained by optimal addition of abscissae to the
-c                    21-point gauss-kronrod rule, or by applying the
-c                    87-point rule (res87) obtained by optimal addition
-c                    of abscissae to the 43-point rule.
-c
-c           abserr - double precision
-c                    estimate of the modulus of the absolute error,
-c                    which should equal or exceed abs(i-result)
-c
-c           neval  - integer
-c                    number of integrand evaluations
-c
-c           ier    - ier = 0 normal and reliable termination of the
-c                            routine. it is assumed that the requested
-c                            accuracy has been achieved.
-c                    ier.gt.0 abnormal termination of the routine. it is
-c                            assumed that the requested accuracy has
-c                            not been achieved.
-c           error messages
-c                    ier = 1 the maximum number of steps has been
-c                            executed. the integral is probably too
-c                            difficult to be calculated by dqng.
-c                        = 6 the input is invalid, because
-c                            epsabs.le.0 and
-c                            epsrel.lt.max(50*rel.mach.acc.,0.5d-28).
-c                            result, abserr and neval are set to zero.
-c
-c***references  (none)
-c***routines called  d1mach,xerror
-c***end prologue  dqng
-c
-      double precision a,absc,abserr,b,centr,dabs,dhlgth,dmax1,dmin1,
-     *  d1mach,epmach,epsabs,epsrel,f,fcentr,fval,fval1,fval2,fv1,fv2,
-     *  fv3,fv4,hlgth,result,res10,res21,res43,res87,resabs,resasc,
-     *  reskh,savfun,uflow,w10,w21a,w21b,w43a,w43b,w87a,w87b,x1,x2,x3,x4
-      integer ier,ipx,k,l,neval
-      external f
-c
-      dimension fv1(5),fv2(5),fv3(5),fv4(5),x1(5),x2(5),x3(11),x4(22),
-     *  w10(5),w21a(5),w21b(6),w43a(10),w43b(12),w87a(21),w87b(23),
-     *  savfun(21)
-c
-c           the following data statements contain the
-c           abscissae and weights of the integration rules used.
-c
-c           x1      abscissae common to the 10-, 21-, 43- and 87-
-c                   point rule
-c           x2      abscissae common to the 21-, 43- and 87-point rule
-c           x3      abscissae common to the 43- and 87-point rule
-c           x4      abscissae of the 87-point rule
-c           w10     weights of the 10-point formula
-c           w21a    weights of the 21-point formula for abscissae x1
-c           w21b    weights of the 21-point formula for abscissae x2
-c           w43a    weights of the 43-point formula for abscissae x1, x3
-c           w43b    weights of the 43-point formula for abscissae x3
-c           w87a    weights of the 87-point formula for abscissae x1,
-c                   x2, x3
-c           w87b    weights of the 87-point formula for abscissae x4
-c
-c
-c gauss-kronrod-patterson quadrature coefficients for use in
-c quadpack routine qng.  these coefficients were calculated with
-c 101 decimal digit arithmetic by l. w. fullerton, bell labs, nov 1981.
-c
-      data x1    (  1) / 0.9739065285 1717172007 7964012084 452 d0 /
-      data x1    (  2) / 0.8650633666 8898451073 2096688423 493 d0 /
-      data x1    (  3) / 0.6794095682 9902440623 4327365114 874 d0 /
-      data x1    (  4) / 0.4333953941 2924719079 9265943165 784 d0 /
-      data x1    (  5) / 0.1488743389 8163121088 4826001129 720 d0 /
-      data w10   (  1) / 0.0666713443 0868813759 3568809893 332 d0 /
-      data w10   (  2) / 0.1494513491 5058059314 5776339657 697 d0 /
-      data w10   (  3) / 0.2190863625 1598204399 5534934228 163 d0 /
-      data w10   (  4) / 0.2692667193 0999635509 1226921569 469 d0 /
-      data w10   (  5) / 0.2955242247 1475287017 3892994651 338 d0 /
-c
-      data x2    (  1) / 0.9956571630 2580808073 5527280689 003 d0 /
-      data x2    (  2) / 0.9301574913 5570822600 1207180059 508 d0 /
-      data x2    (  3) / 0.7808177265 8641689706 3717578345 042 d0 /
-      data x2    (  4) / 0.5627571346 6860468333 9000099272 694 d0 /
-      data x2    (  5) / 0.2943928627 0146019813 1126603103 866 d0 /
-      data w21a  (  1) / 0.0325581623 0796472747 8818972459 390 d0 /
-      data w21a  (  2) / 0.0750396748 1091995276 7043140916 190 d0 /
-      data w21a  (  3) / 0.1093871588 0229764189 9210590325 805 d0 /
-      data w21a  (  4) / 0.1347092173 1147332592 8054001771 707 d0 /
-      data w21a  (  5) / 0.1477391049 0133849137 4841515972 068 d0 /
-      data w21b  (  1) / 0.0116946388 6737187427 8064396062 192 d0 /
-      data w21b  (  2) / 0.0547558965 7435199603 1381300244 580 d0 /
-      data w21b  (  3) / 0.0931254545 8369760553 5065465083 366 d0 /
-      data w21b  (  4) / 0.1234919762 6206585107 7958109831 074 d0 /
-      data w21b  (  5) / 0.1427759385 7706008079 7094273138 717 d0 /
-      data w21b  (  6) / 0.1494455540 0291690566 4936468389 821 d0 /
-c
-      data x3    (  1) / 0.9993333609 0193208139 4099323919 911 d0 /
-      data x3    (  2) / 0.9874334029 0808886979 5961478381 209 d0 /
-      data x3    (  3) / 0.9548079348 1426629925 7919200290 473 d0 /
-      data x3    (  4) / 0.9001486957 4832829362 5099494069 092 d0 /
-      data x3    (  5) / 0.8251983149 8311415084 7066732588 520 d0 /
-      data x3    (  6) / 0.7321483889 8930498261 2354848755 461 d0 /
-      data x3    (  7) / 0.6228479705 3772523864 1159120344 323 d0 /
-      data x3    (  8) / 0.4994795740 7105649995 2214885499 755 d0 /
-      data x3    (  9) / 0.3649016613 4658076804 3989548502 644 d0 /
-      data x3    ( 10) / 0.2222549197 7660129649 8260928066 212 d0 /
-      data x3    ( 11) / 0.0746506174 6138332204 3914435796 506 d0 /
-      data w43a  (  1) / 0.0162967342 8966656492 4281974617 663 d0 /
-      data w43a  (  2) / 0.0375228761 2086950146 1613795898 115 d0 /
-      data w43a  (  3) / 0.0546949020 5825544214 7212685465 005 d0 /
-      data w43a  (  4) / 0.0673554146 0947808607 5553166302 174 d0 /
-      data w43a  (  5) / 0.0738701996 3239395343 2140695251 367 d0 /
-      data w43a  (  6) / 0.0057685560 5976979618 4184327908 655 d0 /
-      data w43a  (  7) / 0.0273718905 9324884208 1276069289 151 d0 /
-      data w43a  (  8) / 0.0465608269 1042883074 3339154433 824 d0 /
-      data w43a  (  9) / 0.0617449952 0144256449 6240336030 883 d0 /
-      data w43a  ( 10) / 0.0713872672 6869339776 8559114425 516 d0 /
-      data w43b  (  1) / 0.0018444776 4021241410 0389106552 965 d0 /
-      data w43b  (  2) / 0.0107986895 8589165174 0465406741 293 d0 /
-      data w43b  (  3) / 0.0218953638 6779542810 2523123075 149 d0 /
-      data w43b  (  4) / 0.0325974639 7534568944 3882222526 137 d0 /
-      data w43b  (  5) / 0.0421631379 3519181184 7627924327 955 d0 /
-      data w43b  (  6) / 0.0507419396 0018457778 0189020092 084 d0 /
-      data w43b  (  7) / 0.0583793955 4261924837 5475369330 206 d0 /
-      data w43b  (  8) / 0.0647464049 5144588554 4689259517 511 d0 /
-      data w43b  (  9) / 0.0695661979 1235648452 8633315038 405 d0 /
-      data w43b  ( 10) / 0.0728244414 7183320815 0939535192 842 d0 /
-      data w43b  ( 11) / 0.0745077510 1417511827 3571813842 889 d0 /
-      data w43b  ( 12) / 0.0747221475 1740300559 4425168280 423 d0 /
-c
-      data x4    (  1) / 0.9999029772 6272923449 0529830591 582 d0 /
-      data x4    (  2) / 0.9979898959 8667874542 7496322365 960 d0 /
-      data x4    (  3) / 0.9921754978 6068722280 8523352251 425 d0 /
-      data x4    (  4) / 0.9813581635 7271277357 1916941623 894 d0 /
-      data x4    (  5) / 0.9650576238 5838461912 8284110607 926 d0 /
-      data x4    (  6) / 0.9431676131 3367059681 6416634507 426 d0 /
-      data x4    (  7) / 0.9158064146 8550720959 1826430720 050 d0 /
-      data x4    (  8) / 0.8832216577 7131650137 2117548744 163 d0 /
-      data x4    (  9) / 0.8457107484 6241566660 5902011504 855 d0 /
-      data x4    ( 10) / 0.8035576580 3523098278 8739474980 964 d0 /
-      data x4    ( 11) / 0.7570057306 8549555832 8942793432 020 d0 /
-      data x4    ( 12) / 0.7062732097 8732181982 4094274740 840 d0 /
-      data x4    ( 13) / 0.6515894665 0117792253 4422205016 736 d0 /
-      data x4    ( 14) / 0.5932233740 5796108887 5273770349 144 d0 /
-      data x4    ( 15) / 0.5314936059 7083193228 5268948562 671 d0 /
-      data x4    ( 16) / 0.4667636230 4202284487 1966781659 270 d0 /
-      data x4    ( 17) / 0.3994248478 5921880473 2101665817 923 d0 /
-      data x4    ( 18) / 0.3298748771 0618828826 5053371824 597 d0 /
-      data x4    ( 19) / 0.2585035592 0216155180 2280975429 025 d0 /
-      data x4    ( 20) / 0.1856953965 6834665201 5917141167 606 d0 /
-      data x4    ( 21) / 0.1118422131 7990746817 2398359241 362 d0 /
-      data x4    ( 22) / 0.0373521233 9461987081 4998165437 704 d0 /
-      data w87a  (  1) / 0.0081483773 8414917290 0002878448 190 d0 /
-      data w87a  (  2) / 0.0187614382 0156282224 3935059003 794 d0 /
-      data w87a  (  3) / 0.0273474510 5005228616 1582829741 283 d0 /
-      data w87a  (  4) / 0.0336777073 1163793004 6581056957 588 d0 /
-      data w87a  (  5) / 0.0369350998 2042790761 4589586742 499 d0 /
-      data w87a  (  6) / 0.0028848724 3021153050 1334156248 695 d0 /
-      data w87a  (  7) / 0.0136859460 2271270188 8950035273 128 d0 /
-      data w87a  (  8) / 0.0232804135 0288831112 3409291030 404 d0 /
-      data w87a  (  9) / 0.0308724976 1171335867 5466394126 442 d0 /
-      data w87a  ( 10) / 0.0356936336 3941877071 9351355457 044 d0 /
-      data w87a  ( 11) / 0.0009152833 4520224136 0843392549 948 d0 /
-      data w87a  ( 12) / 0.0053992802 1930047136 7738743391 053 d0 /
-      data w87a  ( 13) / 0.0109476796 0111893113 4327826856 808 d0 /
-      data w87a  ( 14) / 0.0162987316 9678733526 2665703223 280 d0 /
-      data w87a  ( 15) / 0.0210815688 8920383511 2433060188 190 d0 /
-      data w87a  ( 16) / 0.0253709697 6925382724 3467999831 710 d0 /
-      data w87a  ( 17) / 0.0291896977 5647575250 1446154084 920 d0 /
-      data w87a  ( 18) / 0.0323732024 6720278968 5788194889 595 d0 /
-      data w87a  ( 19) / 0.0347830989 5036514275 0781997949 596 d0 /
-      data w87a  ( 20) / 0.0364122207 3135178756 2801163687 577 d0 /
-      data w87a  ( 21) / 0.0372538755 0304770853 9592001191 226 d0 /
-      data w87b  (  1) / 0.0002741455 6376207235 0016527092 881 d0 /
-      data w87b  (  2) / 0.0018071241 5505794294 8341311753 254 d0 /
-      data w87b  (  3) / 0.0040968692 8275916486 4458070683 480 d0 /
-      data w87b  (  4) / 0.0067582900 5184737869 9816577897 424 d0 /
-      data w87b  (  5) / 0.0095499576 7220164653 6053581325 377 d0 /
-      data w87b  (  6) / 0.0123294476 5224485369 4626639963 780 d0 /
-      data w87b  (  7) / 0.0150104473 4638895237 6697286041 943 d0 /
-      data w87b  (  8) / 0.0175489679 8624319109 9665352925 900 d0 /
-      data w87b  (  9) / 0.0199380377 8644088820 2278192730 714 d0 /
-      data w87b  ( 10) / 0.0221949359 6101228679 6332102959 499 d0 /
-      data w87b  ( 11) / 0.0243391471 2600080547 0360647041 454 d0 /
-      data w87b  ( 12) / 0.0263745054 1483920724 1503786552 615 d0 /
-      data w87b  ( 13) / 0.0282869107 8877120065 9968002987 960 d0 /
-      data w87b  ( 14) / 0.0300525811 2809269532 2521110347 341 d0 /
-      data w87b  ( 15) / 0.0316467513 7143992940 4586051078 883 d0 /
-      data w87b  ( 16) / 0.0330504134 1997850329 0785944862 689 d0 /
-      data w87b  ( 17) / 0.0342550997 0422606178 7082821046 821 d0 /
-      data w87b  ( 18) / 0.0352624126 6015668103 3782717998 428 d0 /
-      data w87b  ( 19) / 0.0360769896 2288870118 5500318003 895 d0 /
-      data w87b  ( 20) / 0.0366986044 9845609449 8018047441 094 d0 /
-      data w87b  ( 21) / 0.0371205492 6983257611 4119958413 599 d0 /
-      data w87b  ( 22) / 0.0373342287 5193504032 1235449094 698 d0 /
-      data w87b  ( 23) / 0.0373610737 6267902341 0321241766 599 d0 /
-c
-c           list of major variables
-c           -----------------------
-c
-c           centr  - mid point of the integration interval
-c           hlgth  - half-length of the integration interval
-c           fcentr - function value at mid point
-c           absc   - abscissa
-c           fval   - function value
-c           savfun - array of function values which have already been
-c                    computed
-c           res10  - 10-point gauss result
-c           res21  - 21-point kronrod result
-c           res43  - 43-point result
-c           res87  - 87-point result
-c           resabs - approximation to the integral of abs(f)
-c           resasc - approximation to the integral of abs(f-i/(b-a))
-c
-c           machine dependent constants
-c           ---------------------------
-c
-c           epmach is the largest relative spacing.
-c           uflow is the smallest positive magnitude.
-c
-c***first executable statement  dqng
-      epmach = d1mach(4)
-      uflow = d1mach(1)
-c
-c           test on validity of parameters
-c           ------------------------------
-c
-      result = 0.0d+00
-      abserr = 0.0d+00
-      neval = 0
-      ier = 6
-      if(epsabs.le.0.0d+00.and.epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28))
-     *  go to 80
-      hlgth = 0.5d+00*(b-a)
-      dhlgth = dabs(hlgth)
-      centr = 0.5d+00*(b+a)
-      fcentr = f(centr)
-      neval = 21
-      ier = 1
-c
-c          compute the integral using the 10- and 21-point formula.
-c
-      do 70 l = 1,3
-      go to (5,25,45),l
-    5 res10 = 0.0d+00
-      res21 = w21b(6)*fcentr
-      resabs = w21b(6)*dabs(fcentr)
-      do 10 k=1,5
-        absc = hlgth*x1(k)
-        fval1 = f(centr+absc)
-        fval2 = f(centr-absc)
-        fval = fval1+fval2
-        res10 = res10+w10(k)*fval
-        res21 = res21+w21a(k)*fval
-        resabs = resabs+w21a(k)*(dabs(fval1)+dabs(fval2))
-        savfun(k) = fval
-        fv1(k) = fval1
-        fv2(k) = fval2
-   10 continue
-      ipx = 5
-      do 15 k=1,5
-        ipx = ipx+1
-        absc = hlgth*x2(k)
-        fval1 = f(centr+absc)
-        fval2 = f(centr-absc)
-        fval = fval1+fval2
-        res21 = res21+w21b(k)*fval
-        resabs = resabs+w21b(k)*(dabs(fval1)+dabs(fval2))
-        savfun(ipx) = fval
-        fv3(k) = fval1
-        fv4(k) = fval2
-   15 continue
-c
-c          test for convergence.
-c
-      result = res21*hlgth
-      resabs = resabs*dhlgth
-      reskh = 0.5d+00*res21
-      resasc = w21b(6)*dabs(fcentr-reskh)
-      do 20 k = 1,5
-        resasc = resasc+w21a(k)*(dabs(fv1(k)-reskh)+dabs(fv2(k)-reskh))
-     *                  +w21b(k)*(dabs(fv3(k)-reskh)+dabs(fv4(k)-reskh))
-   20 continue
-      abserr = dabs((res21-res10)*hlgth)
-      resasc = resasc*dhlgth
-      go to 65
-c
-c          compute the integral using the 43-point formula.
-c
-   25 res43 = w43b(12)*fcentr
-      neval = 43
-      do 30 k=1,10
-        res43 = res43+savfun(k)*w43a(k)
-   30 continue
-      do 40 k=1,11
-        ipx = ipx+1
-        absc = hlgth*x3(k)
-        fval = f(absc+centr)+f(centr-absc)
-        res43 = res43+fval*w43b(k)
-        savfun(ipx) = fval
-   40 continue
-c
-c          test for convergence.
-c
-      result = res43*hlgth
-      abserr = dabs((res43-res21)*hlgth)
-      go to 65
-c
-c          compute the integral using the 87-point formula.
-c
-   45 res87 = w87b(23)*fcentr
-      neval = 87
-      do 50 k=1,21
-        res87 = res87+savfun(k)*w87a(k)
-   50 continue
-      do 60 k=1,22
-        absc = hlgth*x4(k)
-        res87 = res87+w87b(k)*(f(absc+centr)+f(centr-absc))
-   60 continue
-      result = res87*hlgth
-      abserr = dabs((res87-res43)*hlgth)
-   65 if(resasc.ne.0.0d+00.and.abserr.ne.0.0d+00)
-     *  abserr = resasc*dmin1(0.1d+01,(0.2d+03*abserr/resasc)**1.5d+00)
-      if (resabs.gt.uflow/(0.5d+02*epmach)) abserr = dmax1
-     *  ((epmach*0.5d+02)*resabs,abserr)
-      if (abserr.le.dmax1(epsabs,epsrel*dabs(result))) ier = 0
-c ***jump out of do-loop
-      if (ier.eq.0) go to 999
-   70 continue
-   80 call xerror('abnormal return from dqng ',26,ier,0)
-  999 return
-      end
Index: scipy/scipy/integrate/quadpack/dqpsrt.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqpsrt.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,130 +0,0 @@
-      recursive subroutine dqpsrt(limit,last,maxerr,ermax,elist,iord,
-     *   nrmax)
-c***begin prologue  dqpsrt
-c***refer to  dqage,dqagie,dqagpe,dqawse
-c***routines called  (none)
-c***revision date  810101   (yymmdd)
-c***keywords  sequential sorting
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  this routine maintains the descending ordering in the
-c            list of the local error estimated resulting from the
-c            interval subdivision process. at each call two error
-c            estimates are inserted using the sequential search
-c            method, top-down for the largest error estimate and
-c            bottom-up for the smallest error estimate.
-c***description
-c
-c           ordering routine
-c           standard fortran subroutine
-c           double precision version
-c
-c           parameters (meaning at output)
-c              limit  - integer
-c                       maximum number of error estimates the list
-c                       can contain
-c
-c              last   - integer
-c                       number of error estimates currently in the list
-c
-c              maxerr - integer
-c                       maxerr points to the nrmax-th largest error
-c                       estimate currently in the list
-c
-c              ermax  - double precision
-c                       nrmax-th largest error estimate
-c                       ermax = elist(maxerr)
-c
-c              elist  - double precision
-c                       vector of dimension last containing
-c                       the error estimates
-c
-c              iord   - integer
-c                       vector of dimension last, the first k elements
-c                       of which contain pointers to the error
-c                       estimates, such that
-c                       elist(iord(1)),...,  elist(iord(k))
-c                       form a decreasing sequence, with
-c                       k = last if last.le.(limit/2+2), and
-c                       k = limit+1-last otherwise
-c
-c              nrmax  - integer
-c                       maxerr = iord(nrmax)
-c
-c***end prologue  dqpsrt
-c
-      double precision elist,ermax,errmax,errmin
-      integer i,ibeg,ido,iord,isucc,j,jbnd,jupbn,k,last,limit,maxerr,
-     *  nrmax
-      dimension elist(last),iord(last)
-c
-c           check whether the list contains more than
-c           two error estimates.
-c
-c***first executable statement  dqpsrt
-      if(last.gt.2) go to 10
-      iord(1) = 1
-      iord(2) = 2
-      go to 90
-c
-c           this part of the routine is only executed if, due to a
-c           difficult integrand, subdivision increased the error
-c           estimate. in the normal case the insert procedure should
-c           start after the nrmax-th largest error estimate.
-c
-   10 errmax = elist(maxerr)
-      if(nrmax.eq.1) go to 30
-      ido = nrmax-1
-      do 20 i = 1,ido
-        isucc = iord(nrmax-1)
-c ***jump out of do-loop
-        if(errmax.le.elist(isucc)) go to 30
-        iord(nrmax) = isucc
-        nrmax = nrmax-1
-   20    continue
-c
-c           compute the number of elements in the list to be maintained
-c           in descending order. this number depends on the number of
-c           subdivisions still allowed.
-c
-   30 jupbn = last
-      if(last.gt.(limit/2+2)) jupbn = limit+3-last
-      errmin = elist(last)
-c
-c           insert errmax by traversing the list top-down,
-c           starting comparison from the element elist(iord(nrmax+1)).
-c
-      jbnd = jupbn-1
-      ibeg = nrmax+1
-      if(ibeg.gt.jbnd) go to 50
-      do 40 i=ibeg,jbnd
-        isucc = iord(i)
-c ***jump out of do-loop
-        if(errmax.ge.elist(isucc)) go to 60
-        iord(i-1) = isucc
-   40 continue
-   50 iord(jbnd) = maxerr
-      iord(jupbn) = last
-      go to 90
-c
-c           insert errmin by traversing the list bottom-up.
-c
-   60 iord(i-1) = maxerr
-      k = jbnd
-      do 70 j=i,jbnd
-        isucc = iord(k)
-c ***jump out of do-loop
-        if(errmin.lt.elist(isucc)) go to 80
-        iord(k+1) = isucc
-        k = k-1
-   70 continue
-      iord(i) = last
-      go to 90
-   80 iord(k+1) = last
-c
-c           set maxerr and ermax.
-c
-   90 maxerr = iord(nrmax)
-      ermax = elist(maxerr)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqwgtc.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqwgtc.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,18 +0,0 @@
-      double precision function dqwgtc(x,c,p2,p3,p4,kp)
-c***begin prologue  dqwgtc
-c***refer to dqk15w
-c***routines called  (none)
-c***revision date  810101   (yymmdd)
-c***keywords  weight function, cauchy principal value
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  this function subprogram is used together with the
-c            routine qawc and defines the weight function.
-c***end prologue  dqwgtc
-c
-      double precision c,p2,p3,p4,x
-      integer kp
-c***first executable statement  dqwgtc
-      dqwgtc = 0.1d+01/(x-c)
-      return
-      end
Index: scipy/scipy/integrate/quadpack/dqwgtf.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqwgtf.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,20 +0,0 @@
-      double precision function dqwgtf(x,omega,p2,p3,p4,integr)
-c***begin prologue  dqwgtf
-c***refer to   dqk15w
-c***routines called  (none)
-c***revision date 810101   (yymmdd)
-c***keywords  cos or sin in weight function
-c***author  piessens,robert, appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. * progr. div. - k.u.leuven
-c***end prologue  dqwgtf
-c
-      double precision dcos,dsin,omega,omx,p2,p3,p4,x
-      integer integr
-c***first executable statement  dqwgtf
-      omx = omega*x
-      go to(10,20),integr
-   10 dqwgtf = dcos(omx)
-      go to 30
-   20 dqwgtf = dsin(omx)
-   30 return
-      end
Index: scipy/scipy/integrate/quadpack/dqwgts.f
===================================================================
--- scipy.orig/scipy/integrate/quadpack/dqwgts.f	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,27 +0,0 @@
-      double precision function dqwgts(x,a,b,alfa,beta,integr)
-c***begin prologue  dqwgts
-c***refer to dqk15w
-c***routines called  (none)
-c***revision date  810101   (yymmdd)
-c***keywords  weight function, algebraico-logarithmic
-c             end-point singularities
-c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
-c           de doncker,elise,appl. math. & progr. div. - k.u.leuven
-c***purpose  this function subprogram is used together with the
-c            routine dqaws and defines the weight function.
-c***end prologue  dqwgts
-c
-      double precision a,alfa,b,beta,bmx,dlog,x,xma
-      integer integr
-c***first executable statement  dqwgts
-      xma = x-a
-      bmx = b-x
-      dqwgts = xma**alfa*bmx**beta
-      go to (40,10,20,30),integr
-   10 dqwgts = dqwgts*dlog(xma)
-      go to 40
-   20 dqwgts = dqwgts*dlog(bmx)
-      go to 40
-   30 dqwgts = dqwgts*dlog(xma)*dlog(bmx)
-   40 return
-      end
Index: scipy/scipy/integrate/quadpack/index
===================================================================
--- scipy.orig/scipy/integrate/quadpack/index	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,304 +0,0 @@
-file	quadpack/dqc25s.f
-gams	H2a2a2
-
-file	quadpack/qc25s.f
-gams	H2a2a2
-
-file	quadpack/qage.f
-gams	H2a1a1
-for	same as (quadpack/qag) but provides more information and control
-
-file	quadpack/dqage.f
-gams	H2a1a1
-for	same as (quadpack/dqag) but provides more information and control
-
-file	quadpack/qagie.f
-gams	H2a3a1,H2a4a1
-for	same as (quadpack/qagi) but provides more information and control
-
-file	quadpack/dqagie.f
-gams	H2a3a1,H2a4a1
-for	same as (quadpack/dqagi) but provides more information and control
-
-file	quadpack/qagpe.f
-gams	H2a2a1
-for	same as (quadpack/qagp) but provides more information and control
-
-file	quadpack/dqagpe.f
-gams	H2a2a1
-for	same as (quadpack/dqagp) but provides more information and control
-
-file	quadpack/qagse.f
-gams	H2a1a1
-for	same as (quadpack/qags) but provides more information and control
-
-file	quadpack/dqagse.f
-gams	H2a1a1
-for	same as (quadpack/dqags) but provides more information and control
-
-file	quadpack/qawoe.f
-gams	H2a2a1
-for	same as (quadpack/qawo) but provides more information and control
-
-file	quadpack/dqawoe.f
-gams	H2a2a1
-for	same as (quadpack/dqawo) but provides more information and control
-
-file	quadpack/qawse.f
-gams	H2a2a1
-for	same as (quadpack/qaws) but provides more information and control
-
-file	quadpack/dqawse.f
-gams	H2a2a1
-for	same as (quadpack/dqaws) but provides more information and control
-
-file	quadpack/qawce.f
-gams	H2a2a1,J4
-for	same as (quadpack/qawc) but provides more information and control
-
-file	quadpack/dqawce.f
-gams	H2a2a1,J4
-for	same as (quadpack/dqawc) but provides more information and control
-
-file	quadpack/qawfe.f
-gams	H2a3a1
-for	same as (quadpack/qawf) but provides more information and control
-
-file	quadpack/dqawfe.f
-gams	H2a3a1
-for	same as (quadpack/dqawf) but provides more information and control
-
-file	quadpack/qag.f
-gams	H2a1a1
-for	1D globally adaptive integrator using Gauss-Kronrod quadrature, oscillating integrand
-prec	single
-
-file	quadpack/dqag.f
-gams	H2a1a1
-for	1D globally adaptive integrator using Gauss-Kronrod quadrature, oscillating integrand
-prec	double
-
-file	quadpack/qagi.f
-gams	H2a3a1,H2a4a1
-for	1D globally adaptive integrator, infinite intervals
-prec	single
-
-file	quadpack/dqagi.f
-gams	H2a3a1,H2a4a1
-for	1D globally adaptive integrator, infinite intervals
-prec	double
-
-file	quadpack/qagp.f
-gams	H2a2a1
-for	1D globally adaptive integrator, singularities or discontinuities
-prec	single
-
-file	quadpack/dqagp.f
-gams	H2a2a1
-for	1D globally adaptive integrator, singularities or discontinuities
-prec	double
-
-file	quadpack/qags.f
-gams	H2a1a1
-for	1D globally adaptive integrator using interval subdivision and extrapolation
-prec	single
-
-file	quadpack/dqags.f
-gams	H2a1a1
-for	1D globally adaptive integrator using interval subdivision and extrapolation
-prec	double
-
-file	quadpack/qawo.f
-gams	H2a2a1
-for	1D integration of cos(omega*x)*f(x) or sin(omega*x)*f(x) over a finite interval, adaptive subdivision with extrapolation
-prec	single
-
-file	quadpack/dqawo.f
-gams	H2a2a1
-for	1D integration of cos(omega*x)*f(x) or sin(omega*x)*f(x) over a finite interval, adaptive subdivision with extrapolation
-prec	double
-
-file	quadpack/qaws.f
-gams	H2a2a1
-for	1D integration of functions with powers and or logs over a finite interval
-prec	single
-
-file	quadpack/dqaws.f
-gams	H2a2a1
-for	1D integration of functions with powers and or logs over a finite interval
-prec	double
-
-file	quadpack/qawc.f
-gams	H2a2a1,J4
-for	compute Cauchy principal value of f(x)/(x-c) over a finite interval
-prec	single
-
-file	quadpack/dqawc.f
-gams	H2a2a1,J4
-for	compute Cauchy principal value of f(x)/(x-c) over a finite interval
-prec	double
-
-file	quadpack/qng.f
-gams	H2a1a1
-for	1D non-adaptive automatic integrator
-prec	single
-
-file	quadpack/dqng.f
-gams	H2a1a1
-for	1D non-adaptive automatic integrator
-prec	double
-
-file	quadpack/qawf.f
-gams	H2a3a1
-for	Fourier sine/cosine transform for user supplied interval a to infinity
-prec	single
-
-file	quadpack/dqawf.f
-gams	H2a3a1
-for	Fourier sine/cosine transform for user supplied interval a to infinity
-prec	double
-
-file	quadpack/qk15.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 15 point rule and give error estimate, non-automatic
-prec	single
-
-file	quadpack/dqk15.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 15 point rule and give error estimate, non-automatic
-prec	double
-
-file	quadpack/qk21.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 21 point rule and give error estimate, non-automatic
-prec	single
-
-file	quadpack/dqk21.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 21 point rule and give error estimate, non-automatic
-prec	double
-
-file	quadpack/qk31.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 31 point rule and give error estimate, non-automatic
-prec	single
-
-file	quadpack/dqk31.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 31 point rule and give error estimate, non-automatic
-prec	double
-
-file	quadpack/qk41.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 41 point rule and give error estimate, non-automatic
-prec	single
-
-file	quadpack/dqk41.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 41 point rule and give error estimate, non-automatic
-prec	double
-
-file	quadpack/qk51.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 51 point rule and give error estimate, non-automatic
-prec	single
-
-file	quadpack/dqk51.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 51 point rule and give error estimate, non-automatic
-prec	double
-
-file	quadpack/qk61.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 61 point rule and give error estimate, non-automatic
-prec	single
-
-file	quadpack/dqk61.f
-gams	H2a1a2
-for	estimate 1D integral on finite interval using a 61 point rule and give error estimate, non-automatic
-prec	double
-
-file	quadpack/qk15i.f
-gams	H2a3a2,H2a4a2
-for	estimate 1D integral on (semi)infinite interval using a 15 point quadrature rule,non-automatic
-prec	single
-
-file	quadpack/dqk15i.f
-gams	H2a3a2,H2a4a2
-for	estimate 1D integral on (semi)infinite interval using a 15 point quadrature rule,non-automatic
-prec	double
-
-file	quadpack/qk15w.f
-gams	H2a2a2
-for	estimate 1D integral with special singular weight functions using a 15 point quadrature rule
-prec	single
-
-file	quadpack/dqk15w.f
-gams	H2a2a2
-for	estimate 1D integral with special singular weight functions using a 15 point quadrature rule
-prec	double
-
-file	quadpack/qc25c.f
-gams	H2a2a2,J4
-for	1D integral for Cauchy principal values using a 25 point quadrature rule
-prec	single
-
-file	quadpack/dqc25c.f
-gams	H2a2a2,J4
-for	1D integral for Cauchy principal values using a 25 point quadrature rule
-prec	double
-
-file	quadpack/qmomo.f
-gams	H2a2a1,C3a2
-for	1D integration of k-th degree Chebyshev polynomial times a function with singularities
-prec	single
-
-file	quadpack/dqmomo.f
-gams	H2a2a1,C3a2
-for	1D integration of k-th degree Chebyshev polynomial times a function with singularities
-prec	double
-
-file	quadpack/qc25f.f
-gams	H2a2a2
-for	1D integral for sin/cos integrand using a 25 point quadrature rule
-prec	single
-
-file	quadpack/dqc25f.f
-gams	H2a2a2
-for	1D integral for sin/cos integrand using a 25 point quadrature rule
-prec	double
-
-lib	quadpack/Old
-
-file	quadpack/changes
-
-file	quadpack/doc
-
-file	quadpack/dqcheb.f
-
-file	quadpack/dqelg.f
-
-file	quadpack/dqpsrt.f
-
-file	quadpack/dqwgtc.f
-
-file	quadpack/dqwgtf.f
-
-file	quadpack/dqwgts.f
-
-file	quadpack/qcheb.f
-
-file	quadpack/qelg.f
-
-file	quadpack/qpsrt.f
-
-file	quadpack/qwgtc.f
-
-file	quadpack/qwgtf.f
-
-file	quadpack/qwgts.f
-
-lib	quadpack/test
-
-file	quadpack/readme
-
Index: scipy/scipy/integrate/quadpack/permission
===================================================================
--- scipy.orig/scipy/integrate/quadpack/permission	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1 +0,0 @@
-prehistoric
Index: scipy/scipy/integrate/quadpack/readme
===================================================================
--- scipy.orig/scipy/integrate/quadpack/readme	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,104 +0,0 @@
-
-QUADPACK is a FORTRAN subroutine package for the numerical
-computation of definite one-dimensional integrals. It originated
-from a joint project of R. Piessens and E. de Doncker (Appl.
-Math. and Progr. Div.- K.U.Leuven, Belgium), C. Ueberhuber (Inst.
-Fuer Math.- Techn.U.Wien, Austria), and D. Kahaner (Nation. Bur.
-of Standards- Washington D.C., U.S.A.).
-The routine names for the DOUBLE PRECISION versions are preceded
-by the letter D.
-
-- QNG  : Is a simple non-adaptive automatic integrator, based on
-         a sequence of rules with increasing degree of algebraic
-         precision (Patterson, 1968).
-
-- QAG  : Is a simple globally adaptive integrator using the
-         strategy of Aind (Piessens, 1973). It is possible to
-         choose between 6 pairs of Gauss-Kronrod quadrature
-         formulae for the rule evaluation component. The pairs
-         of high degree of precision are suitable for handling
-         integration difficulties due to a strongly oscillating
-         integrand.
-
-- QAGS : Is an integrator based on globally adaptive interval
-         subdivision in connection with extrapolation (de Doncker,
-         1978) by the Epsilon algorithm (Wynn, 1956).
-
-- QAGP : Serves the same purposes as QAGS, but also allows
-         for eventual user-supplied information, i.e. the
-         abscissae of internal singularities, discontinuities
-         and other difficulties of the integrand function.
-         The algorithm is a modification of that in QAGS.
-
-- QAGI : Handles integration over infinite intervals. The
-         infinite range is mapped onto a finite interval and
-         then the same strategy as in QAGS is applied.
-
-- QAWO : Is a routine for the integration of COS(OMEGA*X)*F(X)
-         or SIN(OMEGA*X)*F(X) over a finite interval (A,B).
-         OMEGA is specified by the user
-         The rule evaluation component is based on the
-         modified Clenshaw-Curtis technique.
-         An adaptive subdivision scheme is used connected with
-         an extrapolation procedure, which is a modification
-         of that in QAGS and provides the possibility to deal
-         even with singularities in F.
-
-- QAWF : Calculates the Fourier cosine or Fourier sine
-         transform of F(X), for user-supplied interval (A,
-         INFINITY), OMEGA, and F. The procedure of QAWO is
-         used on successive finite intervals, and convergence
-         acceleration by means of the Epsilon algorithm (Wynn,
-         1956) is applied to the series of the integral
-         contributions.
-
-- QAWS : Integrates W(X)*F(X) over (A,B) with A.LT.B finite,
-         and   W(X) = ((X-A)**ALFA)*((B-X)**BETA)*V(X)
-         where V(X) = 1 or LOG(X-A) or LOG(B-X)
-                        or LOG(X-A)*LOG(B-X)
-         and   ALFA.GT.(-1), BETA.GT.(-1).
-         The user specifies A, B, ALFA, BETA and the type of
-         the function V.
-         A globally adaptive subdivision strategy is applied,
-         with modified Clenshaw-Curtis integration on the
-         subintervals which contain A or B.
-
-- QAWC : Computes the Cauchy Principal Value of F(X)/(X-C)
-         over a finite interval (A,B) and for
-         user-determined C.
-         The strategy is globally adaptive, and modified
-         Clenshaw-Curtis integration is used on the subranges
-         which contain the point X = C.
-
-   Each of the routines above also has a "more detailed" version
-with a name ending in E, as QAGE.  These provide more
-information and control than the easier versions.
-
-
-   The preceding routines are all automatic.  That is, the user
-inputs his problem and an error tolerance.  The routine
-attempts to perform the integration to within the requested
-absolute or relative error.
-   There are, in addition, a number of non-automatic integrators.
-These are most useful when the problem is such that the
-user knows that a fixed rule will provide the accuracy
-required.  Typically they return an error estimate but make
-no attempt to satisfy any particular input error request.
-
-  QK15 QK21 QK31 QK41 QK51 QK61
-       Estimate the integral on [a,b] using 15, 21,..., 61
-       point rule and return an error estimate.
-  QK15I 15 point rule for (semi)infinite interval.
-  QK15W 15 point rule for special singular weight functions.
-  QC25C 25 point rule for Cauchy Principal Values
-  QC25F 25 point rule for sin/cos integrand.
-  QMOMO Integrates k-th degree Chebychev polynomial times
-        function with various explicit singularities.
-
-Support functions from linpack, slatec, and blas have been omitted
-by default but can be obtained by asking.  For example, suppose you
-already have installed linpack and the blas, but not slatec.  Then
-use a request like  "send dqag from quadpack slatec".
-
-
-[see also toms/691]
Index: scipy/scipy/integrate/_quadpackmodule.c
===================================================================
--- scipy.orig/scipy/integrate/_quadpackmodule.c	2024-08-11 19:01:43.865849459 +0200
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,55 +0,0 @@
-/*
-  From Multipack project
- */
-#include "__quadpack.h"
-
-static struct PyMethodDef quadpack_module_methods[] = {
-{"_qagse", quadpack_qagse, METH_VARARGS, doc_qagse},
-{"_qagie", quadpack_qagie, METH_VARARGS, doc_qagie},
-{"_qagpe", quadpack_qagpe, METH_VARARGS, doc_qagpe},
-{"_qawoe", quadpack_qawoe, METH_VARARGS, doc_qawoe},
-{"_qawfe", quadpack_qawfe, METH_VARARGS, doc_qawfe},
-{"_qawse", quadpack_qawse, METH_VARARGS, doc_qawse},
-{"_qawce", quadpack_qawce, METH_VARARGS, doc_qawce},
-{NULL,		NULL, 0, NULL}
-};
-
-static struct PyModuleDef moduledef = {
-    PyModuleDef_HEAD_INIT,
-    "_quadpack",
-    NULL,
-    -1,
-    quadpack_module_methods,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-
-PyMODINIT_FUNC
-PyInit__quadpack(void)
-{
-    PyObject *module, *mdict;
-
-    import_array();
-
-    module = PyModule_Create(&moduledef);
-    if (module == NULL) {
-        return NULL;
-    }
-
-    mdict = PyModule_GetDict(module);
-    if (mdict == NULL) {
-        return NULL;
-    }
-
-    quadpack_error = PyErr_NewException ("_quadpack.error", NULL, NULL);
-    if (quadpack_error == NULL) {
-        return NULL;
-    }
-    if (PyDict_SetItemString(mdict, "error", quadpack_error)) {
-        return NULL;
-    }
-
-    return module;
-}
Index: scipy/scipy/integrate/meson.build
===================================================================
--- scipy.orig/scipy/integrate/meson.build	2024-08-11 19:01:43.865849459 +0200
+++ scipy/scipy/integrate/meson.build	2024-08-11 19:01:43.861849413 +0200
@@ -3,44 +3,6 @@
   'mach/xerror.f'
 ]
 
-quadpack_src = [
-  'quadpack/dqag.f',
-  'quadpack/dqage.f',
-  'quadpack/dqagi.f',
-  'quadpack/dqagie.f',
-  'quadpack/dqagp.f',
-  'quadpack/dqagpe.f',
-  'quadpack/dqags.f',
-  'quadpack/dqagse.f',
-  'quadpack/dqawc.f',
-  'quadpack/dqawce.f',
-  'quadpack/dqawf.f',
-  'quadpack/dqawfe.f',
-  'quadpack/dqawo.f',
-  'quadpack/dqawoe.f',
-  'quadpack/dqaws.f',
-  'quadpack/dqawse.f',
-  'quadpack/dqc25c.f',
-  'quadpack/dqc25f.f',
-  'quadpack/dqc25s.f',
-  'quadpack/dqcheb.f',
-  'quadpack/dqelg.f',
-  'quadpack/dqk15.f',
-  'quadpack/dqk15i.f',
-  'quadpack/dqk15w.f',
-  'quadpack/dqk21.f',
-  'quadpack/dqk31.f',
-  'quadpack/dqk41.f',
-  'quadpack/dqk51.f',
-  'quadpack/dqk61.f',
-  'quadpack/dqmomo.f',
-  'quadpack/dqng.f',
-  'quadpack/dqpsrt.f',
-  'quadpack/dqwgtc.f',
-  'quadpack/dqwgtf.f',
-  'quadpack/dqwgts.f'
-]
-
 lsoda_src = [
   'odepack/blkdta000.f',
   'odepack/bnorm.f',
@@ -79,12 +41,6 @@
   gnu_symbol_visibility: 'hidden',
 )
 
-quadpack_lib = static_library('quadpack_lib',
-  quadpack_src,
-  fortran_args: fortran_ignore_warnings,
-  gnu_symbol_visibility: 'hidden',
-)
-
 lsoda_lib = static_library('lsoda_lib',
   lsoda_src,
   fortran_args: fortran_ignore_warnings,
@@ -106,14 +62,10 @@
 )
 
 py3.extension_module('_quadpack',
-  ['__quadpack.h', '_quadpackmodule.c'],
-  fortran_args: fortran_ignore_warnings,
+  ['__quadpack.h', '__quadpack.c'],
   include_directories: ['../_lib/src'],
-  link_with: [quadpack_lib, mach_lib],
-  link_args: version_link_args,
-  dependencies: [lapack_dep, np_dep],
+  dependencies: np_dep,
   install: true,
-  link_language: 'fortran',
   subdir: 'scipy/integrate'
 )
 
Index: scipy/scipy/integrate/__quadpack.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ scipy/scipy/integrate/__quadpack.c	2024-08-11 19:01:43.861849413 +0200
@@ -0,0 +1,6852 @@
+/*
+ * Copyright (C) 2024 SciPy developers
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * a. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * b. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * c. Names of the SciPy Developers may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *
+ * This file is a C translation of the Fortran code known as QUADPACK written by
+ * R. Piessens, E. de Doncker-Kapenga, C. Überhuber , and D. Kahaner with the
+ * original description below.
+ *
+ */
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ * QUADPACK is a FORTRAN subroutine package for the numerical
+ * computation of definite one-dimensional integrals. It originated
+ * from a joint project of R. Piessens and E. de Doncker (Appl.
+ * Math. and Progr. Div.- K.U.Leuven, Belgium), C. Ueberhuber (Inst.
+ * Fuer Math.- Techn.U.Wien, Austria), and D. Kahaner (Nation. Bur.
+ * of Standards- Washington D.C., U.S.A.).
+ * The routine names for the DOUBLE PRECISION versions are preceded
+ * by the letter D.
+ *
+ * - QNG  : Is a simple non-adaptive automatic integrator, based on
+ *          a sequence of rules with increasing degree of algebraic
+ *          precision (Patterson, 1968).
+ *
+ * - QAG  : Is a simple globally adaptive integrator using the
+ *          strategy of Aind (Piessens, 1973). It is possible to
+ *          choose between 6 pairs of Gauss-Kronrod quadrature
+ *          formulae for the rule evaluation component. The pairs
+ *          of high degree of precision are suitable for handling
+ *          integration difficulties due to a strongly oscillating
+ *          integrand.
+ *
+ * - QAGS : Is an integrator based on globally adaptive interval
+ *          subdivision in connection with extrapolation (de Doncker,
+ *          1978) by the Epsilon algorithm (Wynn, 1956).
+ *
+ * - QAGP : Serves the same purposes as QAGS, but also allows
+ *          for eventual user-supplied information, i.e. the
+ *          abscissae of internal singularities, discontinuities
+ *          and other difficulties of the integrand function.
+ *          The algorithm is a modification of that in QAGS.
+ *
+ * - QAGI : Handles integration over infinite intervals. The
+ *          infinite range is mapped onto a finite interval and
+ *          then the same strategy as in QAGS is applied.
+ *
+ * - QAWO : Is a routine for the integration of COS(OMEGA*X)*F(X)
+ *          or SIN(OMEGA*X)*F(X) over a finite interval (A,B).
+ *          OMEGA is specified by the user
+ *          The rule evaluation component is based on the
+ *          modified Clenshaw-Curtis technique.
+ *          An adaptive subdivision scheme is used connected with
+ *          an extrapolation procedure, which is a modification
+ *          of that in QAGS and provides the possibility to deal
+ *          even with singularities in F.
+ *
+ * - QAWF : Calculates the Fourier cosine or Fourier sine
+ *          transform of F(X), for user-supplied interval (A,
+ *          INFINITY), OMEGA, and F. The procedure of QAWO is
+ *          used on successive finite intervals, and convergence
+ *          acceleration by means of the Epsilon algorithm (Wynn,
+ *          1956) is applied to the series of the integral
+ *          contributions.
+ *
+ * - QAWS : Integrates W(X)*F(X) over (A,B) with A.LT.B finite,
+ *          and   W(X) = ((X-A)**ALFA)*((B-X)**BETA)*V(X)
+ *          where V(X) = 1 or LOG(X-A) or LOG(B-X)
+ *                         or LOG(X-A)*LOG(B-X)
+ *          and   ALFA.GT.(-1), BETA.GT.(-1).
+ *          The user specifies A, B, ALFA, BETA and the type of
+ *          the function V.
+ *          A globally adaptive subdivision strategy is applied,
+ *          with modified Clenshaw-Curtis integration on the
+ *          subintervals which contain A or B.
+ *
+ * - QAWC : Computes the Cauchy Principal Value of F(X)/(X-C)
+ *          over a finite interval (A,B) and for
+ *          user-determined C.
+ *          The strategy is globally adaptive, and modified
+ *          Clenshaw-Curtis integration is used on the subranges
+ *          which contain the point X = C.
+ *
+ *    Each of the routines above also has a "more detailed" version
+ * with a name ending in E, as QAGE.  These provide more
+ * information and control than the easier versions.
+ *
+ *
+ *    The preceding routines are all automatic.  That is, the user
+ * inputs his problem and an error tolerance.  The routine
+ * attempts to perform the integration to within the requested
+ * absolute or relative error.
+ *    There are, in addition, a number of non-automatic integrators.
+ * These are most useful when the problem is such that the
+ * user knows that a fixed rule will provide the accuracy
+ * required.  Typically they return an error estimate but make
+ * no attempt to satisfy any particular input error request.
+ *
+ *   QK15 QK21 QK31 QK41 QK51 QK61
+ *        Estimate the integral on [a,b] using 15, 21,..., 61
+ *        point rule and return an error estimate.
+ *   QK15I 15 point rule for (semi)infinite interval.
+ *   QK15W 15 point rule for special singular weight functions.
+ *   QC25C 25 point rule for Cauchy Principal Values
+ *   QC25F 25 point rule for sin/cos integrand.
+ *   QMOMO Integrates k-th degree Chebychev polynomial times
+ *         function with various explicit singularities.
+ *
+ * Support functions from linpack, slatec, and blas have been omitted
+ * by default but can be obtained by asking.  For example, suppose you
+ * already have installed linpack and the blas, but not slatec.  Then
+ * use a request like  "send dqag from quadpack slatec".
+ *
+ *
+ * [see also toms/691]
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ * The original Fortran code can be found at https://www.netlib.org/quadpack/
+ *
+ * References:
+ *
+ * [1]: Robert Piessens, Elise Doncker-Kapenga, Christoph Überhuber, David
+ *      Kahaner. "QUADPACK: A subroutine package for automatic integration",
+ *      Springer, 1983, https://doi.org/10.1007/978-3-642-61786-7
+ *
+ *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#include "__quadpack.h"
+#include <math.h>
+
+
+typedef double quadpack_w_func(const double,const double,const double,const double,const double,const int);
+
+// Internal functions
+static void dqc25c(double(*)(double*),const double,const double,const double,double*,double*,int*,int*);
+static void dqc25f(double(*)(double*),const double,const double,const double,
+                   const int,const int,const int, const int, double*,double*,
+                   int*,double*,double*,int*,double*);
+static void dqc25s(double(*)(double*),const double,const double,const double,
+                   const double,const double,const double,double*,double*,double*,
+                   double*,double*,double*,double*,const int,int*);
+static void dqcheb(const double*,double*,double*,double*);
+static void dqelg(int*,double*,double*,double*,double*,int*);
+static void dqk15(double(*)(double*),const double,const double,double*,double*,double*,double*);
+static void dqk15i(double(*)(double*),const double,const int,const double,const double,double*,double*,double*,double*);
+static void dqk15w(double(*)(double*),double(),const double,const double,
+                   const double,const double,const int,const double,const double,
+                   double*,double*,double*,double*);
+static void dqk21(double(*)(double*),const double,const double,double*,double*,double*,double*);
+static void dqk31(double(*)(double*),const double,const double,double*,double*,double*,double*);
+static void dqk41(double(*)(double*),const double,const double,double*,double*,double*,double*);
+static void dqk51(double(*)(double*),const double,const double,double*,double*,double*,double*);
+static void dqk61(double(*)(double*),const double,const double,double*,double*,double*,double*);
+static void dqmomo(const double,const double,double*,double*,double*,double*,const int);
+static void dqng(double(*)(double*),const double,const double,const double,const double,double*,double*,int*,int*);
+static void dqpsrt(const int,const int,int*,double*,const double*,int *,int*);
+static double dqwgtc(const double,const double,const double,const double,const double,const int);
+static double dqwgtf(const double,const double,const double,const double,const double,const int);
+static double dqwgts(const double,const double,const double,const double,const double,const int);
+
+// Constants
+static const double uflow = 2.2250738585072014e-308;  /* np.finfo(np.float64).tiny */
+static const double oflow = 1.7976931348623157e+308;  /* np.finfo(np.float64).max  */
+static const double epmach = 2.220446049250313e-016;  /* np.finfo(np.float64).eps  */
+
+
+// Exported functions DQAGIE, DQAGPE, DQAGSE, DQAWCE, DQAWFE, DQAWOE, DQAWSE
+void
+dqagie(double(*fcn)(double* x), const double bound, const int inf,
+       const double epsabs, const double epsrel, const int limit, double* result,
+       double* abserr, int* neval, int* ier, double* alist, double* blist,
+       double* rlist, double* elist, int* iord, int* last)
+{
+    // ***begin prologue  dqagie
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a3a1,h2a4a1
+    // ***keywords  automatic integrator, infinite intervals,
+    //              general-purpose, transformation, extrapolation,
+    //              globally adaptive
+    // ***author  piessens,robert,appl. math & progr. div - k.u.leuven
+    //            de doncker,elise,appl. math & progr. div - k.u.leuven
+    // ***purpose  the routine calculates an approximation result to a given
+    //             integral   i = integral of f over (bound,+infinity)
+    //             or i = integral of f over (-infinity,bound)
+    //             or i = integral of f over (-infinity,+infinity),
+    //             hopefully satisfying following claim for accuracy
+    //             abs(i-result).le.max(epsabs,epsrel*abs(i))
+    // ***description
+    //
+    //  integration over infinite intervals
+    //  standard fortran subroutine
+    //
+    //             f      - double precision
+    //                      function subprogram defining the integrand
+    //                      function f(x). the actual name for f needs to be
+    //                      declared e x t e r n a l in the driver program.
+    //
+    //             bound  - double precision
+    //                      finite bound of integration range
+    //                      (has no meaning if interval is doubly-infinite)
+    //
+    //             inf    - double precision
+    //                      indicating the kind of integration range involved
+    //                      inf = 1 corresponds to  (bound,+infinity),
+    //                      inf = -1            to  (-infinity,bound),
+    //                      inf = 2             to (-infinity,+infinity).
+    //
+    //             epsabs - double precision
+    //                      absolute accuracy requested
+    //             epsrel - double precision
+    //                      relative accuracy requested
+    //                      if  epsabs.le.0
+    //                      and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+    //                      the routine will end with ier = 6.
+    //
+    //             limit  - integer
+    //                      gives an upper bound on the number of subintervals
+    //                      in the partition of (a,b), limit.ge.1
+    //
+    //          on return
+    //             result - double precision
+    //                      approximation to the integral
+    //
+    //             abserr - double precision
+    //                      estimate of the modulus of the absolute error,
+    //                      which should equal or exceed abs(i-result)
+    //
+    //             neval  - integer
+    //                      number of integrand evaluations
+    //
+    //             ier    - integer
+    //                      ier = 0 normal and reliable termination of the
+    //                              routine. it is assumed that the requested
+    //                              accuracy has been achieved.
+    //                    - ier.gt.0 abnormal termination of the routine. the
+    //                              estimates for result and error are less
+    //                              reliable. it is assumed that the requested
+    //                              accuracy has not been achieved.
+    //             error messages
+    //                      ier = 1 maximum number of subdivisions allowed
+    //                              has been achieved. one can allow more
+    //                              subdivisions by increasing the value of
+    //                              limit (and taking the according dimension
+    //                              adjustments into account). however,if
+    //                              this yields no improvement it is advised
+    //                              to analyze the integrand in order to
+    //                              determine the integration difficulties.
+    //                              if the position of a local difficulty can
+    //                              be determined (e.g. singularity,
+    //                              discontinuity within the interval) one
+    //                              will probably gain from splitting up the
+    //                              interval at this point and calling the
+    //                              integrator on the subranges. if possible,
+    //                              an appropriate special-purpose integrator
+    //                              should be used, which is designed for
+    //                              handling the type of difficulty involved.
+    //                          = 2 the occurrence of roundoff error is
+    //                              detected, which prevents the requested
+    //                              tolerance from being achieved.
+    //                              the error may be under-estimated.
+    //                          = 3 extremely bad integrand behaviour occurs
+    //                              at some points of the integration
+    //                              interval.
+    //                          = 4 the algorithm does not converge.
+    //                              roundoff error is detected in the
+    //                              extrapolation table.
+    //                              it is assumed that the requested tolerance
+    //                              cannot be achieved, and that the returned
+    //                              result is the best which can be obtained.
+    //                          = 5 the integral is probably divergent, or
+    //                              slowly convergent. it must be noted that
+    //                              divergence can occur with any other value
+    //                              of ier.
+    //                          = 6 the input is invalid, because
+    //                              (epsabs.le.0 and
+    //                               epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+    //                              result, abserr, neval, last, rlist(1),
+    //                              elist(1) and iord(1) are set to zero.
+    //                              alist(1) and blist(1) are set to 0
+    //                              and 1 respectively.
+    //
+    //             alist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the left
+    //                      end points of the subintervals in the partition
+    //                      of the transformed integration range (0,1).
+    //
+    //             blist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the right
+    //                      end points of the subintervals in the partition
+    //                      of the transformed integration range (0,1).
+    //
+    //             rlist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the integral
+    //                      approximations on the subintervals
+    //
+    //             elist  - double precision
+    //                      vector of dimension at least limit,  the first
+    //                      last elements of which are the moduli of the
+    //                      absolute error estimates on the subintervals
+    //
+    //             iord   - integer
+    //                      vector of dimension limit, the first k
+    //                      elements of which are pointers to the
+    //                      error estimates over the subintervals,
+    //                      such that elist(iord(1)), ..., elist(iord(k))
+    //                      form a decreasing sequence, with k = last
+    //                      if last.le.(limit/2+2), and k = limit+1-last
+    //                      otherwise
+    //
+    //             last   - integer
+    //                      number of subintervals actually produced
+    //                      in the subdivision process
+    //
+    // ***references  (none)
+    // ***routines called  d1mach,dqelg,dqk15i,dqpsrt
+    // ***end prologue  dqagie
+    //
+    //             the dimension of rlist2 is determined by the value of
+    //             limexp in subroutine dqelg.
+    //
+    //
+    //             list of major variables
+    //             -----------------------
+    //
+    //            alist     - list of left end points of all subintervals
+    //                        considered up to now
+    //            blist     - list of right end points of all subintervals
+    //                        considered up to now
+    //            rlist(i)  - approximation to the integral over
+    //                        (alist(i),blist(i))
+    //            rlist2    - array of dimension at least (limexp+2),
+    //                        containing the part of the epsilon table
+    //                        which is still needed for further computations
+    //            elist(i)  - error estimate applying to rlist(i)
+    //            maxerr    - pointer to the interval with largest error
+    //                        estimate
+    //            errmax    - elist(maxerr)
+    //            erlast    - error on the interval currently subdivided
+    //                        (before that subdivision has taken place)
+    //            area      - sum of the integrals over the subintervals
+    //            errsum    - sum of the errors over the subintervals
+    //            errbnd    - requested accuracy max(epsabs,epsrel*
+    //                        abs(result))
+    //            *****1    - variable for the left subinterval
+    //            *****2    - variable for the right subinterval
+    //            last      - index for subdivision
+    //            nres      - number of calls to the extrapolation routine
+    //            numrl2    - number of elements currently in rlist2. if an
+    //                        appropriate approximation to the compounded
+    //                        integral has been obtained, it is put in
+    //                        rlist2(numrl2) after numrl2 has been increased
+    //                        by one.
+    //            small     - length of the smallest interval considered up
+    //                        to now, multiplied by 1.5
+    //            erlarg    - sum of the errors over the intervals larger
+    //                        than the smallest interval considered up to now
+    //            extrap    - logical variable denoting that the routine
+    //                        is attempting to perform extrapolation. i.e.
+    //                        before subdividing the smallest interval we
+    //                        try to decrease the value of erlarg.
+    //            noext     - logical variable denoting that extrapolation
+    //                        is no longer allowed (true-value)
+    //
+    //             machine dependent constants
+    //             ---------------------------
+    //
+    //            epmach is the largest relative spacing.
+    //            uflow is the smallest positive magnitude.
+    //            oflow is the largest positive magnitude.
+    //
+    int ierror, iroff1, iroff2, iroff3, jupbnd, k, ksgn, ktmin, L, maxerr;
+    int nres, nrmax, numrl2, extrap, noext;
+
+    double a1, a2, abseps, area, area1, area12, area2, b1, b2, boun, correc, defabs;
+    double defab1, defab2, dres, erlarg, erlast, errbnd, errmax, error1, error2;
+    double error12, errsum, ertest, resabs, reseps, small;
+    double rlist2[52], res3la[3];
+    small = 0.0;
+    correc = 0.0;
+
+    *ier = 0;
+    *neval = 0;
+    *last = 0;
+    *result = 0.0;
+    *abserr = 0.0;
+    alist[0] = 0.0;
+    blist[0] = 1.0;
+    rlist[0] = 0.0;
+    elist[0] = 0.0;
+    iord[0] = 0;
+    if ((epsabs <= 0.0) && (epsrel < fmax(50.0*epmach, 0.5e-28))) { *ier = 6; }
+    if (*ier == 6) { return; }
+
+    // first approximation to the integral
+    // -----------------------------------
+    // determine the interval to be mapped onto (0,1).
+    // if inf = 2 the integral is computed as i = i1+i2, where
+    // i1 = integral of f over (-infinity,0),
+    // i2 = integral of f over (0,+infinity).
+
+    boun = bound;
+    if (inf == 2) { boun = 0.0; }
+    dqk15i(fcn, boun, inf, 0.0, 1.0, result, abserr, &defabs, &resabs);
+
+    // Test on accuracy.
+    *last = 1;
+    rlist[0] = *result;
+    elist[0] = *abserr;
+    iord[0] = 0;
+    dres = fabs(*result);
+    errbnd = fmax(epsabs, epsrel*dres);
+    if ((*abserr <= 100.0 * epmach * defabs) && (*abserr > errbnd)) { *ier = 2; }
+    if (limit == 1) { *ier = 1; }
+    if ((*ier != 0) || ((*abserr <= errbnd) && (*abserr != resabs)) || (*abserr == 0.0)) { goto LINE130; }
+
+    // Initialization for main loop.
+    rlist2[0] = *result;
+    errmax = *abserr;
+    maxerr = 0;
+    area = *result;
+    errsum = *abserr;
+    *abserr = oflow;
+    nrmax = 0;
+    nres = 0;
+    ktmin = 0;
+    numrl2 = 1;
+    extrap = 0;
+    noext = 0;
+    ierror = 0;
+    iroff1 = 0;
+    iroff2 = 0;
+    iroff3 = 0;
+    ksgn = (dres > (1.0 - 50.0 * epmach) * defabs ? 1 : -1);
+
+    // Main for-loop.
+    for (L = 1; L < limit; L++)
+    {
+        *last = L + 1;
+
+        // Bisect the subinterval with nrmax-th largest error estimate.
+        a1 = alist[maxerr];
+        b1 = 0.5 * (alist[maxerr] + blist[maxerr]);
+        a2 = b1;
+        b2 = blist[maxerr];
+        erlast = errmax;
+        dqk15i(fcn, boun, inf, a1, b1, &area1, &error1, &resabs, &defab1);
+        dqk15i(fcn, boun, inf, a2, b2, &area2, &error2, &resabs, &defab2);
+
+        // Improve previous approximations to integral and error and test for accuracy.
+        area12 = area1 + area2;
+        error12 = error1 + error2;
+        errsum = errsum + error12 - errmax;
+        area = area + area12 - rlist[maxerr];
+
+        if ((defab1 != error1) && (defab2 != error2))
+        {
+            if (!((fabs(rlist[maxerr] - area12) > 1.0e-5*fabs(area12)) || (error12 < 0.99*errmax)))
+            {
+                if (extrap) { iroff2++; } else { iroff1++; }
+            }
+            // 10
+            if ((L > 9) && (error12 > errmax)){ iroff3++; }
+        }
+        // 15
+
+        rlist[maxerr] = area1;
+        rlist[L] = area2;
+        errbnd = fmax(epsabs, epsrel*fabs(area));
+
+        // Test for roundoff error and eventually set error flag.
+        if (((iroff1 + iroff2) >= 10) || (iroff3 >= 20)) { *ier = 2; }
+        if (iroff2 >= 5) { ierror = 3; }
+
+        // Set error flag in the case that the number of subintervals equals limit.
+        if (*last == limit) { *ier = 1; }
+
+        // Set error flag in the case of bad integrand behavior at some points
+        // in the integration range.
+        if (fmax(fabs(a1), fabs(b2)) <= (1.0 + 100.0*epmach)*(fabs(a2) + 1000.0*uflow)) { *ier = 4; }
+
+        // Append the newly-created intervals to the list.
+        if (!(error2 > error1))
+        {
+            alist[L] = a2;
+            blist[maxerr] = b1;
+            blist[L] = b2;
+            elist[maxerr] = error1;
+            elist[L] = error2;
+        } else {
+            alist[maxerr] = a2;
+            alist[L] = a1;
+            blist[L] = b1;
+            rlist[maxerr] = area2;
+            rlist[L] = area1;
+            elist[maxerr] = error2;
+            elist[L] = error1;
+        }
+        // 20
+
+        // Call dqpsrt to maintain the descending ordering in the list of error
+        // estimates and select the subinterval with nrmax-th largest error
+        // estimate (to be bisected next).
+        dqpsrt(limit, *last, &maxerr, &errmax, elist, iord, &nrmax);
+
+        if (errsum <= errbnd) { goto LINE115; }
+        if (*ier != 0) { break; }
+        if (L == 1) { goto LINE80; }
+        if (noext) { continue; }
+        erlarg = erlarg - erlast;
+        if (fabs(b1 - a1) > small) { erlarg = erlarg + error12; }
+        if (!(extrap))
+        {
+            // Test whether the interval to be bisected next is the smallest interval.
+            if(blist[maxerr] - alist[maxerr] > small) { continue; }
+            extrap = 1;
+            nrmax = 1;
+        }
+        // 40
+
+        if ((ierror == 3) || (erlarg <= ertest)) { goto LINE60; }
+        // The smallest interval has the largest error. Before bisecting
+        // decrease the sum of the errors over the larger intervals (erlarg)
+        // and perform extrapolation.
+        jupbnd = (*last > 2 + (limit/2) ? limit + 2 - L : L);
+        for (k = nrmax; k <= jupbnd; k++) {
+            maxerr = iord[nrmax];
+            errmax = elist[maxerr];
+            if (fabs(blist[maxerr] - alist[maxerr]) > small) { goto LINE90; }
+            nrmax++;
+        }
+        // 50
+LINE60:
+        // Perform extrapolation.
+        numrl2++;
+        rlist2[numrl2] = area;
+        dqelg(&numrl2, rlist2, &reseps, &abseps, res3la, &nres);
+        ktmin += 1;
+        if ((ktmin > 5) && (*abserr < 1.0e-3 * errsum)) { *ier = 5; }
+        if (abseps >= *abserr) { goto LINE70; }
+        ktmin = 0;
+        *abserr = abseps;
+        *result = reseps;
+        correc = erlarg;
+        ertest = fmax(epsabs, epsrel*fabs(reseps));
+        if (*abserr <= ertest) { break; }
+LINE70:
+        // Prepare bisection of the smallest interval.
+        if (numrl2 == 0) { noext = 1; }
+        if (*ier == 5) { break; }
+        maxerr = iord[0];
+        errmax = elist[maxerr];
+        nrmax = 0;
+        extrap = 0;
+        small = small * 0.5;
+        erlarg = errsum;
+        continue;
+LINE80:
+        small = 0.375;
+        erlarg = errsum;
+        ertest = errbnd;
+        rlist2[1] = area;
+LINE90:
+        ; // no-op
+    }
+
+    // Set final result and error estimate.
+    if (*abserr == oflow) { goto LINE115; }
+    if ((*ier + ierror) == 0) { goto LINE110; }
+    if (ierror == 3) { *abserr = *abserr + correc; }
+    if (*ier == 0) { *ier = 3; }
+    if ((*result != 0.0) && (area != 0.0)) { goto LINE105; }
+    if (*abserr > errsum) { goto LINE115; }
+    if (area == 0.0) { goto LINE130; }
+    goto LINE110;
+LINE105:
+    if (*abserr/fabs(*result) > errsum/fabs(area)) { goto LINE115; }
+LINE110:
+    // Test on divergence.
+    if ((ksgn == -1) && (fmax(fabs(*result),fabs(area)) <= defabs *0.01)) { goto LINE130; }
+    if ((0.01 > *result/area) || (*result/area > 100.0) || (errsum > fabs(area))) { *ier = 6; }
+    goto LINE130;
+LINE115:
+    // Compute global integral.
+    *result = 0.0;
+    for (k = 0; k <= L; k++) { *result = *result + rlist[k]; }
+    *abserr = errsum;
+LINE130:
+    *neval = 30*(*last) - 15;
+    if (inf == 2) { *neval *= 2; }
+    if (*ier > 2) { *ier -= 1; }
+
+    return;
+}
+
+
+void
+dqagpe(double(*fcn)(double* x), const double a, const double b, int npts2,
+       double* points, const double epsabs, const double epsrel, const int limit,
+       double* result, double* abserr, int* neval, int* ier, double* alist,
+       double* blist, double* rlist, double* elist, double* pts, int* iord,
+       int* level, int* ndin, int* last)
+{
+    // ***begin prologue  dqagpe
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a2a1
+    // ***keywords  automatic integrator, general-purpose,
+    //              singularities at user specified points,
+    //              extrapolation, globally adaptive.
+    // ***author  piessens,robert ,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  the routine calculates an approximation result to a given
+    //             definite integral i = integral of f over (a,b), hopefully
+    //             satisfying following claim for accuracy abs(i-result).le.
+    //             max(epsabs,epsrel*abs(i)). break points of the integration
+    //             interval, where local difficulties of the integrand may
+    //             occur(e.g. singularities,discontinuities),provided by user.
+    // ***description
+    //
+    //         computation of a definite integral
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //          on entry
+    //             f      - double precision
+    //                      function subprogram defining the integrand
+    //                      function f(x). the actual name for f needs to be
+    //                      declared e x t e r n a l in the driver program.
+    //
+    //             a      - double precision
+    //                      lower limit of integration
+    //
+    //             b      - double precision
+    //                      upper limit of integration
+    //
+    //             npts2  - integer
+    //                      number equal to two more than the number of
+    //                      user-supplied break points within the integration
+    //                      range, npts2.ge.2.
+    //                      if npts2.lt.2, the routine will end with ier = 6.
+    //
+    //             points - double precision
+    //                      vector of dimension npts2, the first (npts2-2)
+    //                      elements of which are the user provided break
+    //                      points. if these points do not constitute an
+    //                      ascending sequence there will be an automatic
+    //                      sorting.
+    //
+    //             epsabs - double precision
+    //                      absolute accuracy requested
+    //             epsrel - double precision
+    //                      relative accuracy requested
+    //                      if  epsabs.le.0
+    //                      and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+    //                      the routine will end with ier = 6.
+    //
+    //             limit  - integer
+    //                      gives an upper bound on the number of subintervals
+    //                      in the partition of (a,b), limit.ge.npts2
+    //                      if limit.lt.npts2, the routine will end with
+    //                      ier = 6.
+    //
+    //          on return
+    //             result - double precision
+    //                      approximation to the integral
+    //
+    //             abserr - double precision
+    //                      estimate of the modulus of the absolute error,
+    //                      which should equal or exceed abs(i-result)
+    //
+    //             neval  - integer
+    //                      number of integrand evaluations
+    //
+    //             ier    - integer
+    //                      ier = 0 normal and reliable termination of the
+    //                              routine. it is assumed that the requested
+    //                              accuracy has been achieved.
+    //                      ier.gt.0 abnormal termination of the routine.
+    //                              the estimates for integral and error are
+    //                              less reliable. it is assumed that the
+    //                              requested accuracy has not been achieved.
+    //             error messages
+    //                      ier = 1 maximum number of subdivisions allowed
+    //                              has been achieved. one can allow more
+    //                              subdivisions by increasing the value of
+    //                              limit (and taking the according dimension
+    //                              adjustments into account). however, if
+    //                              this yields no improvement it is advised
+    //                              to analyze the integrand in order to
+    //                              determine the integration difficulties. if
+    //                              the position of a local difficulty can be
+    //                              determined (i.e. singularity,
+    //                              discontinuity within the interval), it
+    //                              should be supplied to the routine as an
+    //                              element of the vector points. if necessary
+    //                              an appropriate special-purpose integrator
+    //                              must be used, which is designed for
+    //                              handling the type of difficulty involved.
+    //                          = 2 the occurrence of roundoff error is
+    //                              detected, which prevents the requested
+    //                              tolerance from being achieved.
+    //                              the error may be under-estimated.
+    //                          = 3 extremely bad integrand behaviour occurs
+    //                              at some points of the integration
+    //                              interval.
+    //                          = 4 the algorithm does not converge.
+    //                              roundoff error is detected in the
+    //                              extrapolation table. it is presumed that
+    //                              the requested tolerance cannot be
+    //                              achieved, and that the returned result is
+    //                              the best which can be obtained.
+    //                          = 5 the integral is probably divergent, or
+    //                              slowly convergent. it must be noted that
+    //                              divergence can occur with any other value
+    //                              of ier.gt.0.
+    //                          = 6 the input is invalid because
+    //                              npts2.lt.2 or
+    //                              break points are specified outside
+    //                              the integration range or
+    //                              (epsabs.le.0 and
+    //                               epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
+    //                              or limit.lt.npts2.
+    //                              result, abserr, neval, last, rlist(1),
+    //                              and elist(1) are set to zero. alist(1) and
+    //                              blist(1) are set to a and b respectively.
+    //
+    //             alist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the left end points
+    //                      of the subintervals in the partition of the given
+    //                      integration range (a,b)
+    //
+    //             blist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the right end points
+    //                      of the subintervals in the partition of the given
+    //                      integration range (a,b)
+    //
+    //             rlist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the integral
+    //                      approximations on the subintervals
+    //
+    //             elist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the moduli of the
+    //                      absolute error estimates on the subintervals
+    //
+    //             pts    - double precision
+    //                      vector of dimension at least npts2, containing the
+    //                      integration limits and the break points of the
+    //                      interval in ascending sequence.
+    //
+    //             level  - integer
+    //                      vector of dimension at least limit, containing the
+    //                      subdivision levels of the subinterval, i.e. if
+    //                      (aa,bb) is a subinterval of (p1,p2) where p1 as
+    //                      well as p2 is a user-provided break point or
+    //                      integration limit, then (aa,bb) has level l if
+    //                      abs(bb-aa) = abs(p2-p1)*2**(-l).
+    //
+    //             ndin   - integer
+    //                      vector of dimension at least npts2, after first
+    //                      integration over the intervals (pts(i)),pts(i+1),
+    //                      i = 0,1, ..., npts2-2, the error estimates over
+    //                      some of the intervals may have been increased
+    //                      artificially, in order to put their subdivision
+    //                      forward. if this happens for the subinterval
+    //                      numbered k, ndin(k) is put to 1, otherwise
+    //                      ndin(k) = 0.
+    //
+    //             iord   - integer
+    //                      vector of dimension at least limit, the first k
+    //                      elements of which are pointers to the
+    //                      error estimates over the subintervals,
+    //                      such that elist(iord(1)), ..., elist(iord(k))
+    //                      form a decreasing sequence, with k = last
+    //                      if last.le.(limit/2+2), and k = limit+1-last
+    //                      otherwise
+    //
+    //             last   - integer
+    //                      number of subintervals actually produced in the
+    //                      subdivisions process
+    //
+    // ***references  (none)
+    // ***routines called  d1mach,dqelg,dqk21,dqpsrt
+    // ***end prologue  dqagpe
+    //
+    //             the dimension of rlist2 is determined by the value of
+    //             limexp in subroutine epsalg (rlist2 should be of dimension
+    //             (limexp+2) at least).
+    //
+    //
+    //             list of major variables
+    //             -----------------------
+    //
+    //            alist     - list of left end points of all subintervals
+    //                        considered up to now
+    //            blist     - list of right end points of all subintervals
+    //                        considered up to now
+    //            rlist(i)  - approximation to the integral over
+    //                        (alist(i),blist(i))
+    //            rlist2    - array of dimension at least limexp+2
+    //                        containing the part of the epsilon table which
+    //                        is still needed for further computations
+    //            elist(i)  - error estimate applying to rlist(i)
+    //            maxerr    - pointer to the interval with largest error
+    //                        estimate
+    //            errmax    - elist(maxerr)
+    //            erlast    - error on the interval currently subdivided
+    //                        (before that subdivision has taken place)
+    //            area      - sum of the integrals over the subintervals
+    //            errsum    - sum of the errors over the subintervals
+    //            errbnd    - requested accuracy max(epsabs,epsrel*
+    //                        abs(result))
+    //            *****1    - variable for the left subinterval
+    //            *****2    - variable for the right subinterval
+    //            last      - index for subdivision
+    //            nres      - number of calls to the extrapolation routine
+    //            numrl2    - number of elements in rlist2. if an appropriate
+    //                        approximation to the compounded integral has
+    //                        been obtained, it is put in rlist2(numrl2) after
+    //                        numrl2 has been increased by one.
+    //            erlarg    - sum of the errors over the intervals larger
+    //                        than the smallest interval considered up to now
+    //            extrap    - logical variable denoting that the routine
+    //                        is attempting to perform extrapolation. i.e.
+    //                        before subdividing the smallest interval we
+    //                        try to decrease the value of erlarg.
+    //            noext     - logical variable denoting that extrapolation is
+    //                        no longer allowed (true-value)
+    //
+    //             machine dependent constants
+    //             ---------------------------
+    //
+    //            epmach is the largest relative spacing.
+    //            uflow is the smallest positive magnitude.
+    //            oflow is the largest positive magnitude.
+    //
+    int i, ierror, ind1, ind2, iroff1, iroff2, iroff3, j, jlow,jupbnd;
+    int k, ksgn, ktmin, L, levcur, levmax, maxerr, nint, npts, nres, nrmax;
+    int numrl2, extrap, noext;
+    double abseps, area, area1, area12, area2, a1, a2, b1, b2, correc;
+    double defabs, defab1, defab2, dres, erlarg, erlast, errbnd, errmax, error1;
+    double error12, error2, errsum, ertest, resa, resabs, reseps, sign, temp;
+    double res3la[3], rlist2[52];
+    k = 0;
+    correc = 0.0;
+
+    // Test validity of parameters.
+    *ier = 6;
+    *neval = 0;
+    *last = 0;
+    *result = 0.0;
+    *abserr = 0.0;
+    alist[0] = a;
+    blist[0] = b;
+    rlist[0] = 0.0;
+    elist[0] = 0.0;
+    iord[0] = 0;
+    level[0] = 0;
+    npts = npts2 - 2;
+    if ((npts2 < 2) || (limit <= npts) ||
+        ((epsabs <= 0.0) && (epsrel < fmax(50.0*epmach, 0.5e-28)))) { return; }
+    *ier = 0;
+
+    // If any break points are provided, sort them into an ascending sequence.
+    sign = (a > b ? -1.0 : 1.0);
+    pts[0] = fmin(a, b);
+    if (npts != 0)
+    {
+        for (i = 0; i < npts; i++) { pts[i+1] = points[i]; }
+    }
+    // 15
+
+    pts[npts + 1] = fmax(a, b);
+    nint = npts + 1;
+    a1 = pts[0];
+    if (npts != 0)
+    {
+        for (i = 0; i < nint; i++)
+        {
+            for (j = i+1; j < nint+1; j++)
+            {
+                if (pts[i] <= pts[j]) { continue; }
+                temp = pts[i];
+                pts[i] = pts[j];
+                pts[j] = temp;
+            }
+        }
+        // 20
+        if ((pts[0] != fmin(a, b)) || (pts[nint] != fmax(a, b)))
+        {
+            *ier = 6;
+            return;
+        }
+    }
+    // 40
+
+    // Compute first integral and error approximations.
+    resabs = 0.0;
+    for (i = 0; i < nint; i++)
+    {
+        b1 = pts[i+1];
+        dqk21(fcn, a1, b1, &area1, &error1, &defabs, &resa);
+        *abserr = *abserr + error1;
+        *result = *result + area1;
+        ndin[i] = 0;
+        if ((error1 == resa) && (error1 != 0.0)) { ndin[i] = 1; }
+        resabs = resabs + defabs;
+        level[i] = 0;
+        elist[i] = error1;
+        alist[i] = a1;
+        blist[i] = b1;
+        rlist[i] = area1;
+        iord[i] = i;
+        a1 = b1;
+    }
+    // 50
+
+    errsum = 0.0;
+    for (i = 0; i < nint; i++)
+    {
+        if (ndin[i] == 1) { elist[i] = *abserr; }
+        errsum = errsum + elist[i];
+    }
+    // 55
+
+    // Test on accuracy.
+    *last = nint;
+    *neval = 21 * nint;
+    dres = fabs(*result);
+    errbnd = fmax(epsabs, epsrel*dres);
+    if ((*abserr <= 100.0 * epmach * resabs) && (*abserr > errbnd)) { *ier = 2; }
+    if (nint != 1)
+    {
+        for (i = 0; i < npts; i++)
+        {
+            jlow = i+1;
+            ind1 = iord[i];
+            for (j = jlow; j < nint; j++)
+            {
+                ind2 = iord[j];
+                if (elist[ind1] > elist[ind2]) { continue; }
+                ind1 = ind2;
+                k = j;
+            }
+            // 60
+
+            if (ind1 == iord[i]) { continue; }
+            iord[k] = iord[i];
+            iord[i] = ind1;
+        }
+        // 70
+
+        if (limit < npts2) { *ier = 1; }
+    }
+    // 80
+    if ((*ier != 0) || (*abserr <= errbnd)) { goto LINE210; }
+
+    // Initialization
+    rlist2[0] = *result;
+    maxerr = iord[0];
+    errmax = elist[maxerr];
+    area = *result;
+    nrmax = 0;
+    nres = 0;
+    numrl2 = 0;
+    ktmin = 0;
+    extrap = 0;
+    noext = 0;
+    erlarg = errsum;
+    ertest = errbnd;
+    levmax = 1;
+    iroff1 = 0;
+    iroff2 = 0;
+    iroff3 = 0;
+    ierror = 0;
+    *abserr = oflow;
+    ksgn = (dres >= (1.0 - 50*epmach)*resabs ?  1 : -1);
+
+    // Main for-loop.
+    for (L = npts2 - 1; L < limit; L++)
+    {
+        *last = L + 1;
+
+        // Bisect the subinterval with the nrmax-th largest error estimate.
+        levcur = level[maxerr] + 1;
+        a1 = alist[maxerr];
+        b1 = 0.5 * (alist[maxerr] + blist[maxerr]);
+        a2 = b1;
+        b2 = blist[maxerr];
+        erlast = errmax;
+        dqk21(fcn, a1, b1, &area1, &error1, &resa, &defab1);
+        dqk21(fcn, a2, b2, &area2, &error2, &resa, &defab2);
+
+        // Improve previous approximations to integral and error and test accuracy.
+        *neval += 42;
+        area12 = area1 + area2;
+        error12 = error1 + error2;
+        errsum = errsum + error12 - errmax;
+        area = area + area12 - rlist[maxerr];
+        if ((defab1 != error1) && (defab2 != error2))
+        {
+            if (!((fabs(rlist[maxerr] - area12) > 1.0e-5*fabs(area12)) || (error12 < 0.99*errmax)))
+            {
+                if (extrap) { iroff2++; } else { iroff1++; }
+            }
+            // 90
+            if ((L > 9) && error12 > errmax) { iroff3++; }
+        }
+        // 95
+        level[maxerr] = levcur;
+        level[L] = levcur;
+        rlist[maxerr] = area1;
+        rlist[L] = area2;
+        errbnd = fmax(epsabs, epsrel*fabs(area));
+
+        // Test for roundoff error and eventually set error flag.
+        if (((iroff1 + iroff2) >= 10) || (iroff3 >= 20)) { *ier = 2; }
+        if (iroff2 >= 5) { ierror = 3; }
+
+        // Set error flag in the case that the number of subintervals equals limit.
+        if (*last == limit) { *ier = 1; }
+
+        // Set error flag in the case of bad integrand behavior at a point of the
+        // integration range.
+        if (fmax(fabs(a1), fabs(b2)) <= (1.0 +100.0*epmach)*(fabs(a2) + 1000.0*uflow))
+        {
+            *ier = 4;
+        }
+
+        // Append the newly-created intervals to the list.
+        if (!(error2 > error1))
+        {
+            alist[L] = a2;
+            blist[maxerr] = b1;
+            blist[L] = b2;
+            elist[maxerr] = error1;
+            elist[L] = error2;
+        } else {
+            alist[maxerr] = a2;
+            alist[L] = a1;
+            blist[L] = b1;
+            rlist[maxerr] = area2;
+            rlist[L] = area1;
+            elist[maxerr] = error2;
+            elist[L] = error1;
+        }
+        // 110
+
+        // Call subroutine dqpsrt to maintain the descending ordering in the list
+        // of error estimates and select the subinterval with nrmax-th largest
+        // error estimate (to be bisected next).
+        dqpsrt(limit, *last, &maxerr, &errmax, elist, iord, &nrmax);
+
+        if (errsum <= errbnd) { goto LINE190; }
+        if (*ier != 0) { break; }
+        if (noext) { continue; }
+        erlarg = erlarg - erlast;
+        if (levcur+1 <= levmax) { erlarg = erlarg + error12; }
+        if (!(extrap))
+        {
+            if(level[maxerr]+1 <= levmax) { continue; }
+            extrap = 1;
+            nrmax = 1;
+        }
+        // 120
+
+        if ((ierror != 3) && (!(erlarg <= ertest)))
+        {
+            // The smallest interval has the largest error. Before bisecting
+            // decrease the sum of the errors over the larger intervals (erlarg)
+            // and perform extrapolation.
+            jupbnd = (*last > 2 + (limit/2) ? limit + 2 - L : L);
+            for (k = nrmax; k <= jupbnd; k++) {
+                maxerr = iord[nrmax];
+                errmax = elist[maxerr];
+                if (level[maxerr] +1 <= levmax) { goto LINE160; }  // break->continue
+                nrmax++;
+            }
+            // 130
+        }
+        // 140
+
+        // Perform extrapolation.
+        numrl2++;
+        rlist2[numrl2] = area;
+        if (numrl2 <= 1) { goto LINE155; }
+        dqelg(&numrl2, rlist2, &reseps, &abseps, res3la, &nres);
+        ktmin++;
+        if ((ktmin > 5) && (*abserr < 1.0e-3 * errsum)) { *ier = 5; }
+        if (abseps >= *abserr) { goto LINE150; }
+        ktmin = 0;
+        *abserr = abseps;
+        *result = reseps;
+        correc = erlarg;
+        ertest = fmax(epsabs, epsrel*fabs(reseps));
+        if (*abserr < ertest) { break; }
+LINE150:
+        // Prepare bisection of the smallest interval.
+        if (numrl2 == 0) noext = 1;
+        if (*ier >= 5) { break; }
+LINE155:
+        maxerr = iord[0];
+        errmax = elist[maxerr];
+        nrmax = 0;
+        extrap = 0;
+        levmax += 1;
+        erlarg = errsum;
+LINE160:
+        ; // no-op.
+    }
+
+    // 170
+    if (*abserr == oflow) { goto LINE190; }
+    if ((*ier + ierror) == 0) { goto LINE180; }
+    if (ierror == 3) *abserr = *abserr + correc;
+    if (*ier == 0) { *ier = 3; }
+    if ((*result != 0.0) && (area != 0.0)) { goto LINE175; }
+    if (*abserr > errsum) { goto LINE190; }
+    if (area == 0.0) { goto LINE210; }
+    goto LINE180;
+LINE175:
+    if (*abserr/fabs(*result) > errsum/fabs(area)) { goto LINE190; }
+LINE180:
+    // Test on divergence.
+    if ((ksgn == -1) && (fmax(fabs(*result), fabs(area)) <= resabs*0.01)) { goto LINE210; }
+    if ((0.01 > *result/area) || (*result/area > 100.0) || (errsum > fabs(area))) { *ier = 6; }
+    goto LINE210;
+LINE190:
+    // Compute global integral sum.
+    *result = 0.0;
+    for (k = 0; k <= L; k++) { *result = *result + rlist[k]; }
+    *abserr = errsum;
+LINE210:
+    if (*ier > 2) { *ier -= 1; }
+    *result = (*result)*sign;
+
+    return;
+}
+
+
+void
+dqagse(double(*fcn)(double* x), const double a, const double b,
+       const double epsabs, const double epsrel, const int limit, double* result,
+       double* abserr, int* neval, int* ier, double* alist, double* blist,
+       double* rlist, double* elist, int* iord, int* last)
+{
+    // ***begin prologue  dqagse
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a1a1
+    // ***keywords  automatic integrator, general-purpose,
+    //              (end point) singularities, extrapolation,
+    //              globally adaptive
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  the routine calculates an approximation result to a given
+    //             definite integral i = integral of f over (a,b),
+    //             hopefully satisfying following claim for accuracy
+    //             abs(i-result).le.max(epsabs,epsrel*abs(i)).
+    // ***description
+    //
+    //         computation of a definite integral
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //          on entry
+    //             f      - double precision
+    //                      function subprogram defining the integrand
+    //                      function f(x). the actual name for f needs to be
+    //                      declared e x t e r n a l in the driver program.
+    //
+    //             a      - double precision
+    //                      lower limit of integration
+    //
+    //             b      - double precision
+    //                      upper limit of integration
+    //
+    //             epsabs - double precision
+    //                      absolute accuracy requested
+    //             epsrel - double precision
+    //                      relative accuracy requested
+    //                      if  epsabs.le.0
+    //                      and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+    //                      the routine will end with ier = 6.
+    //
+    //             limit  - integer
+    //                      gives an upperbound on the number of subintervals
+    //                      in the partition of (a,b)
+    //
+    //          on return
+    //             result - double precision
+    //                      approximation to the integral
+    //
+    //             abserr - double precision
+    //                      estimate of the modulus of the absolute error,
+    //                      which should equal or exceed abs(i-result)
+    //
+    //             neval  - integer
+    //                      number of integrand evaluations
+    //
+    //             ier    - integer
+    //                      ier = 0 normal and reliable termination of the
+    //                              routine. it is assumed that the requested
+    //                              accuracy has been achieved.
+    //                      ier.gt.0 abnormal termination of the routine
+    //                              the estimates for integral and error are
+    //                              less reliable. it is assumed that the
+    //                              requested accuracy has not been achieved.
+    //             error messages
+    //                          = 1 maximum number of subdivisions allowed
+    //                              has been achieved. one can allow more sub-
+    //                              divisions by increasing the value of limit
+    //                              (and taking the according dimension
+    //                              adjustments into account). however, if
+    //                              this yields no improvement it is advised
+    //                              to analyze the integrand in order to
+    //                              determine the integration difficulties. if
+    //                              the position of a local difficulty can be
+    //                              determined (e.g. singularity,
+    //                              discontinuity within the interval) one
+    //                              will probably gain from splitting up the
+    //                              interval at this point and calling the
+    //                              integrator on the subranges. if possible,
+    //                              an appropriate special-purpose integrator
+    //                              should be used, which is designed for
+    //                              handling the type of difficulty involved.
+    //                          = 2 the occurrence of roundoff error is detec-
+    //                              ted, which prevents the requested
+    //                              tolerance from being achieved.
+    //                              the error may be under-estimated.
+    //                          = 3 extremely bad integrand behaviour
+    //                              occurs at some points of the integration
+    //                              interval.
+    //                          = 4 the algorithm does not converge.
+    //                              roundoff error is detected in the
+    //                              extrapolation table.
+    //                              it is presumed that the requested
+    //                              tolerance cannot be achieved, and that the
+    //                              returned result is the best which can be
+    //                              obtained.
+    //                          = 5 the integral is probably divergent, or
+    //                              slowly convergent. it must be noted that
+    //                              divergence can occur with any other value
+    //                              of ier.
+    //                          = 6 the input is invalid, because
+    //                              epsabs.le.0 and
+    //                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28).
+    //                              result, abserr, neval, last, rlist(1),
+    //                              iord(1) and elist(1) are set to zero.
+    //                              alist(1) and blist(1) are set to a and b
+    //                              respectively.
+    //
+    //             alist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the left end points
+    //                      of the subintervals in the partition of the
+    //                      given integration range (a,b)
+    //
+    //             blist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the right end points
+    //                      of the subintervals in the partition of the given
+    //                      integration range (a,b)
+    //
+    //             rlist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the integral
+    //                      approximations on the subintervals
+    //
+    //             elist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the moduli of the
+    //                      absolute error estimates on the subintervals
+    //
+    //             iord   - integer
+    //                      vector of dimension at least limit, the first k
+    //                      elements of which are pointers to the
+    //                      error estimates over the subintervals,
+    //                      such that elist(iord(1)), ..., elist(iord(k))
+    //                      form a decreasing sequence, with k = last
+    //                      if last.le.(limit/2+2), and k = limit+1-last
+    //                      otherwise
+    //
+    //             last   - integer
+    //                      number of subintervals actually produced in the
+    //                      subdivision process
+    //
+    // ***references  (none)
+    // ***routines called  d1mach,dqelg,dqk21,dqpsrt
+    // ***end prologue  dqagse
+    //
+    //
+    //             the dimension of rlist2 is determined by the value of
+    //             limexp in subroutine dqelg (rlist2 should be of dimension
+    //             (limexp+2) at least).
+    //
+    //             list of major variables
+    //             -----------------------
+    //
+    //            alist     - list of left end points of all subintervals
+    //                        considered up to now
+    //            blist     - list of right end points of all subintervals
+    //                        considered up to now
+    //            rlist(i)  - approximation to the integral over
+    //                        (alist(i),blist(i))
+    //            rlist2    - array of dimension at least limexp+2 containing
+    //                        the part of the epsilon table which is still
+    //                        needed for further computations
+    //            elist(i)  - error estimate applying to rlist(i)
+    //            maxerr    - pointer to the interval with largest error
+    //                        estimate
+    //            errmax    - elist(maxerr)
+    //            erlast    - error on the interval currently subdivided
+    //                        (before that subdivision has taken place)
+    //            area      - sum of the integrals over the subintervals
+    //            errsum    - sum of the errors over the subintervals
+    //            errbnd    - requested accuracy max(epsabs,epsrel*
+    //                        abs(result))
+    //            *****1    - variable for the left interval
+    //            *****2    - variable for the right interval
+    //            last      - index for subdivision
+    //            nres      - number of calls to the extrapolation routine
+    //            numrl2    - number of elements currently in rlist2. if an
+    //                        appropriate approximation to the compounded
+    //                        integral has been obtained it is put in
+    //                        rlist2(numrl2) after numrl2 has been increased
+    //                        by one.
+    //            small     - length of the smallest interval considered up
+    //                        to now, multiplied by 1.5
+    //            erlarg    - sum of the errors over the intervals larger
+    //                        than the smallest interval considered up to now
+    //            extrap    - logical variable denoting that the routine is
+    //                        attempting to perform extrapolation i.e. before
+    //                        subdividing the smallest interval we try to
+    //                        decrease the value of erlarg.
+    //            noext     - logical variable denoting that extrapolation
+    //                        is no longer allowed (true value)
+    //
+    //             machine dependent constants
+    //             ---------------------------
+    //
+    //            epmach is the largest relative spacing.
+    //            uflow is the smallest positive magnitude.
+    //            oflow is the largest positive magnitude.
+    //
+    int extrap, ierror, iroff1, iroff2, iroff3, k, ksgn, ktmin, L, maxerr;
+    int noext, nres, nrmax, numrl2;
+    double a1, a2, area, area1, area12, area2, b1, b2, defab1, defab2, defabs;
+    double dres, erlarg, erlast, errbnd, errmax, error1, error12, error2, errsum;
+    double ertest, small, jupbnd, correc, resabs, reseps, abseps;
+    double res3la[3], rlist2[52];
+    small = 0.0;
+
+    *ier = 0;
+    *neval = 0;
+    *last = 0;
+    alist[0] = a;
+    blist[0] = b;
+    rlist[0] = 0.0;
+    elist[0] = 0.0;
+    iord[0] = 0;
+    *result = 0.0;
+    *abserr = 0.0;
+    ierror = 0;
+    erlarg = 0.0;
+    correc = 0.0;
+
+    if ((epsabs <= 0.0) && (epsrel < fmax(50.0*epmach, 0.5e-28)))
+    {
+        *ier = 6;
+        return;
+    }
+
+    // First approximation to the integral.
+    dqk21(fcn, a, b, result, abserr, &defabs, &resabs);
+
+    // Test on accuracy
+    dres = fabs(*result);
+    errbnd = fmax(epsabs, epsrel*dres);
+    *last = 1;
+    rlist[0] = *result;
+    elist[0] = *abserr;
+    iord[0] = 0;
+
+    if ((*abserr <= 100.0*epmach*defabs) && (*abserr > errbnd)) { *ier = 2; }
+    if (limit == 1) { *ier = 1; }
+    if ((*ier != 0) || ((*abserr <= errbnd) && (*abserr != resabs)) || (*abserr == 0.0)) { goto LINE140; }
+
+    // Initialization.
+    rlist2[0] = *result;
+    errmax = *abserr;
+    maxerr = 0;
+    area = *result;
+    errsum = *abserr;
+    *abserr = oflow;
+    nrmax = 0;
+    nres = 0;
+    numrl2 = 1;
+    ktmin = 0;
+    extrap = 0;
+    noext = 0;
+    iroff1 = 0;
+    iroff2 = 0;
+    iroff3 = 0;
+    ksgn = (dres >= (1.0 - 50.0*epmach)*defabs ? 1 : -1);
+
+    // Main for-loop
+    for (L = 1; L < limit; L++)
+    {
+        *last = L + 1;
+
+        // Bisect the subinterval with nrmax-th largest error estimate.
+        a1 = alist[maxerr];
+        b1 = 0.5*(alist[maxerr] + blist[maxerr]);
+        a2 = b1;
+        b2 = blist[maxerr];
+        erlast = errmax;
+        dqk21(fcn, a1, b1, &area1, &error1, &resabs, &defab1);
+        dqk21(fcn, a2, b2, &area2, &error2, &resabs, &defab2);
+
+        // Improve previous approximations to integral and error and test for accuracy.
+        area12 = area1 + area2;
+        error12 = error1 + error2;
+        errsum = errsum + error12 - errmax;
+        area = area + area12 - rlist[maxerr];
+
+        if ((defab1 != error1) && (defab2 != error2))
+        {
+            if (!((fabs(rlist[maxerr] - area12) > 1.0e-5*fabs(area12)) || (error12 < 0.99*errmax)))
+            {
+                if (extrap) { iroff2++; } else { iroff1++; }
+            }
+            // 10
+            if ((L > 9) && (error12 > errmax)) { iroff3++; }
+        }
+        // 15
+
+        rlist[maxerr] = area1;
+        rlist[L] = area2;
+        errbnd = fmax(epsabs, epsrel*fabs(area));
+
+        // Test for roundoff error and eventually set error flag.
+        if (((iroff1 + iroff2) >= 10) || (iroff3 >= 20)) { *ier = 2; }
+        if (iroff2 >= 5) { ierror = 3; }
+
+        // Set error flag in the case that the number of subintervals equals limit.
+        if (*last == limit) { *ier = 1; }
+
+        // Set error flag in the case of bad integrand behavior at some points
+        // in the integration range.
+        if (fmax(fabs(a1), fabs(b2)) <= (1.0 + 100.0*epmach)*(fabs(a2) + 1000.0*uflow))
+        {
+            *ier = 4;
+        }
+
+        // Append the newly-created intervals to the list.
+        if (!(error2 > error1))
+        {
+            alist[L] = a2;
+            blist[maxerr] = b1;
+            blist[L] = b2;
+            elist[maxerr] = error1;
+            elist[L] = error2;
+        } else {
+            alist[maxerr] = a2;
+            alist[L] = a1;
+            blist[L] = b1;
+            rlist[maxerr] = area2;
+            rlist[L] = area1;
+            elist[maxerr] = error2;
+            elist[L] = error1;
+        }
+
+        // call subroutine dqpsrt to maintain the descending ordering in the
+        // list of error estimates and select the subinterval with nrmax-th
+        // largest error estimate (to be bisected next).
+        dqpsrt(limit, *last, &maxerr, &errmax, elist, iord, &nrmax);
+
+        if (errsum <= errbnd) { goto LINE115; }
+        if (*ier != 0) { break; }
+        if (L == 1) { goto LINE80; }
+        if (noext) { continue; }
+        erlarg = erlarg - erlast;
+        if (fabs(b1 - a1) > small) { erlarg = erlarg + error12; }
+        if (!(extrap))
+        {
+            // Test whether the interval to be bisected next is the smallest interval.
+            if (fabs(blist[maxerr] - alist[maxerr]) > small) { continue; }
+            extrap = 1;
+            nrmax = 1;
+        }
+        // 40
+        if ((ierror == 3) || (erlarg <= ertest)) { goto LINE60; }
+
+        // The smallest interval has the largest error. Before bisecting
+        // decrease the sum of the errors over the larger intervals (erlarg)
+        // and perform extrapolation.
+        jupbnd = (*last > 2 + (limit/2) ? limit + 2 - L : L);
+        for (k = nrmax; k <= jupbnd; k++) {
+            maxerr = iord[nrmax];
+            errmax = elist[maxerr];
+            if (fabs(blist[maxerr] - alist[maxerr]) > small) { goto LINE90; } // break->continue
+            nrmax++;
+        }
+        // 50
+LINE60:
+        // Perform extrapolation.
+        numrl2++;
+        rlist2[numrl2] = area;
+        dqelg(&numrl2, rlist2, &reseps, &abseps, res3la, &nres);
+        ktmin += 1;
+        if ((ktmin > 5) && (*abserr < 1.0e-3 * errsum)) { *ier = 5; }
+        if (abseps >= *abserr) { goto LINE70; }
+        ktmin = 0;
+        *abserr = abseps;
+        *result = reseps;
+        correc = erlarg;
+        ertest = fmax(epsabs, epsrel*fabs(reseps));
+        if (*abserr <= ertest) { break; }
+LINE70:
+        // Prepare bisection of the smallest interval.
+        if (numrl2 == 0) { noext = 1; }
+        if (*ier == 5) { break; }
+        maxerr = iord[0];
+        errmax = elist[maxerr];
+        nrmax = 0;
+        extrap = 0;
+        small = small * 0.5;
+        erlarg = errsum;
+        continue;
+LINE80:
+        small = fabs(b - a)*0.375;
+        erlarg = errsum;
+        ertest = errbnd;
+        rlist2[1] = area;
+LINE90:
+        ; // no-op
+    }
+
+    // Set final result and error estimate
+    if (*abserr == oflow) { goto LINE115; }
+    if ((*ier + ierror) == 0) { goto LINE110; }
+    if (ierror == 3) { *abserr = *abserr + correc; }
+    if (*ier == 0) { *ier = 3; }
+    if ((*result != 0.0) && (area != 0.0)) { goto LINE105; }
+    if (*abserr > errsum) { goto LINE115; }
+    if (area == 0.0) { goto LINE130; }
+    goto LINE110;
+LINE105:
+    if (*abserr/fabs(*result) > errsum/fabs(area)) { goto LINE115; }
+LINE110:
+    // Test on divergence.
+    if ((ksgn == -1) && (fmax(fabs(*result), fabs(area)) <= defabs*0.01)) { goto LINE130; }
+    if ((0.01 > (*result/area)) || ((*result/area) > 100.0) || (errsum > fabs(area))) { *ier = 6; }
+    goto LINE130;
+
+LINE115:
+    // Compute global integral sum.
+    *result = 0.0;
+    for (k = 0; k <= L; k++)
+    {
+        *result = *result + rlist[k];
+    }
+    // 120
+    *abserr = errsum;
+LINE130:
+    if (*ier > 2) { *ier -= 1; }
+LINE140:
+    *neval = 42*(*last) - 21;
+
+    return;
+}
+
+
+void
+dqawce(double(*fcn)(double* x), const double a, const double b, const double c,
+       const double epsabs, const double epsrel, const int limit, double* result,
+       double* abserr, int* neval, int* ier, double* alist, double* blist,
+       double* rlist, double* elist, int* iord, int* last)
+{
+    // ***begin prologue  dqawce
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a2a1,j4
+    // ***keywords  automatic integrator, special-purpose,
+    //              cauchy principal value, clenshaw-curtis method
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***  purpose  the routine calculates an approximation result to a
+    //               cauchy principal value i = integral of f*w over (a,b)
+    //               (w(x) = 1/(x-c), (c.ne.a, c.ne.b), hopefully satisfying
+    //               following claim for accuracy
+    //               abs(i-result).le.max(epsabs,epsrel*abs(i))
+    // ***description
+    //
+    //         computation of a cauchy principal value
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //          on entry
+    //             f      - double precision
+    //                      function subprogram defining the integrand
+    //                      function f(x). the actual name for f needs to be
+    //                      declared e x t e r n a l in the driver program.
+    //
+    //             a      - double precision
+    //                      lower limit of integration
+    //
+    //             b      - double precision
+    //                      upper limit of integration
+    //
+    //             c      - double precision
+    //                      parameter in the weight function, c.ne.a, c.ne.b
+    //                      if c = a or c = b, the routine will end with
+    //                      ier = 6.
+    //
+    //             epsabs - double precision
+    //                      absolute accuracy requested
+    //             epsrel - double precision
+    //                      relative accuracy requested
+    //                      if  epsabs.le.0
+    //                      and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+    //                      the routine will end with ier = 6.
+    //
+    //             limit  - integer
+    //                      gives an upper bound on the number of subintervals
+    //                      in the partition of (a,b), limit.ge.1
+    //
+    //          on return
+    //             result - double precision
+    //                      approximation to the integral
+    //
+    //             abserr - double precision
+    //                      estimate of the modulus of the absolute error,
+    //                      which should equal or exceed abs(i-result)
+    //
+    //             neval  - integer
+    //                      number of integrand evaluations
+    //
+    //             ier    - integer
+    //                      ier = 0 normal and reliable termination of the
+    //                              routine. it is assumed that the requested
+    //                              accuracy has been achieved.
+    //                      ier.gt.0 abnormal termination of the routine
+    //                              the estimates for integral and error are
+    //                              less reliable. it is assumed that the
+    //                              requested accuracy has not been achieved.
+    //             error messages
+    //                      ier = 1 maximum number of subdivisions allowed
+    //                              has been achieved. one can allow more sub-
+    //                              divisions by increasing the value of
+    //                              limit. however, if this yields no
+    //                              improvement it is advised to analyze the
+    //                              the integrand, in order to determine the
+    //                              the integration difficulties. if the
+    //                              position of a local difficulty can be
+    //                              determined (e.g. singularity,
+    //                              discontinuity within the interval) one
+    //                              will probably gain from splitting up the
+    //                              interval at this point and calling
+    //                              appropriate integrators on the subranges.
+    //                          = 2 the occurrence of roundoff error is detec-
+    //                              ted, which prevents the requested
+    //                              tolerance from being achieved.
+    //                          = 3 extremely bad integrand behaviour
+    //                              occurs at some interior points of
+    //                              the integration interval.
+    //                          = 6 the input is invalid, because
+    //                              c = a or c = b or
+    //                              (epsabs.le.0 and
+    //                               epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
+    //                              or limit.lt.1.
+    //                              result, abserr, neval, rlist(1), elist(1),
+    //                              iord(1) and last are set to zero. alist(1)
+    //                              and blist(1) are set to a and b
+    //                              respectively.
+    //
+    //             alist   - double precision
+    //                       vector of dimension at least limit, the first
+    //                        last  elements of which are the left
+    //                       end points of the subintervals in the partition
+    //                       of the given integration range (a,b)
+    //
+    //             blist   - double precision
+    //                       vector of dimension at least limit, the first
+    //                        last  elements of which are the right
+    //                       end points of the subintervals in the partition
+    //                       of the given integration range (a,b)
+    //
+    //             rlist   - double precision
+    //                       vector of dimension at least limit, the first
+    //                        last  elements of which are the integral
+    //                       approximations on the subintervals
+    //
+    //             elist   - double precision
+    //                       vector of dimension limit, the first  last
+    //                       elements of which are the moduli of the absolute
+    //                       error estimates on the subintervals
+    //
+    //             iord    - integer
+    //                       vector of dimension at least limit, the first k
+    //                       elements of which are pointers to the error
+    //                       estimates over the subintervals, so that
+    //                       elist(iord(1)), ..., elist(iord(k)) with k = last
+    //                       if last.le.(limit/2+2), and k = limit+1-last
+    //                       otherwise, form a decreasing sequence
+    //
+    //             last    - integer
+    //                       number of subintervals actually produced in
+    //                       the subdivision process
+    //
+    // ***references  (none)
+    // ***routines called  d1mach,dqc25c,dqpsrt
+    // ***end prologue  dqawce
+    //
+    //             list of major variables
+    //             -----------------------
+    //
+    //            alist     - list of left end points of all subintervals
+    //                        considered up to now
+    //            blist     - list of right end points of all subintervals
+    //                        considered up to now
+    //            rlist(i)  - approximation to the integral over
+    //                        (alist(i),blist(i))
+    //            elist(i)  - error estimate applying to rlist(i)
+    //            maxerr    - pointer to the interval with largest
+    //                        error estimate
+    //            errmax    - elist(maxerr)
+    //            area      - sum of the integrals over the subintervals
+    //            errsum    - sum of the errors over the subintervals
+    //            errbnd    - requested accuracy max(epsabs,epsrel*
+    //                        abs(result))
+    //            *****1    - variable for the left subinterval
+    //            *****2    - variable for the right subinterval
+    //            last      - index for subdivision
+    //
+    //
+    //             machine dependent constants
+    //             ---------------------------
+    //
+    //            epmach is the largest relative spacing.
+    //            uflow is the smallest positive magnitude.
+    //
+    int iroff1, iroff2, k, krule, L, maxerr, nev, nrmax;
+    double a1, a2, aa, area, area1, area12, area2, b1, b2, bb, errbnd, errmax;
+    double error1, error12, error2, errsum;
+
+    *ier = 6;
+    *neval = 0;
+    *last = 0;
+    alist[0] = a;
+    blist[0] = b;
+    rlist[0] = 0.0;
+    elist[0] = 0.0;
+    iord[0] = 0;
+    *result = 0.0;
+    *abserr = 0.0;
+
+    if ((c == a) || (c == b) ||
+        ((epsabs <= 0.0) && (epsrel < fmax(50.0*epmach, 0.5e-28)))) { return; }
+    *ier = 0;
+    // First approximation to the integral
+    aa = (a > b ? b : a);
+    bb = (a > b ? a : b);
+
+    krule = 1;
+    dqc25c(fcn, aa, bb, c, result, abserr, &krule, neval);
+    *last = 1;
+    rlist[0] = *result;
+    elist[0] = *abserr;
+    iord[0] = 0;
+    alist[0] = a;
+    blist[0] = b;
+
+    // Test on accuracy.
+    errbnd = fmax(epsabs, epsrel * fabs(*result));
+    if (limit == 1) { *ier = 1; }
+    if ((*abserr < fmin(0.01*fabs(*result), errbnd)) || (*ier == 1))
+    {
+        // 70
+        if (aa == b) { *result = -(*result); }
+        return;
+    }
+
+    // Initialization
+    alist[0] = aa;
+    blist[0] = bb;
+    rlist[0] = *result;
+    errmax = *abserr;
+    maxerr = 0;
+    area = *result;
+    errsum = *abserr;
+    nrmax = 0;
+    iroff1 = 0;
+    iroff2 = 0;
+
+    // Main for-loop.
+    for (L = 1; L < limit; L++)
+    {
+        *last = L + 1;
+
+        // Bisect the subinterval with nrmax-th largest error estimate.
+        a1 = alist[maxerr];
+        b1 = 0.5*(alist[maxerr] + blist[maxerr]);
+        b2 = blist[maxerr];
+        if ((c <= b1) && (c > a1)) { b1 = 0.5 * (c + b2); }
+        if ((c >  b1) && (c < b2)) { b1 = 0.5 * (a1 + c); }
+        a2 = b1;
+        krule = 2;
+        dqc25c(fcn, a1, b1, c, &area1, &error1, &krule, &nev);
+        *neval += nev;
+        dqc25c(fcn, a2, b2, c, &area2, &error2, &krule, &nev);
+        *neval += nev;
+
+        // Improve previous approximations to integral and error and test for accuracy.
+        area12 = area1 + area2;
+        error12 = error1 + error2;
+        errsum = errsum + error12 - errmax;
+        area = area + area12 - rlist[maxerr];
+
+        if ((fabs(rlist[maxerr]-area12) < (1.0e-5*fabs(area12))) &&
+            (error12 >= 0.99 * errmax) && (krule == 0)) { iroff1++; }
+        if ((L > 9) && (error12 > errmax) && (krule == 0)) { iroff2++; }
+        rlist[maxerr] = area1;
+        rlist[L] = area2;
+        errbnd = fmax(epsabs, epsrel*fabs(area));
+        if (!(errsum <= errbnd))
+        {
+            // Test for roundoff error and eventually set error flag.
+            if ((iroff1 >= 6) && (iroff2 > 20)) { *ier = 2; }
+
+            // Set error flag in the case that number of interval bisections exceeds limit.
+            if (*last == limit) { *ier = 1; }
+
+            // Set error flag in the case of bad integrand behavior at a point
+            // of the integration range.
+            if (fmax(fabs(a1), fabs(b2)) <= (1.0 + 100.0*epmach)*(fabs(a2) + 1000.0*uflow)) { *ier = 3; }
+        }
+        // Append the newly-created intervals to the list.
+        if (!(error2 > error1))
+        {
+            alist[L] = a2;
+            blist[maxerr] = b1;
+            blist[L] = b2;
+            elist[maxerr] = error1;
+            elist[L] = error2;
+        } else {
+            alist[maxerr] = a2;
+            alist[L] = a1;
+            blist[L] = b1;
+            rlist[maxerr] = area2;
+            rlist[L] = area1;
+            elist[maxerr] = error2;
+            elist[L] = error1;
+        }
+        // 30
+
+        // Call subroutine dqpsrt to maintain the descending ordering in the
+        // list of error estimates and select the subinterval with nrmax-th
+        // largest error estimate (to be bisected next).
+        dqpsrt(limit, *last, &maxerr, &errmax, elist, iord, &nrmax);
+        if( (*ier != 0) || (errsum <= errbnd)) { break; }
+    }
+    // 50
+
+    *result = 0.0;
+    for (k = 0; k <= L; k++) {
+        *result = *result + rlist[k];
+    }
+    // 60
+
+    *abserr = errsum;
+    // 70
+    if (aa == b) { *result = -*result; }
+
+    return;
+}
+
+
+void
+dqawfe(double(*fcn)(double* x), const double a, const double omega, const int integr,
+       const double epsabs, const int limlst, const int limit, const int maxp1,
+       double* result, double* abserr, int* neval, int* ier, double* rslst,
+       double* erlst, int* ierlst, int* lst, double* alist, double* blist,
+       double* rlist, double* elist, int* iord, int* nnlog, double* chebmo)
+{
+    // ***begin prologue  dqawfe
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a3a1
+    // ***keywords  automatic integrator, special-purpose,
+    //              fourier integrals,
+    //              integration between zeros with dqawoe,
+    //              convergence acceleration with dqelg
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            dedoncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  the routine calculates an approximation result to a
+    //             given fourier integal
+    //             i = integral of f(x)*w(x) over (a,infinity)
+    //             where w(x)=cos(omega*x) or w(x)=sin(omega*x),
+    //             hopefully satisfying following claim for accuracy
+    //             abs(i-result).le.epsabs.
+    // ***description
+    //
+    //         computation of fourier integrals
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //          on entry
+    //             f      - double precision
+    //                      function subprogram defining the integrand
+    //                      function f(x). the actual name for f needs to
+    //                      be declared e x t e r n a l in the driver program.
+    //
+    //             a      - double precision
+    //                      lower limit of integration
+    //
+    //             omega  - double precision
+    //                      parameter in the weight function
+    //
+    //             integr - integer
+    //                      indicates which weight function is used
+    //                      integr = 1      w(x) = cos(omega*x)
+    //                      integr = 2      w(x) = sin(omega*x)
+    //                      if integr.ne.1.and.integr.ne.2, the routine will
+    //                      end with ier = 6.
+    //
+    //             epsabs - double precision
+    //                      absolute accuracy requested, epsabs.gt.0
+    //                      if epsabs.le.0, the routine will end with ier = 6.
+    //
+    //             limlst - integer
+    //                      limlst gives an upper bound on the number of
+    //                      cycles, limlst.ge.1.
+    //                      if limlst.lt.3, the routine will end with ier = 6.
+    //
+    //             limit  - integer
+    //                      gives an upper bound on the number of subintervals
+    //                      allowed in the partition of each cycle, limit.ge.1
+    //                      each cycle, limit.ge.1.
+    //
+    //             maxp1  - integer
+    //                      gives an upper bound on the number of
+    //                      chebyshev moments which can be stored, i.e.
+    //                      for the intervals of lengths abs(b-a)*2**(-l),
+    //                      l=0,1, ..., maxp1-2, maxp1.ge.1
+    //
+    //          on return
+    //             result - double precision
+    //                      approximation to the integral x
+    //
+    //             abserr - double precision
+    //                      estimate of the modulus of the absolute error,
+    //                      which should equal or exceed abs(i-result)
+    //
+    //             neval  - integer
+    //                      number of integrand evaluations
+    //
+    //             ier    - ier = 0 normal and reliable termination of
+    //                              the routine. it is assumed that the
+    //                              requested accuracy has been achieved.
+    //                      ier.gt.0 abnormal termination of the routine. the
+    //                              estimates for integral and error are less
+    //                              reliable. it is assumed that the requested
+    //                              accuracy has not been achieved.
+    //             error messages
+    //                     if omega.ne.0
+    //                      ier = 1 maximum number of  cycles  allowed
+    //                              has been achieved., i.e. of subintervals
+    //                              (a+(k-1)c,a+kc) where
+    //                              c = (2*int(abs(omega))+1)*pi/abs(omega),
+    //                              for k = 1, 2, ..., lst.
+    //                              one can allow more cycles by increasing
+    //                              the value of limlst (and taking the
+    //                              according dimension adjustments into
+    //                              account).
+    //                              examine the array iwork which contains
+    //                              the error flags on the cycles, in order to
+    //                              look for eventual local integration
+    //                              difficulties. if the position of a local
+    //                              difficulty can be determined (e.g.
+    //                              singularity, discontinuity within the
+    //                              interval) one will probably gain from
+    //                              splitting up the interval at this point
+    //                              and calling appropriate integrators on
+    //                              the subranges.
+    //                          = 4 the extrapolation table constructed for
+    //                              convergence acceleration of the series
+    //                              formed by the integral contributions over
+    //                              the cycles, does not converge to within
+    //                              the requested accuracy. as in the case of
+    //                              ier = 1, it is advised to examine the
+    //                              array iwork which contains the error
+    //                              flags on the cycles.
+    //                          = 6 the input is invalid because
+    //                              (integr.ne.1 and integr.ne.2) or
+    //                               epsabs.le.0 or limlst.lt.3.
+    //                               result, abserr, neval, lst are set
+    //                               to zero.
+    //                          = 7 bad integrand behaviour occurs within one
+    //                              or more of the cycles. location and type
+    //                              of the difficulty involved can be
+    //                              determined from the vector ierlst. here
+    //                              lst is the number of cycles actually
+    //                              needed (see below).
+    //                              ierlst(k) = 1 the maximum number of
+    //                                            subdivisions (= limit) has
+    //                                            been achieved on the k th
+    //                                            cycle.
+    //                                        = 2 occurrence of roundoff error
+    //                                            is detected and prevents the
+    //                                            tolerance imposed on the
+    //                                            k th cycle, from being
+    //                                            achieved.
+    //                                        = 3 extremely bad integrand
+    //                                            behaviour occurs at some
+    //                                            points of the k th cycle.
+    //                                        = 4 the integration procedure
+    //                                            over the k th cycle does
+    //                                            not converge (to within the
+    //                                            required accuracy) due to
+    //                                            roundoff in the
+    //                                            extrapolation procedure
+    //                                            invoked on this cycle. it
+    //                                            is assumed that the result
+    //                                            on this interval is the
+    //                                            best which can be obtained.
+    //                                        = 5 the integral over the k th
+    //                                            cycle is probably divergent
+    //                                            or slowly convergent. it
+    //                                            must be noted that
+    //                                            divergence can occur with
+    //                                            any other value of
+    //                                            ierlst(k).
+    //                     if omega = 0 and integr = 1,
+    //                     the integral is calculated by means of dqagie
+    //                     and ier = ierlst(1) (with meaning as described
+    //                     for ierlst(k), k = 1).
+    //
+    //             rslst  - double precision
+    //                      vector of dimension at least limlst
+    //                      rslst(k) contains the integral contribution
+    //                      over the interval (a+(k-1)c,a+kc) where
+    //                      c = (2*int(abs(omega))+1)*pi/abs(omega),
+    //                      k = 1, 2, ..., lst.
+    //                      note that, if omega = 0, rslst(1) contains
+    //                      the value of the integral over (a,infinity).
+    //
+    //             erlst  - double precision
+    //                      vector of dimension at least limlst
+    //                      erlst(k) contains the error estimate corresponding
+    //                      with rslst(k).
+    //
+    //             ierlst - integer
+    //                      vector of dimension at least limlst
+    //                      ierlst(k) contains the error flag corresponding
+    //                      with rslst(k). for the meaning of the local error
+    //                      flags see description of output parameter ier.
+    //
+    //             lst    - integer
+    //                      number of subintervals needed for the integration
+    //                      if omega = 0 then lst is set to 1.
+    //
+    //             alist, blist, rlist, elist - double precision
+    //                      vector of dimension at least limit,
+    //
+    //             iord, nnlog - integer
+    //                      vector of dimension at least limit, providing
+    //                      space for the quantities needed in the subdivision
+    //                      process of each cycle
+    //
+    //             chebmo - double precision
+    //                      array of dimension at least (maxp1,25), providing
+    //                      space for the chebyshev moments needed within the
+    //                      cycles
+    //
+    // ***references  (none)
+    // ***routines called  d1mach,dqagie,dqawoe,dqelg
+    // ***end prologue  dqawfe
+    //
+    //
+    //             the dimension of  psum  is determined by the value of
+    //             limexp in subroutine dqelg (psum must be of dimension
+    //             (limexp+2) at least).
+    //
+    //            list of major variables
+    //            -----------------------
+    //
+    //            c1, c2    - end points of subinterval (of length cycle)
+    //            cycle     - (2*int(abs(omega))+1)*pi/abs(omega)
+    //            psum      - vector of dimension at least (limexp+2)
+    //                        (see routine dqelg)
+    //                        psum contains the part of the epsilon table
+    //                        which is still needed for further computations.
+    //                        each element of psum is a partial sum of the
+    //                        series which should sum to the value of the
+    //                        integral.
+    //            errsum    - sum of error estimates over the subintervals,
+    //                        calculated cumulatively
+    //            epsa      - absolute tolerance requested over current
+    //                        subinterval
+    //            chebmo    - array containing the modified chebyshev
+    //                        moments (see also routine dqc25f)
+    //
+    int ktmin, l, last, ll, iter, momcom, nev, nres, numrl2;
+    double abseps, correc, cycle, c1, c2, dl, drl, ep, eps, epsa;
+    double errsum, fact, p1, reseps;
+    double psum[52], res3la[3] = {0.0};
+    const double p = 0.9;
+    const double pi = 3.14159265358979323846264338327950;
+
+    // Test on validity of parameters.
+    *result = 0;
+    *abserr = 0;
+    *neval = 0;
+    *lst = 0;
+    *ier = 6;
+    if (((integr != 1) && (integr != 2)) || (epsabs <= 0.0) || (limlst < 3)) { return; }
+    *ier = 0;
+
+    if (omega == 0.0)
+    {
+        // Integration by dqagie if omega is zero.
+        if (integr == 1)
+        {
+            dqagie(fcn, 0.0, 1.0, epsabs, 0.0, limit, result, abserr, neval, ier,
+                   alist, blist, rlist, elist, iord, &last);
+        }
+        rslst[0] = *result;
+        erlst[0] = *abserr;
+        ierlst[0] = *ier;
+        *lst = 1;
+        return;
+    }
+
+    // Initializations.
+    l = (int)(fabs(omega));
+    dl = 2*l + 1.0;
+    cycle = dl*pi / fabs(omega);
+    *ier = 0;
+    ktmin = 0;
+    *neval = 0;
+    numrl2 = -1;
+    nres = 0;
+    c1 = a;
+    c2 = cycle + a;
+    p1 = 1.0 - p;
+    eps = (epsabs > (uflow / p1) ? epsabs*p1 : epsabs);
+    ep = eps;
+    fact = 1.0;
+    correc = 0.0;
+    *abserr = 0.0;
+    errsum = 0.0;
+    ll = 0;  // Initialized
+
+    // Main for-loop
+    for (iter = 0; iter < limlst; iter++)
+    {
+        *lst = iter + 1;
+
+        epsa = eps*fact;
+        dqawoe(fcn, c1, c2, omega, integr, epsa, 0.0, limit, *lst, maxp1,
+               &rslst[iter], &erlst[iter], &nev, &ierlst[iter], &last,
+               alist, blist, rlist, elist, iord, nnlog, &momcom, chebmo);
+
+        *neval += nev;
+        fact = fact*p;
+        errsum = errsum + erlst[iter];
+        drl = 50.0*fabs(rslst[iter]);
+
+        // Test on accuracy with partial sum
+        if (((errsum + drl) <= epsabs) && (iter >= 5)) { goto LINE80; }
+        correc = fmax(correc, erlst[iter]);
+        if (ierlst[iter] != 0)
+        {
+            eps = fmax(ep, correc*p1);
+            *ier = 7;
+        }
+        if ((*ier == 7) && ((errsum + drl) <= (correc * 10.0)) && (iter > 4)) { goto LINE80; }
+        numrl2 += 1;
+        if (iter > 0) { goto LINE20; }
+        psum[0] = rslst[0];
+        goto LINE40;
+LINE20:
+        psum[numrl2] = psum[ll] + rslst[iter];
+        if (iter == 1) { goto LINE40; }
+
+        // Test on maximum number of subintervals.
+        if (*lst == limlst) { *ier = 1; }
+
+        // Perform new extrapolation.
+        dqelg(&numrl2, psum, &reseps, &abseps, res3la, &nres);
+
+        // Test whether extrapolated result is influenced by roundouff.
+        ktmin += 1;
+        if ((ktmin >= 15) && (*abserr <= 0.001*(errsum + drl))) { *ier = 4; }
+        if ((abseps > *abserr) && (iter != 2)) { goto LINE30; }
+        *abserr = abseps;
+        *result = reseps;
+        ktmin = 0;
+
+        // If ier is not zero, check whether direct result (partial sum) or
+        // extrapolated result yields the best integral approximation.
+        if (((*abserr + 10.0*correc) <= epsabs) ||
+            ((*abserr <= epsabs) && (10.0*correc >= epsabs))) { goto LINE60; }
+LINE30:
+        if ((*ier != 0) && (*ier != 7)) { goto LINE60; }
+LINE40:
+        ll = numrl2;
+        c1 = c2;
+        c2 = c2 + cycle;
+    }
+    // 50
+
+    // Set final result and error estimate.
+LINE60:
+    *abserr = *abserr + 10.0*correc;
+    if (*ier == 0) { return; }
+    if ((*result != 0.0) && (psum[numrl2] != 0.0)) { goto LINE70; }
+    if (*abserr > errsum) { goto LINE80; }
+    if (psum[numrl2] == 0.0) { return; }
+LINE70:
+    if ((*abserr / fabs(*result) > (errsum+drl) / fabs(psum[numrl2]))) { goto LINE80; }
+    if ((*ier >= 1) && (*ier != 7)) { *abserr = *abserr + drl; }
+    return;
+LINE80:
+    *result = psum[numrl2];
+    *abserr = errsum + drl;
+
+    return;
+}
+
+
+void
+dqawoe(double(*fcn)(double* x), const double a, const double b, const double omega,
+       const int integr, const double epsabs, const double epsrel, const int limit,
+       const int icall, const int maxp1, double* result, double* abserr, int* neval,
+       int* ier, int* last, double* alist, double* blist, double* rlist,
+       double* elist, int* iord, int* nnlog, int* momcom, double* chebmo)
+{
+    //***begin prologue  dqawoe
+    //***date written   800101   (yymmdd)
+    //***revision date  830518   (yymmdd)
+    //***category no.  h2a2a1
+    //***keywords  automatic integrator, special-purpose,
+    //             integrand with oscillatory cos or sin factor,
+    //             clenshaw-curtis method, (end point) singularities,
+    //             extrapolation, globally adaptive
+    //***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //           de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    //***purpose  the routine calculates an approximation result to a given
+    //            definite integral
+    //            i = integral of f(x)*w(x) over (a,b)
+    //            where w(x) = cos(omega*x) or w(x)=sin(omega*x),
+    //            hopefully satisfying following claim for accuracy
+    //            abs(i-result).le.max(epsabs,epsrel*abs(i)).
+    //***description
+    //
+    //        computation of oscillatory integrals
+    //        standard fortran subroutine
+    //        double precision version
+    //
+    //        parameters
+    //         on entry
+    //            f      - double precision
+    //                     function subprogram defining the integrand
+    //                     function f(x). the actual name for f needs to be
+    //                     declared e x t e r n a l in the driver program.
+    //
+    //            a      - double precision
+    //                     lower limit of integration
+    //
+    //            b      - double precision
+    //                     upper limit of integration
+    //
+    //            omega  - double precision
+    //                     parameter in the integrand weight function
+    //
+    //            integr - integer
+    //                     indicates which of the weight functions is to be
+    //                     used
+    //                     integr = 1      w(x) = cos(omega*x)
+    //                     integr = 2      w(x) = sin(omega*x)
+    //                     if integr.ne.1 and integr.ne.2, the routine
+    //                     will end with ier = 6.
+    //
+    //            epsabs - double precision
+    //                     absolute accuracy requested
+    //            epsrel - double precision
+    //                     relative accuracy requested
+    //                     if  epsabs.le.0
+    //                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+    //                     the routine will end with ier = 6.
+    //
+    //            limit  - integer
+    //                     gives an upper bound on the number of subdivisions
+    //                     in the partition of (a,b), limit.ge.1.
+    //
+    //            icall  - integer
+    //                     if dqawoe is to be used only once, icall must
+    //                     be set to 1.  assume that during this call, the
+    //                     chebyshev moments (for clenshaw-curtis integration
+    //                     of degree 24) have been computed for intervals of
+    //                     lengths (abs(b-a))*2**(-l), l=0,1,2,...momcom-1.
+    //                     if icall.gt.1 this means that dqawoe has been
+    //                     called twice or more on intervals of the same
+    //                     length abs(b-a). the chebyshev moments already
+    //                     computed are then re-used in subsequent calls.
+    //                     if icall.lt.1, the routine will end with ier = 6.
+    //
+    //            maxp1  - integer
+    //                     gives an upper bound on the number of chebyshev
+    //                     moments which can be stored, i.e. for the
+    //                     intervals of lengths abs(b-a)*2**(-l),
+    //                     l=0,1, ..., maxp1-2, maxp1.ge.1.
+    //                     if maxp1.lt.1, the routine will end with ier = 6.
+    //
+    //         on return
+    //            result - double precision
+    //                     approximation to the integral
+    //
+    //            abserr - double precision
+    //                     estimate of the modulus of the absolute error,
+    //                     which should equal or exceed abs(i-result)
+    //
+    //            neval  - integer
+    //                     number of integrand evaluations
+    //
+    //            ier    - integer
+    //                     ier = 0 normal and reliable termination of the
+    //                             routine. it is assumed that the
+    //                             requested accuracy has been achieved.
+    //                   - ier.gt.0 abnormal termination of the routine.
+    //                             the estimates for integral and error are
+    //                             less reliable. it is assumed that the
+    //                             requested accuracy has not been achieved.
+    //            error messages
+    //                     ier = 1 maximum number of subdivisions allowed
+    //                             has been achieved. one can allow more
+    //                             subdivisions by increasing the value of
+    //                             limit (and taking according dimension
+    //                             adjustments into account). however, if
+    //                             this yields no improvement it is advised
+    //                             to analyze the integrand, in order to
+    //                             determine the integration difficulties.
+    //                             if the position of a local difficulty can
+    //                             be determined (e.g. singularity,
+    //                             discontinuity within the interval) one
+    //                             will probably gain from splitting up the
+    //                             interval at this point and calling the
+    //                             integrator on the subranges. if possible,
+    //                             an appropriate special-purpose integrator
+    //                             should be used which is designed for
+    //                             handling the type of difficulty involved.
+    //                         = 2 the occurrence of roundoff error is
+    //                             detected, which prevents the requested
+    //                             tolerance from being achieved.
+    //                             the error may be under-estimated.
+    //                         = 3 extremely bad integrand behaviour occurs
+    //                             at some points of the integration
+    //                             interval.
+    //                         = 4 the algorithm does not converge.
+    //                             roundoff error is detected in the
+    //                             extrapolation table.
+    //                             it is presumed that the requested
+    //                             tolerance cannot be achieved due to
+    //                             roundoff in the extrapolation table,
+    //                             and that the returned result is the
+    //                             best which can be obtained.
+    //                         = 5 the integral is probably divergent, or
+    //                             slowly convergent. it must be noted that
+    //                             divergence can occur with any other value
+    //                             of ier.gt.0.
+    //                         = 6 the input is invalid, because
+    //                             (epsabs.le.0 and
+    //                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
+    //                             or (integr.ne.1 and integr.ne.2) or
+    //                             icall.lt.1 or maxp1.lt.1.
+    //                             result, abserr, neval, last, rlist(1),
+    //                             elist(1), iord(1) and nnlog(1) are set
+    //                             to zero. alist(1) and blist(1) are set
+    //                             to a and b respectively.
+    //
+    //            last  -  integer
+    //                     on return, last equals the number of
+    //                     subintervals produces in the subdivision
+    //                     process, which determines the number of
+    //                     significant elements actually in the
+    //                     work arrays.
+    //            alist  - double precision
+    //                     vector of dimension at least limit, the first
+    //                      last  elements of which are the left
+    //                     end points of the subintervals in the partition
+    //                     of the given integration range (a,b)
+    //
+    //            blist  - double precision
+    //                     vector of dimension at least limit, the first
+    //                      last  elements of which are the right
+    //                     end points of the subintervals in the partition
+    //                     of the given integration range (a,b)
+    //
+    //            rlist  - double precision
+    //                     vector of dimension at least limit, the first
+    //                      last  elements of which are the integral
+    //                     approximations on the subintervals
+    //
+    //            elist  - double precision
+    //                     vector of dimension at least limit, the first
+    //                      last  elements of which are the moduli of the
+    //                     absolute error estimates on the subintervals
+    //
+    //            iord   - integer
+    //                     vector of dimension at least limit, the first k
+    //                     elements of which are pointers to the error
+    //                     estimates over the subintervals,
+    //                     such that elist(iord(1)), ...,
+    //                     elist(iord(k)) form a decreasing sequence, with
+    //                     k = last if last.le.(limit/2+2), and
+    //                     k = limit+1-last otherwise.
+    //
+    //            nnlog  - integer
+    //                     vector of dimension at least limit, containing the
+    //                     subdivision levels of the subintervals, i.e.
+    //                     iwork(i) = l means that the subinterval
+    //                     numbered i is of length abs(b-a)*2**(1-l)
+    //
+    //         on entry and return
+    //            momcom - integer
+    //                     indicating that the chebyshev moments
+    //                     have been computed for intervals of lengths
+    //                     (abs(b-a))*2**(-l), l=0,1,2, ..., momcom-1,
+    //                     momcom.lt.maxp1
+    //
+    //            chebmo - double precision
+    //                     array of dimension (maxp1,25) containing the
+    //                     chebyshev moments
+    //
+    //***references  (none)
+    //***routines called  d1mach,dqc25f,dqelg,dqpsrt
+    //***end prologue  dqawoe
+    //
+    //            the dimension of rlist2 is determined by  the value of
+    //            limexp in subroutine dqelg (rlist2 should be of
+    //            dimension (limexp+2) at least).
+    //
+    //            list of major variables
+    //            -----------------------
+    //
+    //           alist     - list of left end points of all subintervals
+    //                       considered up to now
+    //           blist     - list of right end points of all subintervals
+    //                       considered up to now
+    //           rlist(i)  - approximation to the integral over
+    //                       (alist(i),blist(i))
+    //           rlist2    - array of dimension at least limexp+2
+    //                       containing the part of the epsilon table
+    //                       which is still needed for further computations
+    //           elist(i)  - error estimate applying to rlist(i)
+    //           maxerr    - pointer to the interval with largest
+    //                       error estimate
+    //           errmax    - elist(maxerr)
+    //           erlast    - error on the interval currently subdivided
+    //           area      - sum of the integrals over the subintervals
+    //           errsum    - sum of the errors over the subintervals
+    //           errbnd    - requested accuracy max(epsabs,epsrel*
+    //                       abs(result))
+    //           *****1    - variable for the left subinterval
+    //           *****2    - variable for the right subinterval
+    //           last      - index for subdivision
+    //           nres      - number of calls to the extrapolation routine
+    //           numrl2    - number of elements in rlist2. if an appropriate
+    //                       approximation to the compounded integral has
+    //                       been obtained it is put in rlist2(numrl2) after
+    //                       numrl2 has been increased by one
+    //           small     - length of the smallest interval considered
+    //                       up to now, multiplied by 1.5
+    //           erlarg    - sum of the errors over the intervals larger
+    //                       than the smallest interval considered up to now
+    //           extrap    - logical variable denoting that the routine is
+    //                       attempting to perform extrapolation, i.e. before
+    //                       subdividing the smallest interval we try to
+    //                       decrease the value of erlarg
+    //           noext     - logical variable denoting that extrapolation
+    //                       is no longer allowed (true  value)
+    //
+    //            machine dependent constants
+    //            ---------------------------
+    //
+    //           epmach is the largest relative spacing.
+    //           uflow is the smallest positive magnitude.
+    //           oflow is the largest positive magnitude.
+    //
+    int extrap, extall, ierror, iroff1, iroff2, iroff3, jupbnd, k, ksgn;
+    int ktmin, L, maxerr, nev, noext, nres, nrmax, nrmom, numrl2;
+    double abseps, area, area1, area12, area2, a1, a2, b1, b2, correc, defab1;
+    double defab2, defabs, domega, dres, erlarg, erlast, errbnd, errmax, error1;
+    double error12, error2, errsum, ertest, resabs, reseps, small, width;
+    double rlist2[52], res3la[3];
+
+    // last and limit, actual and max allowed no. of subintervals, are not
+    // indices, however used as such. We use L for "last"-indexed arrays
+
+    *ier = 6;
+    *neval = 0;
+    *last = 0;
+    *result = 0.0;
+    *abserr = 0.0;
+    alist[0] = a;
+    blist[0] = b;
+    rlist[0] = 0.0;
+    elist[0] = 0.0;
+    iord[0] = 0;
+    nnlog[0] = 0;
+
+    if (((integr != 1) && (integr != 2)) ||
+        ((epsabs <= 0.0) && (epsrel < fmax(50.0*epmach, 0.5e-28))) ||
+        (icall < 1) || (maxp1 < 1)) { return; }
+    *ier = 0;
+
+    // First approximation to the integral
+
+    domega = fabs(omega);
+    nrmom = 0;
+    if (icall < 2) { *momcom = 0; }
+    dqc25f(fcn, a, b, domega, integr, nrmom, maxp1, 0, result, abserr, neval, &defabs, &resabs, momcom, chebmo);
+
+    // Test on accuracy
+    dres = fabs(*result);
+    errbnd = fmax(epsabs, epsrel*dres);
+    rlist[0] = *result;
+    elist[0] = *abserr;
+    iord[0] = 0;
+
+    if ((*abserr <= 100.0*epmach * defabs) && (*abserr > errbnd)) { *ier = 2; }
+    if (limit == 1) { *ier = 1; }
+    if ((*ier != 0) || (*abserr <= errbnd))
+    {
+        // 200
+        if ((integr == 2) && (omega < 0.0)) { *result= -*result; }
+        return;
+    }
+
+    // Initializations
+    errmax = *abserr;
+    maxerr = 0;
+    area = *result;
+    errsum = *abserr;
+    *abserr = oflow;
+    nrmax = 0;
+    extrap = 0;
+    noext = 0;
+    ierror = 0;
+    iroff1 = 0;
+    iroff2 = 0;
+    iroff3 = 0;
+    ktmin = 0;
+    small = fabs(b - a)*0.75;
+    nres = 0;
+    numrl2 = -1;
+    extall = 0;
+
+    correc = 0.0;  // Initialized
+    erlarg = 0.0;  // Initialized
+    ertest = 0.0;  // Initialized
+
+    if ((0.5*fabs(b - a)*domega) <= 2.0)
+    {
+        numrl2 = 0;
+        extall = 1;
+        rlist2[0] = *result;
+    } else if ((0.25*fabs(b - a)*domega) <= 2.0) {
+        extall = 1;
+    }
+    ksgn = (dres >= (1.0 - 50.0*epmach)*defabs ? 1 : -1);
+
+    // Main for-loop.
+    for (L = 1; L < limit; L++)
+    {
+        *last = L + 1;
+
+        // Bisect the subinterval with the nrmax-th largest error estimate.
+        nrmom = nnlog[maxerr] + 1;
+        a1 = alist[maxerr];
+        b1 = 0.5*(alist[maxerr] + blist[maxerr]);
+        a2 = b1;
+        b2 = blist[maxerr];
+        erlast = errmax;
+        dqc25f(fcn, a1, b1, domega, integr, nrmom, maxp1, 0, &area1, &error1, &nev, &resabs, &defab1, momcom, chebmo);
+        *neval += nev;
+        dqc25f(fcn, a2, b2, domega, integr, nrmom, maxp1, 1, &area2, &error2, &nev, &resabs, &defab2, momcom, chebmo);
+        *neval += nev;
+
+        // Improve previous approximations to integral and error and test for accuracy.
+        area12 = area1 + area2;
+        error12 = error1 + error2;
+        errsum = errsum + error12 - errmax;
+        area = area + area12 - rlist[maxerr];
+        if ((defab1 != error1) && (defab2 != error2))
+        {
+            if (!((fabs(rlist[maxerr] - area12) > 1.0e-5*fabs(area12)) || (error12 < 0.99*errmax)))
+            {
+                if (extrap) { iroff2++; } else { iroff1++; }
+            }
+            // 20
+            if ((L > 9) && (error12 > errmax)) { iroff3++; }
+        }
+        // 25
+
+        rlist[maxerr] = area1;
+        rlist[L] = area2;
+        nnlog[maxerr] = nrmom;
+        nnlog[L] = nrmom;
+        errbnd = fmax(epsabs, epsrel*fabs(area));
+
+        // Test for roundoff eerror and eventually set error flag.
+        if ((iroff1 + iroff2 >= 10) || iroff3 >= 20) { *ier = 2; }
+        if (iroff2 >= 5) { ierror = 3; }
+
+        // Set error flag in the case that the number of subintervals equals limit.
+        if (*last == limit) { *ier = 1; }
+
+        // Set error flag in the case of bad integrand behavior at a point of the integration range.
+        if (fmax(fabs(a1), fabs(b2)) <= (1.0 + 100.0*epmach)*(fabs(a2) + 1.0e3*epmach)) { *ier = 4; }
+
+        // Append the newly-created intervals to the list.
+        if (!(error2 > error1))
+        {
+            alist[L] = a2;
+            blist[maxerr] = b1;
+            blist[L] = b2;
+            elist[maxerr] = error1;
+            elist[L] = error2;
+        } else {
+            alist[maxerr] = a2;
+            alist[L] = a1;
+            blist[L] = b1;
+            rlist[maxerr] = area2;
+            rlist[L] = area1;
+            elist[maxerr] = error2;
+            elist[L] = error1;
+        }
+        // 40
+
+        // Call subroutine dqpsrt to maintain the descending ordering in the list
+        // of error estimates and select the subinterval with nrmax-th error
+        // estimate (to bisected next).
+        dqpsrt(limit, *last, &maxerr, &errmax, elist, iord, &nrmax);
+
+        if (errsum <= errbnd) { goto LINE170; }
+        if (*ier != 0) { break; }
+        if ((L == 1) && (extall)) { goto LINE120; }
+        if (noext) { continue; }
+        if (!extall) { goto LINE50; }
+        erlarg = erlarg - erlast;
+        if (fabs(b1 - a1) > small) { erlarg = erlarg + error12; }
+        if (extrap) { goto LINE70; }
+LINE50:
+        // Test whether the interval to be bisected next is the smallest interval.
+        width = fabs(blist[maxerr] - alist[maxerr]);
+        if (width > small) { continue; }
+        if (!(extall))
+        {
+            // Test whether we can start with the extrapolation procedure (we do
+            // this if we integrate over the next interval with use of a
+            // Gauss-Kronrod rule - see dqc25f).
+            small = small*0.5;
+            if (0.25*width*domega > 2.0) { continue; }
+            extall = 1;
+            goto LINE130;
+        }
+        // 60
+        extrap = 1;
+        nrmax = 1;
+LINE70:
+        if ((ierror == 3) || (erlarg <= ertest)) { goto LINE90; }
+
+        // The smallest interval has the largest error. Before bisecting, decrease
+        // the sum of the erorrs over the larger intervals (erlarg) and perform
+        // extrapolation.
+        jupbnd = (*last > (limit/2 + 2) ? limit + 2 - *last : L);
+
+        for (k = nrmax; k <= jupbnd; k++) {
+            maxerr = iord[nrmax];
+            errmax = elist[maxerr];
+            if (fabs(blist[maxerr] - alist[maxerr]) > small) { goto LINE140; }
+            nrmax++;
+        }
+        // 80
+LINE90:
+        // Perform extrapolation.
+        numrl2++;
+        rlist2[numrl2] = area;
+        if (numrl2 < 2) { goto LINE110; }
+        dqelg(&numrl2, rlist2, &reseps, &abseps, res3la, &nres);
+        ktmin++;
+        if ((ktmin > 5) && (*abserr < 1.0e-3 * errsum)) { *ier = 5; }
+        if (abseps >= *abserr) { goto LINE100; }
+        ktmin = 0;
+        *abserr = abseps;
+        *result = reseps;
+        correc = erlarg;
+        ertest = fmax(epsabs, epsrel * fabs(reseps));
+        if (*abserr <= ertest) { break; }
+LINE100:
+        // Prepare bisection of the smallest interval
+        if (numrl2 == 0) { noext = 1; }
+        if (*ier == 5) { break; }
+LINE110:
+        maxerr = iord[0];
+        errmax = elist[maxerr];
+        nrmax = 0;
+        extrap = 0;
+        small = small*0.5;
+        erlarg = errsum;
+        continue;
+LINE120:
+        small = small*0.5;
+        numrl2++;
+        rlist2[numrl2] = area;
+LINE130:
+        ertest = errbnd;
+        erlarg = errsum;
+LINE140:
+        ;  // no-op.
+    }
+    // 140
+
+    // Set the final result.
+    if ((*abserr == oflow) || (nres == 0)) { goto LINE170; }
+    if ((*ier + ierror) == 0) { goto LINE165; }
+    if (ierror == 3) { *abserr = *abserr + correc; }
+    if (*ier == 0) { *ier = 3; }
+    if ((*result != 0.0) && (area != 0.0)) { goto LINE160;}
+    if (*abserr > errsum) { goto LINE170; }
+    if (area == 0.0) { goto LINE190; }
+    goto LINE165;
+LINE160:
+    if ((*abserr/fabs(*result)) > errsum/fabs(area)) { goto LINE170; }
+LINE165:
+    // Test on divergence.
+    if ((ksgn == -1) && (fmax(fabs(*result), fabs(area)) <= defabs*0.01)) { goto LINE190; }
+    if ((0.01 > *result/area) || (*result/area > 100.0) || (errsum >= fabs(area))) { *ier = 6; }
+    goto LINE190;
+LINE170:
+    // Compute global integral sum.
+    *result = 0.0;
+    for (k = 0; k <= L; k++)
+    {
+        *result = *result + rlist[k];
+    }
+    // 180
+    *abserr = errsum;
+LINE190:
+    if (*ier > 2) { *ier -= 1;}
+    if ((integr == 2) && (omega < 0.0)) { *result= -*result; }
+
+    return;
+}
+
+
+void
+dqawse(double(*fcn)(double* x), const double a, const double b, const double alfa,
+       const double beta, const int integr, const double epsabs, const double epsrel,
+       const int limit, double* result, double* abserr, int* neval, int* ier,
+       double* alist, double* blist, double* rlist, double* elist, int* iord,
+       int* last)
+{
+    // ***begin prologue  dqawse
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a2a1
+    // ***keywords  automatic integrator, special-purpose,
+    //              algebraico-logarithmic end point singularities,
+    //              clenshaw-curtis method
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  the routine calculates an approximation result to a given
+    //             definite integral i = integral of f*w over (a,b),
+    //             (where w shows a singular behaviour at the end points,
+    //             see parameter integr).
+    //             hopefully satisfying following claim for accuracy
+    //             abs(i-result).le.max(epsabs,epsrel*abs(i)).
+    // ***description
+    //
+    //         integration of functions having algebraico-logarithmic
+    //         end point singularities
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //          on entry
+    //             f      - double precision
+    //                      function subprogram defining the integrand
+    //                      function f(x). the actual name for f needs to be
+    //                      declared e x t e r n a l in the driver program.
+    //
+    //             a      - double precision
+    //                      lower limit of integration
+    //
+    //             b      - double precision
+    //                      upper limit of integration, b.gt.a
+    //                      if b.le.a, the routine will end with ier = 6.
+    //
+    //             alfa   - double precision
+    //                      parameter in the weight function, alfa.gt.(-1)
+    //                      if alfa.le.(-1), the routine will end with
+    //                      ier = 6.
+    //
+    //             beta   - double precision
+    //                      parameter in the weight function, beta.gt.(-1)
+    //                      if beta.le.(-1), the routine will end with
+    //                      ier = 6.
+    //
+    //             integr - integer
+    //                      indicates which weight function is to be used
+    //                      = 1  (x-a)**alfa*(b-x)**beta
+    //                      = 2  (x-a)**alfa*(b-x)**beta*log(x-a)
+    //                      = 3  (x-a)**alfa*(b-x)**beta*log(b-x)
+    //                      = 4  (x-a)**alfa*(b-x)**beta*log(x-a)*log(b-x)
+    //                      if integr.lt.1 or integr.gt.4, the routine
+    //                      will end with ier = 6.
+    //
+    //             epsabs - double precision
+    //                      absolute accuracy requested
+    //             epsrel - double precision
+    //                      relative accuracy requested
+    //                      if  epsabs.le.0
+    //                      and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+    //                      the routine will end with ier = 6.
+    //
+    //             limit  - integer
+    //                      gives an upper bound on the number of subintervals
+    //                      in the partition of (a,b), limit.ge.2
+    //                      if limit.lt.2, the routine will end with ier = 6.
+    //
+    //          on return
+    //             result - double precision
+    //                      approximation to the integral
+    //
+    //             abserr - double precision
+    //                      estimate of the modulus of the absolute error,
+    //                      which should equal or exceed abs(i-result)
+    //
+    //             neval  - integer
+    //                      number of integrand evaluations
+    //
+    //             ier    - integer
+    //                      ier = 0 normal and reliable termination of the
+    //                              routine. it is assumed that the requested
+    //                              accuracy has been achieved.
+    //                      ier.gt.0 abnormal termination of the routine
+    //                              the estimates for the integral and error
+    //                              are less reliable. it is assumed that the
+    //                              requested accuracy has not been achieved.
+    //             error messages
+    //                          = 1 maximum number of subdivisions allowed
+    //                              has been achieved. one can allow more
+    //                              subdivisions by increasing the value of
+    //                              limit. however, if this yields no
+    //                              improvement, it is advised to analyze the
+    //                              integrand in order to determine the
+    //                              integration difficulties which prevent the
+    //                              requested tolerance from being achieved.
+    //                              in case of a jump discontinuity or a local
+    //                              singularity of algebraico-logarithmic type
+    //                              at one or more interior points of the
+    //                              integration range, one should proceed by
+    //                              splitting up the interval at these
+    //                              points and calling the integrator on the
+    //                              subranges.
+    //                          = 2 the occurrence of roundoff error is
+    //                              detected, which prevents the requested
+    //                              tolerance from being achieved.
+    //                          = 3 extremely bad integrand behaviour occurs
+    //                              at some points of the integration
+    //                              interval.
+    //                          = 6 the input is invalid, because
+    //                              b.le.a or alfa.le.(-1) or beta.le.(-1), or
+    //                              integr.lt.1 or integr.gt.4, or
+    //                              (epsabs.le.0 and
+    //                               epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+    //                              or limit.lt.2.
+    //                              result, abserr, neval, rlist(1), elist(1),
+    //                              iord(1) and last are set to zero. alist(1)
+    //                              and blist(1) are set to a and b
+    //                              respectively.
+    //
+    //             alist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the left
+    //                      end points of the subintervals in the partition
+    //                      of the given integration range (a,b)
+    //
+    //             blist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the right
+    //                      end points of the subintervals in the partition
+    //                      of the given integration range (a,b)
+    //
+    //             rlist  - double precision
+    //                      vector of dimension at least limit,the first
+    //                       last  elements of which are the integral
+    //                      approximations on the subintervals
+    //
+    //             elist  - double precision
+    //                      vector of dimension at least limit, the first
+    //                       last  elements of which are the moduli of the
+    //                      absolute error estimates on the subintervals
+    //
+    //             iord   - integer
+    //                      vector of dimension at least limit, the first k
+    //                      of which are pointers to the error
+    //                      estimates over the subintervals, so that
+    //                      elist(iord(1)), ..., elist(iord(k)) with k = last
+    //                      if last.le.(limit/2+2), and k = limit+1-last
+    //                      otherwise form a decreasing sequence
+    //
+    //             last   - integer
+    //                      number of subintervals actually produced in
+    //                      the subdivision process
+    //
+    // ***references  (none)
+    // ***routines called  d1mach,dqc25s,dqmomo,dqpsrt
+    // ***end prologue  dqawse
+    //
+    //             list of major variables
+    //             -----------------------
+    //
+    //            alist     - list of left end points of all subintervals
+    //                        considered up to now
+    //            blist     - list of right end points of all subintervals
+    //                        considered up to now
+    //            rlist(i)  - approximation to the integral over
+    //                        (alist(i),blist(i))
+    //            elist(i)  - error estimate applying to rlist(i)
+    //            maxerr    - pointer to the interval with largest
+    //                        error estimate
+    //            errmax    - elist(maxerr)
+    //            area      - sum of the integrals over the subintervals
+    //            errsum    - sum of the errors over the subintervals
+    //            errbnd    - requested accuracy max(epsabs,epsrel*
+    //                        abs(result))
+    //            *****1    - variable for the left subinterval
+    //            *****2    - variable for the right subinterval
+    //            last      - index for subdivision
+    //
+    //
+    //             machine dependent constants
+    //             ---------------------------
+    //
+    //            epmach is the largest relative spacing.
+    //            uflow is the smallest positive magnitude.
+    //
+    int iroff1, iroff2, k, L, maxerr, nev, nrmax;
+    double area, area1, area12, area2, a1, a2, b1, b2, centre, errbnd, errmax;
+    double error1, error12, error2, errsum, resas1, resas2;
+    double ri[25], rj[25], rh[25], rg[25];
+
+    // last and limit, actual and max allowed no. of subintervals, are not
+    // indices, however used as such. We use L for "last"-indexed arrays
+
+    *ier = 6;
+    *neval = 0;
+    *last = 0;
+    L = 0;
+    rlist[0] = 0.0;
+    elist[0] = 0.0;
+    iord[0] = 0;
+    *result = 0.0;
+    *abserr = 0.0;
+
+    if ((b <= a) || ((epsabs == 0.0) && (epsrel < fmax(50*epmach, 0.5e-28))) ||
+        (alfa <= -1.0) || (beta <= -1.0) || (integr < 1) || (integr > 4) ||
+        (limit < 2)) { return; }
+    *ier = 0;
+
+    // Compute the modified Chebyshev moments.
+    dqmomo(alfa, beta, ri, rj, rg, rh, integr);
+
+    // Integrate over the intervals (a, (a+b)/2) and ((a+b)/2, b).
+    centre = 0.5*(b + a);
+    dqc25s(fcn, a, b, a, centre, alfa, beta, ri, rj, rg, rh, &area1, &error1, &resas1, integr, &nev);
+    *neval = nev;
+    dqc25s(fcn, a, b, centre, b, alfa, beta, ri, rj, rg, rh, &area2, &error2, &resas2, integr, &nev);
+    *last = 2;
+    *neval += nev;
+    *result = area1 + area2;
+    *abserr = error1 + error2;
+
+    // Test on Accuracy.
+    errbnd = fmax(epsabs, epsrel*fabs(*result));
+
+    // Initialization
+    if (!(error2 > error1))
+    {
+        alist[0] = a;
+        alist[1] = centre;
+        blist[0] = centre;
+        blist[1] = b;
+        rlist[0] = area1;
+        rlist[1] = area2;
+        elist[0] = error1;
+        elist[1] = error2;
+    } else {
+        alist[0] = centre;
+        alist[1] = a;
+        blist[0] = b;
+        blist[1] = centre;
+        rlist[0] = area2;
+        rlist[1] = area1;
+        elist[0] = error2;
+        elist[1] = error1;
+    }
+    // 20
+
+    iord[0] = 0;
+    iord[1] = 1;
+    if (limit == 2) { *ier = 1; }
+    if ((*abserr <= errbnd) || (*ier == 1)) { return; }
+
+    errmax = elist[0];
+    maxerr = 0;
+    nrmax = 0;
+    area = *result;
+    errsum = *abserr;
+    iroff1 = 0;
+    iroff2 = 0;
+
+    // Main for-loop.
+    for (L = 2; L < limit; L++)
+    {
+        *last = L + 1;
+
+        // Bisect the subinterval with largest error estimate.
+        a1 = alist[maxerr];
+        b1 = 0.5*(alist[maxerr] + blist[maxerr]);
+        a2 = b1;
+        b2 = blist[maxerr];
+
+        dqc25s(fcn, a, b, a1, b1, alfa, beta, ri, rj, rg, rh, &area1, &error1, &resas1, integr, &nev);
+        *neval += nev;
+        dqc25s(fcn, a, b, a2, b2, alfa, beta, ri, rj, rg, rh, &area2, &error2, &resas2, integr, &nev);
+        *neval += nev;
+
+        // Improve previous approximations integral and error and test for accuracy.
+
+        area12 = area1 + area2;
+        error12 = error1 + error2;
+        errsum = errsum + error12 - errmax;
+        area = area + area12 - rlist[maxerr];
+        if (!((a == a1) || (b == b2))){
+            if ((resas1 != error1) && (resas2 != error2))
+            {
+                // Test for roundoff error.
+                if ((fabs(rlist[maxerr]-area12) < (1.0e-5 * fabs(area12))) && (error12 >= (0.99 *errmax)))
+                {
+                    iroff1++;
+                }
+                if ((L > 9) && (error12 > errmax))
+                {
+                    iroff2++;
+                }
+            }
+        }
+        // 30
+        rlist[maxerr] = area1;
+        rlist[L] = area2;
+
+        // Test on accuracy.
+        errbnd = fmax(epsabs, epsrel*fabs(area));
+        if (!(errsum <= errbnd))
+        {
+            // Set error flag in the case that the number of interval bisections
+            // exceeds limit.
+            if (*last == limit) { *ier = 1; }
+
+            // Set error flag in the case of roundoff error.
+            if ((iroff1 >= 6) || (iroff2 >= 20)) { *ier = 2; }
+
+            // Set error flag in the case of bad integrand behavior at interior
+            // points of integration range.
+            if (fmax(fabs(a1), fabs(b2)) <= ((1.0 + 100.0*epmach)*(fabs(a2) + 1.0e3*uflow)))
+            {
+                *ier = 3;
+            }
+        }
+        // 35
+
+        // Append the newly-created intervals to the list.
+        if (!(error2 > error1))
+        {
+            alist[L] = a2;
+            blist[maxerr] = b1;
+            blist[L] = b2;
+            elist[maxerr] = error1;
+            elist[L] = error2;
+        } else {
+            alist[maxerr] = a2;
+            alist[L] = a1;
+            blist[L] = b1;
+            rlist[maxerr] = area2;
+            rlist[L] = area1;
+            elist[maxerr] = error2;
+            elist[L] = error1;
+        }
+        // 50
+
+        // Call subroutine dqpsrt to maintain the descending ordering in the
+        // list of error estimates and select the subinterval with largest error
+        // estimate (to be bisected next).
+        dqpsrt(limit, *last, &maxerr, &errmax, elist, iord, &nrmax);
+        if ((*ier != 0) || (errsum <= errbnd)) { break; }
+        // 60
+    }
+    // 70
+
+    // Compute the final result.
+    *result = 0.0;
+    for (k = 0; k <= L; k++)
+    {
+        *result = *result + rlist[k];
+    }
+    *abserr = errsum;
+
+    return;
+}
+
+
+void
+dqc25c(double(*fcn)(double* x), const double a, const double b, const double c,
+       double* result, double* abserr, int* krul, int* neval)
+{
+    // ***begin prologue  dqc25c
+    // ***date written   810101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a2a2,j4
+    // ***keywords  25-point clenshaw-curtis integration
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  to compute i = integral of f*w over (a,b) with
+    //             error estimate, where w(x) = 1/(x-c)
+    // ***description
+    //
+    //         integration rules for the computation of cauchy
+    //         principal value integrals
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //            f      - double precision
+    //                     function subprogram defining the integrand function
+    //                     f(x). the actual name for f needs to be declared
+    //                     e x t e r n a l  in the driver program.
+    //
+    //            a      - double precision
+    //                     left end point of the integration interval
+    //
+    //            b      - double precision
+    //                     right end point of the integration interval, b.gt.a
+    //
+    //            c      - double precision
+    //                     parameter in the weight function
+    //
+    //            result - double precision
+    //                     approximation to the integral
+    //                     result is computed by using a generalized
+    //                     clenshaw-curtis method if c lies within ten percent
+    //                     of the integration interval. in the other case the
+    //                     15-point kronrod rule obtained by optimal addition
+    //                     of abscissae to the 7-point gauss rule, is applied.
+    //
+    //            abserr - double precision
+    //                     estimate of the modulus of the absolute error,
+    //                     which should equal or exceed abs(i-result)
+    //
+    //            krul   - integer
+    //                     key which is decreased by 1 if the 15-point
+    //                     gauss-kronrod scheme has been used
+    //
+    //            neval  - integer
+    //                     number of integrand evaluations
+    //
+    // .......................................................................
+    // ***references  (none)
+    // ***routines called  dqcheb,dqk15w,dqwgtc
+    // ***end prologue  dqc25c
+    //
+    int i, isym, k, kp;
+    double ak22, amom0, amom1, amom2, cc, centr, hlgth, resabs, resasc, res12, res24, u;
+    double fval[25], cheb12[13], cheb24[25];
+    double mut_D;
+
+    static const double x[11]= {
+       0.991444861373810411144557526928563,
+       0.965925826289068286749743199728897,
+       0.923879532511286756128183189396788,
+       0.866025403784438646763723170752936,
+       0.793353340291235164579776961501299,
+       0.707106781186547524400844362104849,
+       0.608761429008720639416097542898164,
+       0.500000000000000000000000000000000,
+       0.382683432365089771728459984030399,
+       0.258819045102520762348898837624048,
+       0.130526192220051591548406227895489
+    };
+
+    cc = (2.0*c - b - a)/(b - a);
+    kp = 0;  // Not used in dqwgtc, hence value is irrelevant, just initialized.
+    if (fabs(cc) >= 1.1)
+    {
+        // Apply the 15-point Gauss-Kronrod scheme.
+        *krul -= 1;
+        dqk15w(fcn, dqwgtc, c, 0.0, 0.0, 0.0, kp, a, b, result, abserr, &resabs, &resasc);
+        *neval = 15;
+        if (resasc == *abserr) { *krul += 1; }
+        return;
+    }
+    // 10
+
+    // Use the generalized clenshaw-curtis method.
+    hlgth = 0.5 * (b - a);
+    centr = 0.5 * (b + a);
+    *neval = 25;
+
+    mut_D = centr + hlgth;
+    fval[0]  = 0.5 * (*fcn)(&mut_D);
+    fval[12] = (*fcn)(&centr);
+    mut_D = centr - hlgth;
+    fval[24] = 0.5 * (*fcn)(&mut_D);
+
+    for (i = 1; i < 12; i++)
+    {
+        u = hlgth*x[i-1];
+        isym = 24 - i;
+        mut_D = centr + u;
+        fval[i] = (*fcn)(&mut_D);
+        mut_D = centr - u;
+        fval[isym] = (*fcn)(&mut_D);
+    }
+
+    // Compute the Chebyshev series expansion.
+    dqcheb(x, fval, cheb12, cheb24);
+
+    // The modified Chebyshev moments are computed by forward recursion, using
+    // amom0 and amom1 as starting values.
+    amom0 = log(fabs((1.0 - cc) / (1.0 + cc)));
+    amom1 = 2.0 + (cc * amom0);
+    res12 = cheb12[0]*amom0 + cheb12[1]*amom1;
+    res24 = cheb24[0]*amom0 + cheb24[1]*amom1;
+    for (k = 2; k < 13; k++) {
+        amom2 = 2.0*cc*amom1 - amom0;
+        ak22 = (k-1) * (k-1);
+        if ((k % 2) == 1) { amom2 = amom2 - (4.0 / (ak22 - 1.0)); }
+        res12 = res12 + cheb12[k] * amom2;
+        res24 = res24 + cheb24[k] * amom2;
+        amom0 = amom1;
+        amom1 = amom2;
+    }
+    // 30
+
+    for (k = 13; k < 25; k++) {
+        amom2 = 2.0*cc*amom1 - amom0;
+        ak22 = (k-1)*(k-1);
+        if ((k % 2) == 1) { amom2 = amom2 - (4.0 / (ak22 - 1.0)); }
+        res24 = res24 + cheb24[k] * amom2;
+        amom0 = amom1;
+        amom1 = amom2;
+    }
+    *result = res24;
+    *abserr = fabs(res24 - res12);
+
+    return;
+}
+
+
+void
+dqc25f(double(*fcn)(double* x), const double a, const double b, const double omega,
+       const int integr, const int nrmom, const int maxp1, const int ksave,
+       double* result, double* abserr, int* neval, double* resabs, double* resasc,
+       int* momcom, double* chebmo)
+{
+    // ***begin prologue  dqc25f
+    // ***date written   810101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a2a2
+    // ***keywords  integration rules for functions with cos or sin
+    //              factor, clenshaw-curtis, gauss-kronrod
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  to compute the integral i=integral of f(x) over (a,b)
+    //             where w(x) = cos(omega*x) or w(x)=sin(omega*x) and to
+    //             compute j = integral of abs(f) over (a,b). for small value
+    //             of omega or small intervals (a,b) the 15-point gauss-kronro
+    //             rule is used. otherwise a generalized clenshaw-curtis
+    //             method is used.
+    // ***description
+    //
+    //         integration rules for functions with cos or sin factor
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //          on entry
+    //            f      - double precision
+    //                     function subprogram defining the integrand
+    //                     function f(x). the actual name for f needs to
+    //                     be declared e x t e r n a l in the calling program.
+    //
+    //            a      - double precision
+    //                     lower limit of integration
+    //
+    //            b      - double precision
+    //                     upper limit of integration
+    //
+    //            omega  - double precision
+    //                     parameter in the weight function
+    //
+    //            integr - integer
+    //                     indicates which weight function is to be used
+    //                        integr = 1   w(x) = cos(omega*x)
+    //                        integr = 2   w(x) = sin(omega*x)
+    //
+    //            nrmom  - integer
+    //                     the length of interval (a,b) is equal to the length
+    //                     of the original integration interval divided by
+    //                     2**nrmom (we suppose that the routine is used in an
+    //                     adaptive integration process, otherwise set
+    //                     nrmom = 0). nrmom must be zero at the first call.
+    //
+    //            maxp1  - integer
+    //                     gives an upper bound on the number of chebyshev
+    //                     moments which can be stored, i.e. for the
+    //                     intervals of lengths abs(bb-aa)*2**(-l),
+    //                     l = 0,1,2, ..., maxp1-2.
+    //
+    //            ksave  - integer
+    //                     key which is one when the moments for the
+    //                     current interval have been computed
+    //
+    //          on return
+    //            result - double precision
+    //                     approximation to the integral i
+    //
+    //            abserr - double precision
+    //                     estimate of the modulus of the absolute
+    //                     error, which should equal or exceed abs(i-result)
+    //
+    //            neval  - integer
+    //                     number of integrand evaluations
+    //
+    //            resabs - double precision
+    //                     approximation to the integral j
+    //
+    //            resasc - double precision
+    //                     approximation to the integral of abs(f-i/(b-a))
+    //
+    //          on entry and return
+    //            momcom - integer
+    //                     for each interval length we need to compute the
+    //                     chebyshev moments. momcom counts the number of
+    //                     intervals for which these moments have already been
+    //                     computed. if nrmom.lt.momcom or ksave = 1, the
+    //                     chebyshev moments for the interval (a,b) have
+    //                     already been computed and stored, otherwise we
+    //                     compute them and we increase momcom.
+    //
+    //            chebmo - double precision
+    //                     array of dimension at least (maxp1,25) containing
+    //                     the modified chebyshev moments for the first momcom
+    //                     momcom interval lengths
+    //
+    //  ......................................................................
+    // ***references  (none)
+    // ***routines called  d1mach,dgtsl,dqcheb,dqk15w,dqwgtf
+    // ***end prologue  dqc25f
+    //
+    int i, isym, j, k, m, noequ;
+    double ac, an, an2, as, asap, ass, centr, conc, cons, cospar, estc, ests;
+    double hlgth, parint, par2, par22, resc12, resc24, ress12, ress24, sinpar;
+    double cheb12[13], cheb24[25], d[25], d1[25], d2[25], fval[25], v[28];
+    double mut_D, temp, fact;
+    m = 0;
+
+    static const double x[11]= {
+       0.991444861373810411144557526928563,
+       0.965925826289068286749743199728897,
+       0.923879532511286756128183189396788,
+       0.866025403784438646763723170752936,
+       0.793353340291235164579776961501299,
+       0.707106781186547524400844362104849,
+       0.608761429008720639416097542898164,
+       0.500000000000000000000000000000000,
+       0.382683432365089771728459984030399,
+       0.258819045102520762348898837624048,
+       0.130526192220051591548406227895489
+    };
+
+    centr = 0.5*(b + a);
+    hlgth = 0.5*(b - a);
+    parint = omega*hlgth;
+
+    // Compute the integral using the 15-point gauss-kronrod formula if the
+    // value of the parameter in the integrand is small.
+    if (fabs(parint) <= 2.0) {
+        dqk15w(fcn, dqwgtf, omega, 0.0, 0.0, 0.0, integr, a, b, result, abserr, resabs, resasc);
+        *neval = 15;
+        return;
+    }
+
+    // Compute the integral using the generalized clenshaw-curtis method.
+    conc = hlgth * cos(centr * omega);
+    cons = hlgth * sin(centr * omega);
+    *resasc = oflow;
+    *neval = 25;
+
+    // Check whether the Chebyshev moments for this interval have already been computed.
+    if ((nrmom >= *momcom) && (ksave != 1))
+    {
+        // Compute a new set of Chebyshev moments.
+        m = *momcom;
+        par2 = parint * parint;
+        par22 = par2 + 2.0;
+        sinpar = sin(parint);
+        cospar = cos(parint);
+
+        // Compute the Chebyshev moments with respect to cosine.
+        v[0] = 2.0 * sinpar / parint;
+        v[1] = (8.0*cospar + (par2 + par2 - 8.0)*sinpar / parint) / par2;
+        v[2] = (32.0*(par2 - 12.0)*cospar + (2.0*((par2 - 80.0)*par2 + 192.0)*sinpar) / parint) / (par2*par2);
+        ac = 8.0 * cospar;
+        as = 24.0 * parint * sinpar;
+
+        if (fabs(parint) <= 24.0)
+        {
+            // compute the chebyshev moments as the solutions of a boundary value
+            // problem with 1 initial value (v(3)) and 1 end value (computed using
+            // an asymptotic formula).
+            noequ = 24;
+            an = 6.0;
+            for (k = 0; k < noequ; k++)
+            {
+                an2 = an * an;
+                d[k] = -2.0*(an2 - 4.0)*(par22 - an2 - an2);
+                d2[k] = (an - 1.0)*(an - 2.0)*par2;
+                d1[k+1] = (an + 3.0)*(an + 4.0)*par2;
+                v[k+3] = as - (an2 - 4.0)*ac;
+                an = an + 2.0;
+            }
+            // 20
+
+            an2 = an * an;
+            d[noequ] = -2.0*(an2 - 4.0)*(par22 - an2 - an2);
+            v[noequ+3] = as - (an2 - 4.0)*ac;
+            v[3] = v[3] - (56.0 * par2 * v[2]);
+            ass = parint * sinpar;
+            asap = (((((210.0*par2 -1.0)*cospar - (105.0*par2 - 63.0)*ass)/an2
+                    - (1.0 - 15.0*par2)*cospar + 15.0 * ass)/an2
+                    - cospar + 3.0*ass)/an2 - cospar) / an2;
+            v[noequ + 3] = v[noequ + 3] - (2.0*asap * par2 * (an - 1.0) * (an - 2.0));
+
+            // solve the tridiagonal system by means of gaussian
+            // elimination with partial pivoting.
+
+            // SciPy Translation Note: Copied from LAPACK DGTSV
+            // Assuming nonsingularity according to original quadpack code
+            // d1 starts from second element, v starts from third element.
+            // Equivalent FORTRAN DGTSV call:
+            // call dgtsv(noequ,1,d1(2),d,d2,v(4),noequ,iers)
+
+            for (i = 0; i < noequ-1; i++) {
+                if (fabs(d[i]) >= fabs(d1[i+1]))
+                {
+                    // No row interchange required.
+                    fact = d1[i+1] / d[i];
+                    d[i+1] -= fact*d2[i];
+                    v[3+i+1] -= fact*v[3+i];
+                    d1[i+1] = 0.0;
+                } else {
+                    // Interchange rows i and i + 1
+                    fact = d[i] / d1[i+1];
+                    d[i] = d1[i+1];
+                    temp = d[i+1];
+                    d[i+1] = d2[i] - fact*temp;
+                    if (i != noequ-1)
+                    {
+                        d1[i+1] = d2[i+1];
+                        d2[i+1] = -fact*d1[i+1];
+                    }
+                    d2[i] = temp;
+                    temp = v[3+i];
+                    v[3+i] = v[3+i+1];
+                    v[3+i+1] = temp - fact*v[3+i+1];
+                }
+            }
+            // Back substitute
+            v[3+noequ] /= d[noequ];
+            v[3+noequ-1] = (v[3+noequ-1] - d2[noequ-1]*v[3+noequ])/d[noequ-1];
+
+            for (i = noequ-2; i >= 0; i--) {
+                v[3+i] = (v[3+i] - d2[i]*v[3+i+1] - d1[i+1]*v[3+i+2]) / d[i];
+            }
+
+        } else {
+            // 30
+            // Compute the chebyshev moments by means of forward recursion.
+
+            an = 4.0;
+            for (i = 3; i < 13; i++) {
+                an2 = an * an;
+                v[i] = ((an2 - 4.0) * (2.0*(par22 - an2 - an2)*v[i-1] - ac)
+                        + as - par2*(an+1.0)*(an+2.0)*v[i-2]) / (par2*(an-1.0)*(an-2.0));
+                an = an + 2.0;
+            }
+            // 40
+        }
+        // 50
+        for (j = 0; j < 13; j++)
+        {
+            chebmo[*momcom + maxp1*(2*j)] = v[j];
+        }
+        // 60
+
+        // Compute the chebyshev moments with respect to sine.
+        v[0] = 2.0 * (sinpar - parint * cospar) / par2;
+        v[1] = (18.0 - 48.0/par2)*sinpar/par2 + (-2.0 + 48.0/par2)*cospar/parint;
+        ac = -24.0 * parint * cospar;
+        as = -8.0 * sinpar;
+
+        if (fabs(parint) <= 24.0)
+        {
+            // Compute the chebyshev moments as the solutions of a boundary value
+            // problem with 1 initial value (v(2)) and 1 end value (computed using
+            // an asymptotic formula).
+            an = 5.0;
+            for (k = 0; k < noequ; k++)
+            {
+                an2 = an * an;
+                d[k] = -2.0*(an2 - 4.0)*(par22 - an2 - an2);
+                d2[k] = (an - 1.0)*(an - 2.0)*par2;
+                d1[k+1] = (an + 3.0)*(an + 4.0)*par2;
+                v[k+2] = ac + (an2 - 4.0)*as;
+                an = an + 2.0;
+            }
+            // 70
+
+            an2 = an * an;
+            d[noequ] = -2.0*(an2 - 4.0)*(par22 - an2 - an2);
+            v[noequ+2] = ac + (an2 - 4.0)*as;
+            v[2] = v[2] - 42.0*par2*v[1];
+            ass = parint*cospar;
+            asap = (((((105.0*par2-63.0)*ass + (210.0*par2-1.0)*sinpar)/an2
+                    + (15.0*par2 - 1.0)*sinpar - 15.0*ass)/an2
+                    - 3.0*ass - sinpar)/an2-sinpar)/an2;
+            v[noequ+2] = v[noequ+2] - 2.0*asap*par2*(an-1.0)*(an-2.0);
+
+            // Equivalent FORTRAN DGTSV call:
+            // call dgtsv(noequ,1,d1(2),d,d2,v(3),noequ,iers)
+            for (i = 0; i < noequ-1; i++) {
+                if (fabs(d[i]) >= fabs(d1[i+1]))
+                {
+                    // No row interchange required.
+                    fact = d1[i+1] / d[i];
+                    d[i+1] -= fact*d2[i];
+                    v[2+i+1] -= fact*v[2+i];
+                    d1[i+1] = 0.0;
+                } else {
+                    // Interchange rows i and i + 1
+                    fact = d[i] / d1[i+1];
+                    d[i] = d1[i+1];
+                    temp = d[i+1];
+                    d[i+1] = d2[i] - fact*temp;
+                    if (i != noequ-1)
+                    {
+                        d1[i+1] = d2[i+1];
+                        d2[i+1] = -fact*d1[i+1];
+                    }
+                    d2[i] = temp;
+                    temp = v[2+i];
+                    v[2+i] = v[2+i+1];
+                    v[2+i+1] = temp - fact*v[2+i+1];
+                }
+            }
+            // Back substitute
+            v[2+noequ] /= d[noequ];
+            v[2+noequ-1] = (v[2+noequ-1] - d2[noequ-1]*v[2+noequ])/d[noequ-1];
+
+            for (i = noequ-2; i >= 0; i--) {
+                v[2+i] = (v[2+i] - d2[i]*v[2+i+1] - d1[i+1]*v[2+i+2]) / d[i];
+            }
+
+        } else {
+            // 80
+            an = 3.0;
+            for (i = 2; i < 12; i++)
+            {
+                an2 = an*an;
+                v[i] = ((an2-4.0)*(2.0*(par22-an2-an2)*v[i-1]+as)
+                    + ac-par2*(an+1.0)*(an+2.0)*v[i-2])
+                    / (par2*(an-1.0)*(an-2.0));
+                an = an + 2.0;
+            }
+            // 90
+        }
+        // 100
+        for (j = 0; j < 12; j++)
+        {
+            chebmo[m + maxp1*(2*j + 1)] = v[j];
+        }
+        // 110
+    }
+    // 120
+    if (nrmom < *momcom)
+    {
+        m = nrmom;
+    }
+    if ((*momcom < (maxp1 - 1)) && (nrmom >= *momcom))
+    {
+        *momcom += 1;
+    }
+    // 120
+
+    // Compute the coefficients of the chebyshev expansions of degrees 12
+    // and 24 of the function f.
+    mut_D = centr + hlgth;
+    fval[0]  = 0.5 * (*fcn)(&mut_D);
+    fval[12] = (*fcn)(&centr);
+    mut_D = centr - hlgth;
+    fval[24] = 0.5 * (*fcn)(&mut_D);
+    for (i = 1; i < 12; i++)
+    {
+        isym = 24 - i;
+        mut_D = centr + hlgth*x[i-1];
+        fval[i] = (*fcn)(&mut_D);
+        mut_D = centr - hlgth*x[i-1];
+        fval[isym] = (*fcn)(&mut_D);
+    }
+    // 130
+
+    dqcheb(x, fval, cheb12, cheb24);
+
+    // Compute the integral and error estimates.
+    resc12 = cheb12[12]*chebmo[m + maxp1*12];
+    ress12 = 0.0;
+    for (k = 10; k >= 0; k -= 2)
+    {
+        resc12 = resc12 + cheb12[k]*chebmo[m + maxp1*k];
+        ress12 = ress12 + cheb12[k+1]*chebmo[m + maxp1*(k+1)];
+    }
+    // 140
+
+    resc24 = cheb24[24]*chebmo[m + maxp1*24];
+    ress24 = 0.0;
+    *resabs = fabs(cheb24[24]);
+    for (k = 22; k >= 0; k -= 2)
+    {
+        resc24 = resc24 + cheb24[k]*chebmo[m + maxp1*k];
+        ress24 = ress24 + cheb24[k+1]*chebmo[m + maxp1*(k+1)];
+        *resabs = *resabs + fabs(cheb24[k]) + fabs(cheb24[k+1]);
+    }
+    // 150
+
+    estc = fabs(resc24 - resc12);
+    ests = fabs(ress24 - ress12);
+    *resabs = (*resabs)*fabs(hlgth);
+    if (integr != 2)
+    {
+        *result = conc*resc24 - cons*ress24;
+        *abserr = fabs(conc*estc) + fabs(cons*ests);
+    } else {
+        *result = conc*ress24 + cons*resc24;
+        *abserr = fabs(conc*ests) + fabs(cons*estc);
+    }
+
+    return;
+}
+
+
+void
+dqc25s(double(*fcn)(double* x), const double a, const double b, const double bl,
+       const double br, const double alfa, const double beta, double* ri, double* rj,
+       double* rg, double* rh, double* result, double* abserr, double* resasc,
+       const int integr, int* nev)
+{
+    // ***begin prologue  dqc25s
+    // ***date written   810101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a2a2
+    // ***keywords  25-point clenshaw-curtis integration
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  to compute i = integral of f*w over (bl,br), with error
+    //             estimate, where the weight function w has a singular
+    //             behaviour of algebraico-logarithmic type at the points
+    //             a and/or b. (bl,br) is a part of (a,b).
+    // ***description
+    //
+    //         integration rules for integrands having algebraico-logarithmic
+    //         end point singularities
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //            f      - double precision
+    //                     function subprogram defining the integrand
+    //                     f(x). the actual name for f needs to be declared
+    //                     e x t e r n a l  in the driver program.
+    //
+    //            a      - double precision
+    //                     left end point of the original interval
+    //
+    //            b      - double precision
+    //                     right end point of the original interval, b.gt.a
+    //
+    //            bl     - double precision
+    //                     lower limit of integration, bl.ge.a
+    //
+    //            br     - double precision
+    //                     upper limit of integration, br.le.b
+    //
+    //            alfa   - double precision
+    //                     parameter in the weight function
+    //
+    //            beta   - double precision
+    //                     parameter in the weight function
+    //
+    //            ri,rj,rg,rh - double precision
+    //                     modified chebyshev moments for the application
+    //                     of the generalized clenshaw-curtis
+    //                     method (computed in subroutine dqmomo)
+    //
+    //            result - double precision
+    //                     approximation to the integral
+    //                     result is computed by using a generalized
+    //                     clenshaw-curtis method if b1 = a or br = b.
+    //                     in all other cases the 15-point kronrod
+    //                     rule is applied, obtained by optimal addition of
+    //                     abscissae to the 7-point gauss rule.
+    //
+    //            abserr - double precision
+    //                     estimate of the modulus of the absolute error,
+    //                     which should equal or exceed abs(i-result)
+    //
+    //            resasc - double precision
+    //                     approximation to the integral of abs(f*w-i/(b-a))
+    //
+    //            integr - integer
+    //                     which determines the weight function
+    //                     = 1   w(x) = (x-a)**alfa*(b-x)**beta
+    //                     = 2   w(x) = (x-a)**alfa*(b-x)**beta*log(x-a)
+    //                     = 3   w(x) = (x-a)**alfa*(b-x)**beta*log(b-x)
+    //                     = 4   w(x) = (x-a)**alfa*(b-x)**beta*log(x-a)*
+    //                                  log(b-x)
+    //
+    //            nev    - integer
+    //                     number of integrand evaluations
+    // ***references  (none)
+    // ***routines called  dqcheb,dqk15w
+    // ***end prologue  dqc25s
+    //
+    int i, isym;
+    double centr, dc, factor, fix, hlgth, mut_D, resabs, res12, res24, u;
+    double cheb12[13] = { 0.0 };
+    double cheb24[25] = { 0.0 };
+    double fval[25] = { 0.0 };
+
+    static const double x[11]= {
+       0.991444861373810411144557526928563,
+       0.965925826289068286749743199728897,
+       0.923879532511286756128183189396788,
+       0.866025403784438646763723170752936,
+       0.793353340291235164579776961501299,
+       0.707106781186547524400844362104849,
+       0.608761429008720639416097542898164,
+       0.500000000000000000000000000000000,
+       0.382683432365089771728459984030399,
+       0.258819045102520762348898837624048,
+       0.130526192220051591548406227895489
+    };
+
+    *nev = 25;
+    if ((bl == a) && ((alfa != 0.0) || (integr == 2) || (integr == 4)))
+    {
+        // this part of the program is executed only if a = bl.
+        // ----------------------------------------------------
+        // compute the chebyshev series expansion of the
+        // following function
+        // f1 = (0.5*(b+b-br-a)-0.5*(br-a)*x)**beta*f(0.5*(br-a)*x+0.5*(br+a))
+
+        // 10
+        hlgth = 0.5*(br - bl);
+        centr = 0.5*(br + bl);
+        fix = b - centr;
+
+        mut_D = centr + hlgth;
+        fval[0]  = 0.5 * (*fcn)(&mut_D) * pow(fix-hlgth, beta);
+        fval[12] = (*fcn)(&centr) * pow(fix, beta);
+        mut_D = centr - hlgth;
+        fval[24] = 0.5 * (*fcn)(&mut_D) * pow(fix+hlgth, beta);
+
+        for (i = 1; i < 12; i++)
+        {
+            u = hlgth * x[i-1];
+            isym = 24 - i;
+
+            mut_D = centr + u;
+            fval[i] = (*fcn)(&mut_D) * pow(fix - u, beta);
+            mut_D = centr - u;
+            fval[isym] = (*fcn)(&mut_D) * pow(fix + u, beta);
+        }
+        // 20
+        factor = pow(hlgth, alfa + 1.0);
+        *result = 0.0;
+        *abserr = 0.0;
+        res12 = 0.0;
+        res24 = 0.0;
+
+        if (integr <= 2)
+        {
+            dqcheb(x, fval, cheb12, cheb24);
+
+            // integr = 1 or 2
+            for (i = 0; i < 13; i++)
+            {
+                res12 = res12 + cheb12[i] * ri[i];
+            }
+            // 30
+            for (i = 0; i < 25; i++)
+            {
+                res24 = res24 + cheb24[i] * ri[i];
+            }
+            // 40
+            if (integr == 1)
+            {
+                // 130 -> 270
+                *result = (*result + res24) * factor;
+                *abserr = (*abserr + fabs(res24-res12)) * factor;
+                return;
+            }
+
+            // integr = 2
+            dc = log(br - bl);
+            *result = res24*dc;
+            *abserr = fabs((res24 - res12)*dc);
+            res12 = 0.0;
+            res24 = 0.0;
+            for (i = 0; i < 13; i++)
+            {
+                res12 = res12 + cheb12[i] * rg[i];
+            }
+            // 50
+            for (i = 0; i < 25; i++) {
+                res24 = res24 + cheb24[i] * rg[i];
+            }
+            // 60
+
+            // 130 -> 270
+            *result = (*result + res24) * factor;
+            *abserr = (*abserr + fabs(res24-res12)) * factor;
+            return;
+
+        }
+        // 70
+
+        // compute the chebyshev series expansion of the following function
+        // f4 = f1*log(0.5*(b+b-br-a)-0.5*(br-a)*x)
+        fval[0] = fval[0]*log(fix - hlgth);
+        fval[12] = fval[12]*log(fix);
+        fval[24] = fval[24]*log(fix + hlgth);
+        for (i = 1; i < 12; i++)
+        {
+            u = hlgth * x[i-1];
+            isym = 24 - i;
+            fval[i] = fval[i]*log(fix - u);
+            fval[isym] = fval[isym]*log(fix + u);
+        }
+        // 80
+
+        dqcheb(x,fval,cheb12,cheb24);
+
+        //  integr = 3 or 4
+        for (i = 0; i < 13; i++)
+        {
+            res12 = res12 + cheb12[i] * ri[i];
+        }
+        // 90
+        for (i = 0; i < 25; i++)
+        {
+            res24 = res24 + cheb24[i] * ri[i];
+        }
+        // 100
+
+        if (integr == 3)
+        {
+            // 130 -> 270
+            *result = (*result + res24) * factor;
+            *abserr = (*abserr + fabs(res24-res12)) * factor;
+            return;
+        }
+        // integr = 4
+        dc = log(br - bl);
+        *result = res24 * dc;
+        *abserr = fabs((res24-res12)*dc);
+        res12 = 0.0;
+        res24 = 0.0;
+        for (i = 0; i < 13; i++)
+        {
+            res12 = res12 + cheb12[i] * rg[i];
+        }
+        // 110
+        for (i = 0; i < 25; i++)
+        {
+            res24 = res24 + cheb24[i] * rg[i];
+        }
+        // 120
+        *result = (*result + res24) * factor;
+        *abserr = (*abserr + fabs(res24-res12)) * factor;
+        return;
+    }
+
+    if ((br == b) && ((beta != 0.0) || (integr == 3) || (integr == 4)))
+    {
+        // 140
+        // this part of the program is executed only if b = br.
+        // ----------------------------------------------------
+        // compute the chebyshev series expansion of the following function
+        // f2 = (0.5*(b+bl-a-a)+0.5*(b-bl)*x)**alfa*f(0.5*(b-bl)*x+0.5*(b+bl))
+
+        hlgth = 0.5*(b - bl);
+        centr = 0.5*(br + bl);
+        fix = centr - a;
+
+        mut_D = centr + hlgth;
+        fval[0]  = 0.5 * (*fcn)(&mut_D) * pow(fix + hlgth, alfa);
+        fval[12] = (*fcn)(&centr) * pow(fix, alfa);
+        mut_D = centr - hlgth;
+        fval[24] = 0.5 * (*fcn)(&mut_D) * pow(fix - hlgth, alfa);
+
+        for (i = 1; i < 12; i++)
+        {
+            u = hlgth * x[i-1];
+            isym = 24 - i;
+
+            mut_D = centr + u;
+            fval[i] = (*fcn)(&mut_D) * pow(fix + u, alfa);
+            mut_D = centr - u;
+            fval[isym] = (*fcn)(&mut_D) * pow(fix - u, alfa);
+        }
+        // 150
+        factor = pow(hlgth, beta+1.0);
+        *result = 0.0;
+        *abserr = 0.0;
+        res12 = 0.0;
+        res24 = 0.0;
+        if ((integr != 2) && (integr != 4))
+        {
+            // integr = 1 or 3
+            dqcheb(x,fval,cheb12,cheb24);
+
+            for (i = 0; i < 13; i++)
+            {
+                res12 = res12 + cheb12[i] * rj[i];
+            }
+            // 160
+            for (i = 0; i < 25; i++)
+            {
+                res24 = res24 + cheb24[i] * rj[i];
+            }
+            // 170
+
+            if (integr == 1)
+            {
+                // 260 -> 270
+                *result = (*result + res24) * factor;
+                *abserr = (*abserr + fabs(res24-res12)) * factor;
+                return;
+            }
+
+            // integr == 3
+            dc = log(br - bl);
+            *result = res24 * dc;
+            *abserr = fabs((res24 - res12) * dc);
+            res12 = 0.0;
+            res24 = 0.0;
+            for ( i = 0; i < 13; i++)
+            {
+                res12 = res12 + cheb12[i] * rh[i];
+            }
+            // 180
+            for (i = 0; i < 25; i++)
+            {
+                res24 = res24 + cheb24[i] * rh[i];
+            }
+            // 190
+            *result = (*result + res24) * factor;
+            *abserr = (*abserr + fabs(res24-res12)) * factor;
+            return;
+        }
+        // 200
+
+        // compute the chebyshev series expansion of the following function
+        // f3 = f2*log(0.5*(b-bl)*x+0.5*(b+bl-a-a))
+        fval[0] = fval[0]*log(hlgth + fix);
+        fval[12] = fval[12]*log(fix);
+        fval[24] = fval[24]*log(fix - hlgth);
+        for (i = 1; i < 12; i++)
+        {
+            u = hlgth * x[i-1];
+            isym = 24 - i;
+
+            fval[i] = fval[i]*log(fix + u);
+            fval[isym] = fval[isym]*log(fix - u);
+        }
+        // 210
+        dqcheb(x,fval,cheb12,cheb24);
+
+        //  integr = 2 or 4
+        for (i = 0 ; i < 13; i++)
+        {
+            res12 = res12 + cheb12[i] * rj[i];
+        }
+        // 220
+        for (i = 0; i < 25; i++)
+        {
+            res24 = res24 + cheb24[i] * rj[i];
+        }
+        // 230
+
+        if (integr == 2)
+        {
+            // 260 -> 270
+            *result = (*result + res24) * factor;
+            *abserr = (*abserr + fabs(res24-res12)) * factor;
+            return;
+        }
+
+        dc = log(br - bl);
+        *result = res24 * dc;
+        *abserr = fabs((res24-res12) * dc);
+        res12 = 0.0;
+        res24 = 0.0;
+
+        // integr == 4
+        for (i = 0; i < 13; i++)
+        {
+            res12 = res12 + cheb12[i] * rh[i];
+        }
+        // 240
+        for (i = 0; i < 25; i++)
+        {
+            res24 = res24 + cheb24[i] * rh[i];
+        }
+        // 250
+
+        *result = (*result + res24) * factor;
+        *abserr = (*abserr + fabs(res24-res12)) * factor;
+        return;
+    }
+
+    // If a > bl and b < br, apply the 15-point gauss-kronrod scheme.
+    dqk15w(fcn, dqwgts, a, b, alfa, beta, integr, bl, br, result, abserr, &resabs, resasc);
+    *nev = 15;
+    return;
+
+}
+
+
+void
+dqcheb(const double* x, double* fval, double* cheb12, double* cheb24)
+{
+    // ***begin prologue  dqcheb
+    // ***refer to  dqc25c,dqc25f,dqc25s
+    // ***routines called  (none)
+    // ***revision date  830518   (yymmdd)
+    // ***keywords  chebyshev series expansion, fast fourier transform
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  this routine computes the chebyshev series expansion
+    //             of degrees 12 and 24 of a function using a
+    //             fast fourier transform method
+    //             f(x) = sum(k=1,..,13) (cheb12(k)*t(k-1,x)),
+    //             f(x) = sum(k=1,..,25) (cheb24(k)*t(k-1,x)),
+    //             where t(k,x) is the chebyshev polynomial of degree k.
+    // ***description
+    //
+    //         chebyshev series expansion
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //           on entry
+    //            x      - double precision
+    //                     vector of dimension 11 containing the
+    //                     values cos(k*pi/24), k = 1, ..., 11
+    //
+    //            fval   - double precision
+    //                     vector of dimension 25 containing the
+    //                     function values at the points
+    //                     (b+a+(b-a)*cos(k*pi/24))/2, k = 0, ...,24,
+    //                     where (a,b) is the approximation interval.
+    //                     fval(1) and fval(25) are divided by two
+    //                     (these values are destroyed at output).
+    //
+    //           on return
+    //            cheb12 - double precision
+    //                     vector of dimension 13 containing the
+    //                     chebyshev coefficients for degree 12
+    //
+    //            cheb24 - double precision
+    //                     vector of dimension 25 containing the
+    //                     chebyshev coefficients for degree 24
+    //
+    // ***end prologue  dqcheb
+    //
+    int i, j;
+    double alam, alam1, alam2, part1, part2, part3;
+    double v[12];
+
+    // x[11], fval[25], cheb12[13], cheb24[25]
+
+    for (i = 0; i < 12; i++)
+    {
+        j = 24 - i;
+        v[i] = fval[i] - fval[j];
+        fval[i] = fval[i] + fval[j];
+    }
+    // 10
+
+    alam1 = v[0] - v[8];
+    alam2 = x[5] * (v[2] - v[6] - v[10]);
+    cheb12[3] = alam1 + alam2;
+    cheb12[9] = alam1 - alam2;
+
+    alam1 = v[1] - v[7] - v[9];
+    alam2 = v[3] - v[5] - v[11];
+    alam = x[2]*alam1 + x[8]*alam2;
+    cheb24[3] = cheb12[3] + alam;
+    cheb24[21] = cheb12[3] - alam;
+
+    alam = x[8]*alam1 - x[2]*alam2;
+    cheb24[9] = cheb12[9] + alam;
+    cheb24[15] = cheb12[9] - alam;
+
+    part1 = x[3] * v[4];
+    part2 = x[7] * v[8];
+    part3 = x[5] * v[6];
+
+    alam1 = v[0] + part1 + part2;
+    alam2 = x[1]*v[2] + part3 + x[9]*v[10];
+    cheb12[1] = alam1 + alam2;
+    cheb12[11] = alam1 - alam2;
+
+    alam = x[0]*v[1] + x[2]*v[3] + x[4]*v[5] + x[6]*v[7] + x[8]*v[9] + x[10]*v[11];
+    cheb24[1] = cheb12[1] + alam;
+    cheb24[23] = cheb12[1] - alam;
+
+    alam = x[10]*v[1] - x[8]*v[3] + x[6]*v[5] - x[4]*v[7] + x[2]*v[9] - x[0]*v[11];
+    cheb24[11] = cheb12[11] + alam;
+    cheb24[13] = cheb12[11] - alam;
+
+    alam1 = v[0] - part1 + part2;
+    alam2 = x[9] * v[2] - part3 + x[1] * v[10];
+    cheb12[5] = alam1 + alam2;
+    cheb12[7] = alam1 - alam2;
+
+    alam = x[4]*v[1] - x[8]*v[3] - x[0]*v[5] - x[10]*v[7] + x[2]*v[9] + x[6]*v[11];
+    cheb24[5] = cheb12[5] + alam;
+    cheb24[19] = cheb12[5] - alam;
+
+    alam = x[6]*v[1] - x[2]*v[3] - x[10]*v[5] + x[0]*v[7] - x[8]*v[9] - x[4]*v[11];
+    cheb24[7] = cheb12[7] + alam;
+    cheb24[17] = cheb12[7] - alam;
+
+    for (i = 0; i < 6; i++)
+    {
+        j = 12 - i;
+        v[i] = fval[i] - fval[j];
+        fval[i] = fval[i] + fval[j];
+    }
+    // 20
+
+    alam1 = v[0] + x[7]*v[4];
+    alam2 = x[3]*v[2];
+    cheb12[2] = alam1 + alam2;
+    cheb12[10] = alam1 - alam2;
+    cheb12[6] = v[0] - v[4];
+
+    alam = x[1]*v[1] + x[5]*v[3] + x[9]*v[5];
+    cheb24[2] = cheb12[2] + alam;
+    cheb24[22] = cheb12[2] - alam;
+
+    alam = x[5]*(v[1] - v[3] - v[5]);
+    cheb24[6] = cheb12[6] + alam;
+    cheb24[18] = cheb12[6] - alam;
+
+    alam = x[9]*v[1] - x[5]*v[3] + x[1]*v[5];
+    cheb24[10] = cheb12[10] + alam;
+    cheb24[14] = cheb12[10] - alam;
+
+    for (i = 0; i < 3; i++) {
+        j = 6 - i;
+        v[i] = fval[i] -fval[j];
+        fval[i] = fval[i] + fval[j];
+    }
+    // 30
+
+    cheb12[4] = v[0] + x[7] * v[2];
+    cheb12[8] = fval[0] - x[7] * fval[2];
+
+    alam = x[3] * v[1];
+    cheb24[4] = cheb12[4] + alam;
+    cheb24[20] = cheb12[4] - alam;
+
+    alam = x[7] * fval[1] - fval[3];
+    cheb24[8] = cheb12[8] + alam;
+    cheb24[16] = cheb12[8] - alam;
+    cheb12[0] = fval[0] + fval[2];
+
+    alam = fval[1] + fval[3];
+    cheb24[0] = cheb12[0] + alam;
+    cheb24[24] = cheb12[0] - alam;
+    cheb12[12] = v[0] - v[2];
+    cheb24[12] = cheb12[12];
+
+    alam = 1.0 / 6.0;
+    for (i = 1; i < 12; i++)
+    {
+        cheb12[i] = cheb12[i] * alam;
+    }
+    // 40
+
+    alam = 0.5 * alam;
+    cheb12[0] = cheb12[0] * alam ;
+    cheb12[12] = cheb12[12] * alam;
+    for (i = 1; i < 24; i ++)
+    {
+        cheb24[i] = cheb24[i]*alam;
+    }
+    // 50
+
+    cheb24[0] = 0.5*alam*cheb24[0];
+    cheb24[24] = 0.5*alam*cheb24[24];
+
+    return;
+}
+
+
+void
+dqelg(int* n, double* epstab, double* result, double* abserr, double* res3la, int* nres)
+{
+    // ***begin prologue  dqelg
+    // ***refer to  dqagie,dqagoe,dqagpe,dqagse
+    // ***routines called  d1mach
+    // ***revision date  830518   (yymmdd)
+    // ***keywords  epsilon algorithm, convergence acceleration,
+    //              extrapolation
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math & progr. div. - k.u.leuven
+    // ***purpose  the routine determines the limit of a given sequence of
+    //             approximations, by means of the epsilon algorithm of
+    //             p.wynn. an estimate of the absolute error is also given.
+    //             the condensed epsilon table is computed. only those
+    //             elements needed for the computation of the next diagonal
+    //             are preserved.
+    // ***description
+    //
+    //            epsilon algorithm
+    //            standard fortran subroutine
+    //            double precision version
+    //
+    //            parameters
+    //               n      - integer
+    //                        epstab(n) contains the new element in the
+    //                        first column of the epsilon table.
+    //
+    //               epstab - double precision
+    //                        vector of dimension 52 containing the elements
+    //                        of the two lower diagonals of the triangular
+    //                        epsilon table. the elements are numbered
+    //                        starting at the right-hand corner of the
+    //                        triangle.
+    //
+    //               result - double precision
+    //                        resulting approximation to the integral
+    //
+    //               abserr - double precision
+    //                        estimate of the absolute error computed from
+    //                        result and the 3 previous results
+    //
+    //               res3la - double precision
+    //                        vector of dimension 3 containing the last 3
+    //                        results
+    //
+    //               nres   - integer
+    //                        number of calls to the routine
+    //                        (should be zero at first call)
+    //
+    // ***end prologue  dqelg
+    //
+    //            list of major variables
+    //            -----------------------
+    //
+    //            e0     - the 4 elements on which the computation of a new
+    //            e1       element in the epsilon table is based
+    //            e2
+    //            e3                 e0
+    //                         e3    e1    new
+    //                               e2
+    //            newelm - number of elements to be computed in the new
+    //                     diagonal
+    //            error  - error = abs(e1-e0)+abs(e2-e1)+abs(new-e2)
+    //            result - the element in the new diagonal with least value
+    //                     of error
+    //
+    //            machine dependent constants
+    //            ---------------------------
+    //
+    //            epmach is the largest relative spacing.
+    //            oflow is the largest positive magnitude.
+    //            limexp is the maximum number of elements the epsilon
+    //            table can contain. if this number is reached, the upper
+    //            diagonal of the epsilon table is deleted.
+    //
+    int i, indx, k1, k2, k3, limexp, n2_rem, newelm, starting_n;
+    double delta1, delta2, delta3, epsinf, error, err1, err2, err3;
+    double e0, e1, e1abs, e2, e3, res, ss, tol1, tol2, tol3;
+
+    // n is an index of epstab hence must be 0-indexed but the algorithm here
+    // is tricky in terms of jump conditions. Hence np1 = n + 1 will be used for
+    // those parts that require 1-indexed logic.
+
+    starting_n = *n;
+    *nres += 1;
+    *abserr = oflow;
+    *result = epstab[*n];
+    if (*n < 2)
+    {
+        *abserr = fmax(*abserr, 5.0*epmach*fabs(*result));
+        return;
+    }
+
+    limexp = 49; // indices 50 and 51 for the lower diagonals
+    epstab[*n + 2] = epstab[*n];
+    newelm = *n / 2;
+    epstab[*n] = oflow;
+    k1 = *n;
+    for (i = 0; i < newelm; i++)
+    {
+        k2 = k1 - 1;
+        k3 = k1 - 2;
+        res = epstab[k1 + 2];
+        e0 = epstab[k3];
+        e1 = epstab[k2];
+        e2 = res;
+        e1abs = fabs(e1);
+        delta2 = e2 - e1;
+        err2 = fabs(delta2);
+        tol2 = fmax(fabs(e2), e1abs)*epmach;
+        delta3 = e1 - e0;
+        err3 = fabs(delta3);
+        tol3 = fmax(e1abs, fabs(e0))*epmach;
+        if (!((err2 > tol2) || (err3 > tol3)))
+        {
+            // If e0, e1 and e2 are equal to within machine accuracy,
+            // convergence is assumed.
+            // result = e2
+            // abserr = abs(e1-e0)+abs(e2-e1)
+            *result = res;
+            *abserr = err2 + err3;
+            *abserr = fmax(*abserr, 5.0*epmach*fabs(*result));
+            return;
+        }
+        // 10
+
+        e3 = epstab[k1];
+        epstab[k1] = e1;
+        delta1 = e1 - e3;
+        err1 = fabs(delta1);
+        tol1 = fmax(e1abs, fabs(e3))*epmach;
+
+        // if two elements are very close to each other, omit a part of the
+        // table by adjusting the value of n.
+        if ((err1 <= tol1) || (err2 <= tol2) || (err3 <= tol3))
+        {
+            *n = i + i;
+            break;  // Goto 50
+        }
+        ss = 1.0/delta1 + 1.0/delta2 - 1.0/delta3;
+        epsinf = fabs(ss*e1);
+
+        // Test to detect irregular behaviour in the table, and  eventually omit
+        // a part of the table adjusting the value of n.
+        if (!(epsinf > 1e-4))
+        {
+            *n = i + i;
+            break;  // Goto 50
+        }
+        // 30
+
+        // Compute a new element and eventually adjust the value of result.
+        res = e1 + 1.0 / ss;
+        epstab[k1] = res;
+        k1 -= 2;
+        error = err2 + fabs(res - e2) + err3;
+        if (!(error > *abserr))
+        {
+            *abserr = error;
+            *result = res;
+        }
+    }
+    //40
+
+    // Shift the table
+    // 50
+    if (*n == limexp) { *n = 2*(limexp / 2); }
+
+    n2_rem = (starting_n % 2);
+    for (i = 0; i <= newelm; i++)
+    {
+        epstab[2*i + n2_rem] = epstab[2*i + 2 + n2_rem];
+    }
+    // 60
+
+    if (*n != starting_n)
+    {
+        indx = starting_n - *n;
+        for (i = 0; i <= *n; i++)
+        {
+            epstab[i] = epstab[indx];
+            indx++;
+        }
+        // 70
+    }
+    // 80
+    if (*nres < 4)
+    {
+        res3la[*nres - 1] = *result;
+        *abserr = oflow;
+    } else {
+        // 90
+        *abserr = fabs(*result-res3la[2]) + fabs(*result-res3la[1]) + fabs(*result-res3la[0]);
+        res3la[0] = res3la[1];
+        res3la[1] = res3la[2];
+        res3la[2] = *result;
+    }
+    // 100
+
+    *abserr = fmax(*abserr, 5.0*epmach*fabs(*result));
+
+    return;
+}
+
+
+void
+dqk15(double(*fcn)(double* x), const double a, const double b,
+      double* result, double* abserr, double* resabs, double* resasc)
+{
+    // ***begin prologue  dqk15
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a1a2
+    // ***keywords  15-point gauss-kronrod rules
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div - k.u.leuven
+    // ***purpose  to compute i = integral of f over (a,b), with error
+    //                            estimate
+    //                        j = integral of abs(f) over (a,b)
+    // ***description
+    //
+    //            integration rules
+    //            standard fortran subroutine
+    //            double precision version
+    //
+    //            parameters
+    //             on entry
+    //               f      - double precision
+    //                        function subprogram defining the integrand
+    //                        function f(x). the actual name for f needs to be
+    //                        declared e x t e r n a l in the calling program.
+    //
+    //               a      - double precision
+    //                        lower limit of integration
+    //
+    //               b      - double precision
+    //                        upper limit of integration
+    //
+    //             on return
+    //               result - double precision
+    //                        approximation to the integral i
+    //                        result is computed by applying the 15-point
+    //                        kronrod rule (resk) obtained by optimal addition
+    //                        of abscissae to the7-point gauss rule(resg).
+    //
+    //               abserr - double precision
+    //                        estimate of the modulus of the absolute error,
+    //                        which should not exceed abs(i-result)
+    //
+    //               resabs - double precision
+    //                        approximation to the integral j
+    //
+    //               resasc - double precision
+    //                        approximation to the integral of abs(f-i/(b-a))
+    //                        over (a,b)
+    //
+    // ***references  (none)
+    // ***routines called  d1mach
+    // ***end prologue  dqk15
+    //
+    //            the abscissae and weights are given for the interval (-1,1).
+    //            because of symmetry only the positive abscissae and their
+    //            corresponding weights are given.
+    //
+    //            xgk    - abscissae of the 15-point kronrod rule
+    //                     xgk(2), xgk(4), ...  abscissae of the 7-point
+    //                     gauss rule
+    //                     xgk(1), xgk(3), ...  abscissae which are optimally
+    //                     added to the 7-point gauss rule
+    //
+    //            wgk    - weights of the 15-point kronrod rule
+    //
+    //            wg     - weights of the 7-point gauss rule
+    //
+    //
+    //  gauss quadrature weights and kronron quadrature abscissae and weights
+    //  as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
+    //  bell labs, nov. 1981.
+    //
+    int j, jtw, jtwm1;
+    double absc, centr, dhlgth, fc, fsum, fval1, fval2, hlgth, resg, resk,reskh;
+    double fv1[7], fv2[7];
+    double mut_D;
+
+static const double wg[4] = {
+    0.129484966168869693270611432679082,
+    0.279705391489276667901467771423780,
+    0.381830050505118944950369775488975,
+    0.417959183673469387755102040816327
+};
+static const double xgk[8] = {
+    0.991455371120812639206854697526329,
+    0.949107912342758524526189684047851,
+    0.864864423359769072789712788640926,
+    0.741531185599394439863864773280788,
+    0.586087235467691130294144838258730,
+    0.405845151377397166906606412076961,
+    0.207784955007898467600689403773245,
+    0.000000000000000000000000000000000
+};
+static const double wgk[8] = {
+    0.022935322010529224963732008058970,
+    0.063092092629978553290700663189204,
+    0.104790010322250183839876322541518,
+    0.140653259715525918745189590510238,
+    0.169004726639267902826583426598550,
+    0.190350578064785409913256402421014,
+    0.204432940075298892414161999234649,
+    0.209482141084727828012999174891714
+};
+
+    centr = 0.5 * (a + b);
+    hlgth = 0.5 * (b - a);
+    dhlgth = fabs(hlgth);
+
+    // Compute the 15-point kronrod approximation to the integral, and
+    // estimate the absolute error.
+
+    fc = (*fcn)(&centr);
+    resg = wg[3];
+    resk = wgk[7]*fc;
+    *resabs = fabs(resk);
+
+    for (j = 0; j < 3; j++) {
+        jtw = 2*j + 1;
+        absc = hlgth * xgk[jtw];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtw] = fval1;
+        fv2[jtw] = fval2;
+        fsum = fval1 + fval2;
+        resg = resg + wg[j] * fsum;
+        resk = resk + wgk[jtw] * fsum;
+        *resabs = *resabs + wgk[jtw] * (fabs(fval1) + fabs(fval2));
+    }
+    // 10
+
+    for (j = 0; j < 4; j++) {
+        jtwm1 = 2 * j;
+        absc = hlgth * xgk[jtwm1];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtwm1] = fval1;
+        fv2[jtwm1] = fval2;
+        fsum = fval1 + fval2;
+        resk = resk + wgk[jtwm1] * fsum;
+        *resabs = *resabs + wgk[jtwm1] * (fabs(fval1) + fabs(fval2));
+    }
+    // 15
+
+    reskh = resk*0.5;
+    *resasc = wgk[7]*fabs(fc - reskh);
+    for (j = 0; j < 7; j++ )
+    {
+        *resasc = *resasc + wgk[j] * (fabs(fv1[j] - reskh) + fabs(fv2[j] - reskh));
+    }
+    // 20
+
+    *result = resk * hlgth;
+    *resabs = (*resabs)*dhlgth;
+    *resasc = (*resasc)*dhlgth;
+    *abserr = fabs((resk - resg) * hlgth);
+
+    if ((*resasc != 0.0) && (*abserr != 0.0))
+    {
+        *abserr = (*resasc) * fmin(1.0, pow((200.0 * (*abserr)/(*resasc)), 1.5));
+    }
+    if (*resabs > uflow/(50.0 * epmach))
+    {
+        *abserr = fmax(epmach * 50.0 * (*resabs),(*abserr));
+    }
+
+    return;
+}
+
+
+void
+dqk15i(double(*fcn)(double* x), const double boun, const int inf, const double a, const double b,
+       double* result, double* abserr, double* resabs, double* resasc)
+{
+    // ***begin prologue  dqk15i
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a3a2,h2a4a2
+    // ***keywords  15-point transformed gauss-kronrod rules
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  the original (infinite integration range is mapped
+    //             onto the interval (0,1) and (a,b) is a part of (0,1).
+    //             it is the purpose to compute
+    //             i = integral of transformed integrand over (a,b),
+    //             j = integral of abs(transformed integrand) over (a,b).
+    // ***description
+    //
+    //            integration rule
+    //            standard fortran subroutine
+    //            double precision version
+    //
+    //            parameters
+    //             on entry
+    //               f      - double precision
+    //                        function subprogram defining the integrand
+    //                        function f(x). the actual name for f needs to be
+    //                        declared e x t e r n a l in the calling program.
+    //
+    //               boun   - double precision
+    //                        finite bound of original integration
+    //                        range (set to zero if inf = +2)
+    //
+    //               inf    - integer
+    //                        if inf = -1, the original interval is
+    //                                    (-infinity,bound),
+    //                        if inf = +1, the original interval is
+    //                                    (bound,+infinity),
+    //                        if inf = +2, the original interval is
+    //                                    (-infinity,+infinity) and
+    //                        the integral is computed as the sum of two
+    //                        integrals, one over (-infinity,0) and one over
+    //                        (0,+infinity).
+    //
+    //               a      - double precision
+    //                        lower limit for integration over subrange
+    //                        of (0,1)
+    //
+    //               b      - double precision
+    //                        upper limit for integration over subrange
+    //                        of (0,1)
+    //
+    //             on return
+    //               result - double precision
+    //                        approximation to the integral i
+    //                        result is computed by applying the 15-point
+    //                        kronrod rule(resk) obtained by optimal addition
+    //                        of abscissae to the 7-point gauss rule(resg).
+    //
+    //               abserr - double precision
+    //                        estimate of the modulus of the absolute error,
+    //                        which should equal or exceed abs(i-result)
+    //
+    //               resabs - double precision
+    //                        approximation to the integral j
+    //
+    //               resasc - double precision
+    //                        approximation to the integral of
+    //                        abs((transformed integrand)-i/(b-a)) over (a,b)
+    //
+    // ***references  (none)
+    // ***routines called  d1mach
+    // ***end prologue  dqk15i
+    //
+    //            the abscissae and weights are supplied for the interval
+    //            (-1,1).  because of symmetry only the positive abscissae and
+    //            their corresponding weights are given.
+    //
+    //            xgk    - abscissae of the 15-point kronrod rule
+    //                     xgk(2), xgk(4), ... abscissae of the 7-point
+    //                     gauss rule
+    //                     xgk(1), xgk(3), ...  abscissae which are optimally
+    //                     added to the 7-point gauss rule
+    //
+    //            wgk    - weights of the 15-point kronrod rule
+    //
+    //            wg     - weights of the 7-point gauss rule, corresponding
+    //                     to the abscissae xgk(2), xgk(4), ...
+    //                     wg(1), wg(3), ... are set to zero.
+    //
+    int j;
+    double absc, absc1, absc2, centr, dinf, fc, fsum, fval1, fval2, hlgth, resg;
+    double resk, reskh, tabsc1, tabsc2;
+    double fv1[7], fv2[7];
+
+    static const double wg[8] = {
+        0.000000000000000000000000000000000,
+        0.129484966168869693270611432679082,
+        0.000000000000000000000000000000000,
+        0.279705391489276667901467771423780,
+        0.000000000000000000000000000000000,
+        0.381830050505118944950369775488975,
+        0.000000000000000000000000000000000,
+        0.417959183673469387755102040816327
+    };
+    static const double xgk[8] = {
+        0.991455371120812639206854697526329,
+        0.949107912342758524526189684047851,
+        0.864864423359769072789712788640926,
+        0.741531185599394439863864773280788,
+        0.586087235467691130294144838258730,
+        0.405845151377397166906606412076961,
+        0.207784955007898467600689403773245,
+        0.000000000000000000000000000000000
+    };
+    static const double wgk[8] = {
+        0.022935322010529224963732008058970,
+        0.063092092629978553290700663189204,
+        0.104790010322250183839876322541518,
+        0.140653259715525918745189590510238,
+        0.169004726639267902826583426598550,
+        0.190350578064785409913256402421014,
+        0.204432940075298892414161999234649,
+        0.209482141084727828012999174891714
+    };
+
+    dinf = (inf > 1 ? 1 : inf);
+    centr = 0.5 * (a + b);
+    hlgth = 0.5 * (b - a);
+    tabsc1 = boun + dinf*(1.0 - centr)/centr;
+    fval1 = (*fcn)(&tabsc1);
+    if (inf == 2)
+    {
+        tabsc1 = -tabsc1;
+        fval1 = fval1 + (*fcn)(&tabsc1);
+        tabsc1 = -tabsc1;
+    }
+    fc = (fval1 / centr) / centr;
+
+    // Compute the 15-point kronrod approximation to the integral, and
+    // estimate the absolute error.
+
+    resg = fc * wg[7];
+    resk = fc * wgk[7];
+    *resabs = fabs(resk);
+    for (j = 0; j < 7; j++) {
+        absc = hlgth * xgk[j];
+        absc1 = centr - absc;
+        absc2 = centr + absc;
+        tabsc1 = boun + dinf*(1.0 - absc1)/absc1;
+        tabsc2 = boun + dinf*(1.0 - absc2)/absc2;
+
+        fval1 = (*fcn)(&tabsc1);
+        fval2 = (*fcn)(&tabsc2);
+
+        if (inf == 2) {
+            tabsc1 = -tabsc1;
+            tabsc2 = -tabsc2;
+            fval1 = fval1 + (*fcn)(&tabsc1);
+            fval2 = fval2 + (*fcn)(&tabsc2);
+            tabsc1 = -tabsc1;
+            tabsc2 = -tabsc2;
+        }
+        fval1 = (fval1 / absc1) / absc1;
+        fval2 = (fval2 / absc2) / absc2;
+        fv1[j] = fval1;
+        fv2[j] = fval2;
+        fsum = fval1 + fval2;
+        resg = resg + wg[j]*fsum;
+        resk = resk + wgk[j]*fsum;
+        *resabs = *resabs + wgk[j]*(fabs(fval1) + fabs(fval2));
+    }
+    // 10
+
+    reskh = resk*0.5;
+    *resasc = wgk[7]*fabs(fc - reskh);
+    for (j = 0; j < 7; j++)
+    {
+        *resasc = *resasc + wgk[j] * (fabs(fv1[j] - reskh) + fabs(fv2[j] - reskh));
+    }
+    // 20
+
+    *result = resk * hlgth;
+    *resabs = (*resabs)*hlgth;
+    *resasc = (*resasc)*hlgth;
+    *abserr = fabs((resk - resg) * hlgth);
+
+    if ((*resasc != 0.0) && (*abserr != 0.0))
+    {
+        *abserr = (*resasc) * fmin(1.0, pow((200.0 * (*abserr)/(*resasc)), 1.5));
+    }
+    if (*resabs > uflow/(50.0 * epmach))
+    {
+        *abserr = fmax(epmach * 50.0 * (*resabs),(*abserr));
+    }
+
+    return;
+}
+
+void
+dqk15w(double(*fcn)(double* x), quadpack_w_func w, const double p1, const double p2,
+       const double p3, const double p4, const int kp, const double a, const double b,
+       double* result, double* abserr, double* resabs, double* resasc)
+{
+    // ***begin prologue  dqk15w
+    // ***date written   810101   (yymmdd)
+    // ***revision date  830518   (mmddyy)
+    // ***category no.  h2a2a2
+    // ***keywords  15-point gauss-kronrod rules
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  to compute i = integral of f*w over (a,b), with error
+    //                            estimate
+    //                        j = integral of abs(f*w) over (a,b)
+    // ***description
+    //
+    //            integration rules
+    //            standard fortran subroutine
+    //            double precision version
+    //
+    //            parameters
+    //              on entry
+    //               f      - double precision
+    //                        function subprogram defining the integrand
+    //                        function f(x). the actual name for f needs to be
+    //                        declared e x t e r n a l in the driver program.
+    //
+    //               w      - double precision
+    //                        function subprogram defining the integrand
+    //                        weight function w(x). the actual name for w
+    //                        needs to be declared e x t e r n a l in the
+    //                        calling program.
+    //
+    //               p1, p2, p3, p4 - double precision
+    //                        parameters in the weight function
+    //
+    //               kp     - integer
+    //                        key for indicating the type of weight function
+    //
+    //               a      - double precision
+    //                        lower limit of integration
+    //
+    //               b      - double precision
+    //                        upper limit of integration
+    //
+    //             on return
+    //               result - double precision
+    //                        approximation to the integral i
+    //                        result is computed by applying the 15-point
+    //                        kronrod rule (resk) obtained by optimal addition
+    //                        of abscissae to the 7-point gauss rule (resg).
+    //
+    //               abserr - double precision
+    //                        estimate of the modulus of the absolute error,
+    //                        which should equal or exceed abs(i-result)
+    //
+    //               resabs - double precision
+    //                        approximation to the integral of abs(f)
+    //
+    //               resasc - double precision
+    //                        approximation to the integral of abs(f-i/(b-a))
+    //
+    //
+    // ***references  (none)
+    // ***routines called  d1mach
+    // ***end prologue  dqk15w
+    //
+    //            the abscissae and weights are given for the interval (-1,1).
+    //            because of symmetry only the positive abscissae and their
+    //            corresponding weights are given.
+    //
+    //            xgk    - abscissae of the 15-point gauss-kronrod rule
+    //                     xgk(2), xgk(4), ... abscissae of the 7-point
+    //                     gauss rule
+    //                     xgk(1), xgk(3), ... abscissae which are optimally
+    //                     added to the 7-point gauss rule
+    //
+    //            wgk    - weights of the 15-point gauss-kronrod rule
+    //
+    //            wg     - weights of the 7-point gauss rule
+    //
+    int j, jtw, jtwm1;
+    double absc, absc1, absc2, centr, dhlgth, fc, fsum, fval1, fval2, hlgth;
+    double resg,resk,reskh;
+    double fv1[7], fv2[7];
+
+    static const double wg[4] = {
+        0.1294849661688697,
+        0.2797053914892767,
+        0.3818300505051189,
+        0.4179591836734694
+    };
+    static const double xgk[8] = {
+        0.9914553711208126,
+        0.9491079123427585,
+        0.8648644233597691,
+        0.7415311855993944,
+        0.5860872354676911,
+        0.4058451513773972,
+        0.2077849550078985,
+        0.0000000000000000
+    };
+    static const double wgk[8] = {
+        0.2293532201052922e-01,
+        0.6309209262997855e-01,
+        0.1047900103222502,
+        0.1406532597155259,
+        0.1690047266392679,
+        0.1903505780647854,
+        0.2044329400752989,
+        0.2094821410847278
+    };
+
+    centr = 0.5 * (b + a);
+    hlgth = 0.5 * (b - a);
+    dhlgth = fabs(hlgth);
+
+    // Compute the 15-point kronrod approximation to the integral, and
+    // estimate the absolute error.
+
+    fc = (*fcn)(&centr) * (*w)(centr, p1, p2, p3, p4, kp);
+    resg = wg[3] * fc;
+    resk = wgk[7] * fc;
+    *resabs = fabs(resk);
+    for (j = 0; j < 3; j++) {
+        jtw = 2*j + 1;
+        absc = hlgth * xgk[jtw];
+        absc1 = centr - absc;
+        absc2 = centr + absc;
+
+        fval1 = (*fcn)(&absc1) * (*w)(absc1, p1, p2, p3, p4, kp);
+        fval2 = (*fcn)(&absc2) * (*w)(absc2, p1, p2, p3, p4, kp);
+
+        fv1[jtw] = fval1;
+        fv2[jtw] = fval2;
+        fsum = fval1 + fval2;
+        resg = resg + wg[j] * fsum;
+        resk = resk + wgk[jtw] * fsum;
+        *resabs = *resabs + wgk[jtw] * (fabs(fval1) + fabs(fval2));
+    }
+    // 10
+    for (j = 0; j < 4; j++) {
+        jtwm1 = 2*j;
+        absc = hlgth * xgk[jtwm1];
+        absc1 = centr - absc;
+        absc2 = centr + absc;
+
+        fval1 = (*fcn)(&absc1) * (*w)(absc1, p1, p2, p3, p4, kp);
+        fval2 = (*fcn)(&absc2) * (*w)(absc2, p1, p2, p3, p4, kp);
+
+        fv1[jtwm1] = fval1;
+        fv2[jtwm1] = fval2;
+        fsum = fval1 + fval2;
+        resk = resk + wgk[jtwm1] * fsum;
+        *resabs = *resabs + wgk[jtwm1] * (fabs(fval1) + fabs(fval2));
+    }
+    // 15
+
+    reskh = resk*0.5;
+    *resasc = wgk[7]*fabs(fc - reskh);
+    for (j = 0; j < 7; j++ )
+    {
+        *resasc = *resasc + wgk[j] * (fabs(fv1[j] - reskh) + fabs(fv2[j] - reskh));
+    }
+    // 20
+
+    *result = resk * hlgth;
+    *resabs = (*resabs)*dhlgth;
+    *resasc = (*resasc)*dhlgth;
+    *abserr = fabs((resk - resg) * hlgth);
+
+    if ((*resasc != 0.0) && (*abserr != 0.0))
+    {
+        *abserr = (*resasc) * fmin(1.0, pow((200.0 * (*abserr)/(*resasc)), 1.5));
+    }
+    if (*resabs > uflow/(50.0 * epmach))
+    {
+        *abserr = fmax(epmach * 50.0 * (*resabs),(*abserr));
+    }
+
+    return;
+
+}
+
+
+void
+dqk21(double(*fcn)(double* x), const double a, const double b,
+      double* result, double* abserr, double* resabs, double* resasc)
+{
+    // ***begin prologue  dqk21
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a1a2
+    // ***keywords  21-point gauss-kronrod rules
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  to compute i = integral of f over (a,b), with error
+    //                            estimate
+    //                        j = integral of abs(f) over (a,b)
+    // ***description
+    //
+    //            integration rules
+    //            standard fortran subroutine
+    //            double precision version
+    //
+    //            parameters
+    //             on entry
+    //               f      - double precision
+    //                        function subprogram defining the integrand
+    //                        function f(x). the actual name for f needs to be
+    //                        declared e x t e r n a l in the driver program.
+    //
+    //               a      - double precision
+    //                        lower limit of integration
+    //
+    //               b      - double precision
+    //                        upper limit of integration
+    //
+    //             on return
+    //               result - double precision
+    //                        approximation to the integral i
+    //                        result is computed by applying the 21-point
+    //                        kronrod rule (resk) obtained by optimal addition
+    //                        of abscissae to the 10-point gauss rule (resg).
+    //
+    //               abserr - double precision
+    //                        estimate of the modulus of the absolute error,
+    //                        which should not exceed abs(i-result)
+    //
+    //               resabs - double precision
+    //                        approximation to the integral j
+    //
+    //               resasc - double precision
+    //                        approximation to the integral of abs(f-i/(b-a))
+    //                        over (a,b)
+    //
+    // ***references  (none)
+    // ***routines called  d1mach
+    // ***end prologue  dqk21
+    //
+    //            the abscissae and weights are given for the interval (-1,1).
+    //            because of symmetry only the positive abscissae and their
+    //            corresponding weights are given.
+    //
+    //            xgk    - abscissae of the 21-point kronrod rule
+    //                     xgk(2), xgk(4), ...  abscissae of the 10-point
+    //                     gauss rule
+    //                     xgk(1), xgk(3), ...  abscissae which are optimally
+    //                     added to the 10-point gauss rule
+    //
+    //            wgk    - weights of the 21-point kronrod rule
+    //
+    //            wg     - weights of the 10-point gauss rule
+    //
+    //
+    //  gauss quadrature weights and kronron quadrature abscissae and weights
+    //  as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
+    //  bell labs, nov. 1981.
+    //
+    int j, jtw, jtwm1;
+    double absc, centr, dhlgth, fc, fsum, fval1, fval2, hlgth, resg, resk, reskh;
+    double fv1[10], fv2[10];
+    double mut_D;
+
+    static const double wg[5] = {
+        0.066671344308688137593568809893332,
+        0.149451349150580593145776339657697,
+        0.219086362515982043995534934228163,
+        0.269266719309996355091226921569469,
+        0.295524224714752870173892994651338
+    };
+    static const double xgk[11] = {
+        0.995657163025808080735527280689003,
+        0.973906528517171720077964012084452,
+        0.930157491355708226001207180059508,
+        0.865063366688984510732096688423493,
+        0.780817726586416897063717578345042,
+        0.679409568299024406234327365114874,
+        0.562757134668604683339000099272694,
+        0.433395394129247190799265943165784,
+        0.294392862701460198131126603103866,
+        0.148874338981631210884826001129720,
+        0.000000000000000000000000000000000
+    };
+    static const double wgk[11] = {
+        0.011694638867371874278064396062192,
+        0.032558162307964727478818972459390,
+        0.054755896574351996031381300244580,
+        0.075039674810919952767043140916190,
+        0.093125454583697605535065465083366,
+        0.109387158802297641899210590325805,
+        0.123491976262065851077958109831074,
+        0.134709217311473325928054001771707,
+        0.142775938577060080797094273138717,
+        0.147739104901338491374841515972068,
+        0.149445554002916905664936468389821
+    };
+
+    centr = 0.5 * (a + b);
+    hlgth = 0.5 * (b - a);
+    dhlgth = fabs(hlgth);
+
+    // Compute the 21-point kronrod approximation to the integral, and
+    // estimate the absolute error.
+
+    fc=(*fcn)(&centr);
+    resg = 0.0;
+    resk = wgk[10]*fc;
+    *resabs = fabs(resk);
+
+    for (j = 0; j < 5; j++) {
+        jtw = 2*j + 1;
+        absc = hlgth * xgk[jtw];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtw] = fval1;
+        fv2[jtw] = fval2;
+        fsum = fval1 + fval2;
+        resg = resg + wg[j] * fsum;
+        resk = resk + wgk[jtw] * fsum;
+        *resabs = *resabs + wgk[jtw] * (fabs(fval1) + fabs(fval2));
+    }
+    // 10
+
+    for (j = 0; j < 5; j++) {
+        jtwm1 = 2 * j;
+        absc = hlgth * xgk[jtwm1];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtwm1] = fval1;
+        fv2[jtwm1] = fval2;
+        fsum = fval1 + fval2;
+        resk = resk + wgk[jtwm1] * fsum;
+        *resabs = *resabs + wgk[jtwm1] * (fabs(fval1) + fabs(fval2));
+    }
+    // 15
+
+    reskh = resk * 0.5;
+    *resasc = wgk[10]*fabs(fc - reskh);
+    for (j = 0; j < 10; j++ )
+    {
+        *resasc = *resasc + wgk[j] * (fabs(fv1[j] - reskh) + fabs(fv2[j] - reskh));
+    }
+    // 20
+
+    *result = resk * hlgth;
+    *resabs = (*resabs)*dhlgth;
+    *resasc = (*resasc)*dhlgth;
+    *abserr = fabs((resk - resg) * hlgth);
+
+    if ((*resasc != 0.0) && (*abserr != 0.0))
+    {
+        *abserr = (*resasc) * fmin(1.0, pow((200.0 * (*abserr)/(*resasc)), 1.5));
+    }
+    if (*resabs > uflow/(50.0 * epmach))
+    {
+        *abserr = fmax(epmach * 50.0 * (*resabs),(*abserr));
+    }
+
+    return;
+}
+
+
+void
+dqk31(double(*fcn)(double* x), const double a, const double b,
+      double* result, double* abserr, double* resabs, double* resasc)
+{
+    // ***begin prologue  dqk31
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a1a2
+    // ***keywords  31-point gauss-kronrod rules
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  to compute i = integral of f over (a,b) with error
+    //                            estimate
+    //                        j = integral of abs(f) over (a,b)
+    // ***description
+    //
+    //            integration rules
+    //            standard fortran subroutine
+    //            double precision version
+    //
+    //            parameters
+    //             on entry
+    //               f      - double precision
+    //                        function subprogram defining the integrand
+    //                        function f(x). the actual name for f needs to be
+    //                        declared e x t e r n a l in the calling program.
+    //
+    //               a      - double precision
+    //                        lower limit of integration
+    //
+    //               b      - double precision
+    //                        upper limit of integration
+    //
+    //             on return
+    //               result - double precision
+    //                        approximation to the integral i
+    //                        result is computed by applying the 31-point
+    //                        gauss-kronrod rule (resk), obtained by optimal
+    //                        addition of abscissae to the 15-point gauss
+    //                        rule (resg).
+    //
+    //               abserr - double precision
+    //                        estimate of the modulus of the modulus,
+    //                        which should not exceed abs(i-result)
+    //
+    //               resabs - double precision
+    //                        approximation to the integral j
+    //
+    //               resasc - double precision
+    //                        approximation to the integral of abs(f-i/(b-a))
+    //                        over (a,b)
+    //
+    // ***references  (none)
+    // ***routines called  d1mach
+    // ***end prologue  dqk31
+    //
+    //            the abscissae and weights are given for the interval (-1,1).
+    //            because of symmetry only the positive abscissae and their
+    //            corresponding weights are given.
+    //
+    //            xgk    - abscissae of the 31-point kronrod rule
+    //                     xgk(2), xgk(4), ...  abscissae of the 15-point
+    //                     gauss rule
+    //                     xgk(1), xgk(3), ...  abscissae which are optimally
+    //                     added to the 15-point gauss rule
+    //
+    //            wgk    - weights of the 31-point kronrod rule
+    //
+    //            wg     - weights of the 15-point gauss rule
+    //
+    //
+    //  gauss quadrature weights and kronron quadrature abscissae and weights
+    //  as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
+    //  bell labs, nov. 1981.
+    //
+    int j, jtw, jtwm1;
+    double absc, centr, dhlgth, fc, fsum, fval1, fval2, hlgth, resg, resk,reskh;
+    double fv1[15], fv2[15];
+    double mut_D;
+
+    static const double wg[8] = {
+        0.030753241996117268354628393577204,
+        0.070366047488108124709267416450667,
+        0.107159220467171935011869546685869,
+        0.139570677926154314447804794511028,
+        0.166269205816993933553200860481209,
+        0.186161000015562211026800561866423,
+        0.198431485327111576456118326443839,
+        0.202578241925561272880620199967519
+    };
+    static const double xgk[16] = {
+        0.998002298693397060285172840152271,
+        0.987992518020485428489565718586613,
+        0.967739075679139134257347978784337,
+        0.937273392400705904307758947710209,
+        0.897264532344081900882509656454496,
+        0.848206583410427216200648320774217,
+        0.790418501442465932967649294817947,
+        0.724417731360170047416186054613938,
+        0.650996741297416970533735895313275,
+        0.570972172608538847537226737253911,
+        0.485081863640239680693655740232351,
+        0.394151347077563369897207370981045,
+        0.299180007153168812166780024266389,
+        0.201194093997434522300628303394596,
+        0.101142066918717499027074231447392,
+        0.000000000000000000000000000000000
+    };
+    static const double wgk[16] = {
+        0.005377479872923348987792051430128,
+        0.015007947329316122538374763075807,
+        0.025460847326715320186874001019653,
+        0.035346360791375846222037948478360,
+        0.044589751324764876608227299373280,
+        0.053481524690928087265343147239430,
+        0.062009567800670640285139230960803,
+        0.069854121318728258709520077099147,
+        0.076849680757720378894432777482659,
+        0.083080502823133021038289247286104,
+        0.088564443056211770647275443693774,
+        0.093126598170825321225486872747346,
+        0.096642726983623678505179907627589,
+        0.099173598721791959332393173484603,
+        0.100769845523875595044946662617570,
+        0.101330007014791549017374792767493
+    };
+
+    centr = 0.5 * (a + b);
+    hlgth = 0.5 * (b - a);
+    dhlgth = fabs(hlgth);
+
+    // Compute the 31-point kronrod approximation to the integral, and
+    // estimate the absolute error.
+
+    fc=(*fcn)(&centr);
+    resg = wg[7]*fc;
+    resk = wgk[15]*fc;
+    *resabs = fabs(resk);
+
+    for (j = 0; j < 7; j++) {
+        jtw = 2*j + 1;
+        absc = hlgth * xgk[jtw];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtw] = fval1;
+        fv2[jtw] = fval2;
+        fsum = fval1 + fval2;
+        resg = resg + wg[j] * fsum;
+        resk = resk + wgk[jtw] * fsum;
+        *resabs = *resabs + wgk[jtw] * (fabs(fval1) + fabs(fval2));
+    }
+    // 10
+
+    for (j = 0; j < 8; j++) {
+        jtwm1 = 2 * j;
+        absc = hlgth * xgk[jtwm1];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtwm1] = fval1;
+        fv2[jtwm1] = fval2;
+        fsum = fval1 + fval2;
+        resk = resk + wgk[jtwm1] * fsum;
+        *resabs = *resabs + wgk[jtwm1] * (fabs(fval1) + fabs(fval2));
+    }
+    // 15
+
+    reskh = resk * 0.5;
+    *resasc = wgk[15]*fabs(fc - reskh);
+    for (j = 0; j < 15; j++ )
+    {
+        *resasc = *resasc + wgk[j] * (fabs(fv1[j] - reskh) + fabs(fv2[j] - reskh));
+    }
+    // 20
+
+    *result = resk * hlgth;
+    *resabs = (*resabs)*dhlgth;
+    *resasc = (*resasc)*dhlgth;
+    *abserr = fabs((resk - resg) * hlgth);
+
+    if ((*resasc != 0.0) && (*abserr != 0.0))
+    {
+        *abserr = (*resasc) * fmin(1.0, pow((200.0 * (*abserr)/(*resasc)), 1.5));
+    }
+    if (*resabs > uflow/(50.0 * epmach))
+    {
+        *abserr = fmax(epmach * 50.0 * (*resabs),(*abserr));
+    }
+
+    return;
+}
+
+
+void
+dqk41(double(*fcn)(double* x), const double a, const double b,
+      double* result, double* abserr, double* resabs, double* resasc)
+{
+    // ***begin prologue  dqk41
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a1a2
+    // ***keywords  41-point gauss-kronrod rules
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  to compute i = integral of f over (a,b), with error
+    //                            estimate
+    //                        j = integral of abs(f) over (a,b)
+    // ***description
+    //
+    //            integration rules
+    //            standard fortran subroutine
+    //            double precision version
+    //
+    //            parameters
+    //             on entry
+    //               f      - double precision
+    //                        function subprogram defining the integrand
+    //                        function f(x). the actual name for f needs to be
+    //                        declared e x t e r n a l in the calling program.
+    //
+    //               a      - double precision
+    //                        lower limit of integration
+    //
+    //               b      - double precision
+    //                        upper limit of integration
+    //
+    //             on return
+    //               result - double precision
+    //                        approximation to the integral i
+    //                        result is computed by applying the 41-point
+    //                        gauss-kronrod rule (resk) obtained by optimal
+    //                        addition of abscissae to the 20-point gauss
+    //                        rule (resg).
+    //
+    //               abserr - double precision
+    //                        estimate of the modulus of the absolute error,
+    //                        which should not exceed abs(i-result)
+    //
+    //               resabs - double precision
+    //                        approximation to the integral j
+    //
+    //               resasc - double precision
+    //                        approximation to the integal of abs(f-i/(b-a))
+    //                        over (a,b)
+    //
+    // ***references  (none)
+    // ***routines called  d1mach
+    // ***end prologue  dqk41
+    //
+    //            the abscissae and weights are given for the interval (-1,1).
+    //            because of symmetry only the positive abscissae and their
+    //            corresponding weights are given.
+    //
+    //            xgk    - abscissae of the 41-point gauss-kronrod rule
+    //                     xgk(2), xgk(4), ...  abscissae of the 20-point
+    //                     gauss rule
+    //                     xgk(1), xgk(3), ...  abscissae which are optimally
+    //                     added to the 20-point gauss rule
+    //
+    //            wgk    - weights of the 41-point gauss-kronrod rule
+    //
+    //            wg     - weights of the 20-point gauss rule
+    //
+    //
+    //  gauss quadrature weights and kronron quadrature abscissae and weights
+    //  as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
+    //  bell labs, nov. 1981.
+    //
+    int j, jtw, jtwm1;
+    double absc, centr, dhlgth, fc, fsum, fval1, fval2, hlgth, resg, resk, reskh;
+    double fv1[20], fv2[20];
+    double mut_D;
+
+    static const double wg[10] = {
+        0.017614007139152118311861962351853,
+        0.040601429800386941331039952274932,
+        0.062672048334109063569506535187042,
+        0.083276741576704748724758143222046,
+        0.101930119817240435036750135480350,
+        0.118194531961518417312377377711382,
+        0.131688638449176626898494499748163,
+        0.142096109318382051329298325067165,
+        0.149172986472603746787828737001969,
+        0.152753387130725850698084331955098
+    };
+    static const double xgk[21] = {
+        0.998859031588277663838315576545863,
+        0.993128599185094924786122388471320,
+        0.981507877450250259193342994720217,
+        0.963971927277913791267666131197277,
+        0.940822633831754753519982722212443,
+        0.912234428251325905867752441203298,
+        0.878276811252281976077442995113078,
+        0.839116971822218823394529061701521,
+        0.795041428837551198350638833272788,
+        0.746331906460150792614305070355642,
+        0.693237656334751384805490711845932,
+        0.636053680726515025452836696226286,
+        0.575140446819710315342946036586425,
+        0.510867001950827098004364050955251,
+        0.443593175238725103199992213492640,
+        0.373706088715419560672548177024927,
+        0.301627868114913004320555356858592,
+        0.227785851141645078080496195368575,
+        0.152605465240922675505220241022678,
+        0.076526521133497333754640409398838,
+        0.000000000000000000000000000000000
+    };
+    static const double wgk[21] = {
+        0.003073583718520531501218293246031,
+        0.008600269855642942198661787950102,
+        0.014626169256971252983787960308868,
+        0.020388373461266523598010231432755,
+        0.025882133604951158834505067096153,
+        0.031287306777032798958543119323801,
+        0.036600169758200798030557240707211,
+        0.041668873327973686263788305936895,
+        0.046434821867497674720231880926108,
+        0.050944573923728691932707670050345,
+        0.055195105348285994744832372419777,
+        0.059111400880639572374967220648594,
+        0.062653237554781168025870122174255,
+        0.065834597133618422111563556969398,
+        0.068648672928521619345623411885368,
+        0.071054423553444068305790361723210,
+        0.073030690332786667495189417658913,
+        0.074582875400499188986581418362488,
+        0.075704497684556674659542775376617,
+        0.076377867672080736705502835038061,
+        0.076600711917999656445049901530102
+    };
+
+    centr = 0.5 * (a + b);
+    hlgth = 0.5 * (b - a);
+    dhlgth = fabs(hlgth);
+
+    // Compute the 41-point kronrod approximation to the integral, and
+    // estimate the absolute error.
+
+    fc=(*fcn)(&centr);
+    resg = 0.0;
+    resk = wgk[20]*fc;
+    *resabs = fabs(resk);
+
+    for (j = 0; j < 10; j++) {
+        jtw = 2*j + 1;
+        absc = hlgth * xgk[jtw];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtw] = fval1;
+        fv2[jtw] = fval2;
+        fsum = fval1 + fval2;
+        resg = resg + wg[j] * fsum;
+        resk = resk + wgk[jtw] * fsum;
+        *resabs = *resabs + wgk[jtw] * (fabs(fval1) + fabs(fval2));
+    }
+    // 10
+
+    for (j = 0; j < 10; j++) {
+        jtwm1 = 2 * j;
+        absc = hlgth * xgk[jtwm1];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtwm1] = fval1;
+        fv2[jtwm1] = fval2;
+        fsum = fval1 + fval2;
+        resk = resk + wgk[jtwm1] * fsum;
+        *resabs = *resabs + wgk[jtwm1] * (fabs(fval1) + fabs(fval2));
+    }
+    // 15
+
+    reskh = resk * 0.5;
+    *resasc = wgk[20]*fabs(fc - reskh);
+    for (j = 0; j < 20; j++ )
+    {
+        *resasc = *resasc + wgk[j] * (fabs(fv1[j] - reskh) + fabs(fv2[j] - reskh));
+    }
+    // 20
+
+    *result = resk * hlgth;
+    *resabs = (*resabs)*dhlgth;
+    *resasc = (*resasc)*dhlgth;
+    *abserr = fabs((resk - resg) * hlgth);
+
+    if ((*resasc != 0.0) && (*abserr != 0.0))
+    {
+        *abserr = (*resasc) * fmin(1.0, pow((200.0 * (*abserr)/(*resasc)), 1.5));
+    }
+    if (*resabs > uflow/(50.0 * epmach))
+    {
+        *abserr = fmax(epmach * 50.0 * (*resabs),(*abserr));
+    }
+
+    return;
+}
+
+
+void
+dqk51(double(*fcn)(double* x), const double a, const double b,
+      double* result, double* abserr, double* resabs, double* resasc)
+{
+    // ***begin prologue  dqk51
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a1a2
+    // ***keywords  51-point gauss-kronrod rules
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math & progr. div. - k.u.leuven
+    // ***purpose  to compute i = integral of f over (a,b) with error
+    //                            estimate
+    //                        j = integral of abs(f) over (a,b)
+    // ***description
+    //
+    //            integration rules
+    //            standard fortran subroutine
+    //            double precision version
+    //
+    //            parameters
+    //             on entry
+    //               f      - double precision
+    //                        function subroutine defining the integrand
+    //                        function f(x). the actual name for f needs to be
+    //                        declared e x t e r n a l in the calling program.
+    //
+    //               a      - double precision
+    //                        lower limit of integration
+    //
+    //               b      - double precision
+    //                        upper limit of integration
+    //
+    //             on return
+    //               result - double precision
+    //                        approximation to the integral i
+    //                        result is computed by applying the 51-point
+    //                        kronrod rule (resk) obtained by optimal addition
+    //                        of abscissae to the 25-point gauss rule (resg).
+    //
+    //               abserr - double precision
+    //                        estimate of the modulus of the absolute error,
+    //                        which should not exceed abs(i-result)
+    //
+    //               resabs - double precision
+    //                        approximation to the integral j
+    //
+    //               resasc - double precision
+    //                        approximation to the integral of abs(f-i/(b-a))
+    //                        over (a,b)
+    //
+    // ***references  (none)
+    // ***routines called  d1mach
+    // ***end prologue  dqk51
+    //
+    //            the abscissae and weights are given for the interval (-1,1).
+    //            because of symmetry only the positive abscissae and their
+    //            corresponding weights are given.
+    //
+    //            xgk    - abscissae of the 51-point kronrod rule
+    //                     xgk(2), xgk(4), ...  abscissae of the 25-point
+    //                     gauss rule
+    //                     xgk(1), xgk(3), ...  abscissae which are optimally
+    //                     added to the 25-point gauss rule
+    //
+    //            wgk    - weights of the 51-point kronrod rule
+    //
+    //            wg     - weights of the 25-point gauss rule
+    //
+    //
+    //  gauss quadrature weights and kronron quadrature abscissae and weights
+    //  as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
+    //  bell labs, nov. 1981.
+    //
+    int j, jtw, jtwm1;
+    double absc, centr, dhlgth, fc, fsum, fval1, fval2, hlgth, resg, resk, reskh;
+    double fv1[25], fv2[25];
+    double mut_D;
+
+    static const double wg[13] = {
+        0.011393798501026287947902964113235,
+        0.026354986615032137261901815295299,
+        0.040939156701306312655623487711646,
+        0.054904695975835191925936891540473,
+        0.068038333812356917207187185656708,
+        0.080140700335001018013234959669111,
+        0.091028261982963649811497220702892,
+        0.100535949067050644202206890392686,
+        0.108519624474263653116093957050117,
+        0.114858259145711648339325545869556,
+        0.119455763535784772228178126512901,
+        0.122242442990310041688959518945852,
+        0.123176053726715451203902873079050
+    };
+    static const double xgk[26] = {
+        0.999262104992609834193457486540341,
+        0.995556969790498097908784946893902,
+        0.988035794534077247637331014577406,
+        0.976663921459517511498315386479594,
+        0.961614986425842512418130033660167,
+        0.942974571228974339414011169658471,
+        0.920747115281701561746346084546331,
+        0.894991997878275368851042006782805,
+        0.865847065293275595448996969588340,
+        0.833442628760834001421021108693570,
+        0.797873797998500059410410904994307,
+        0.759259263037357630577282865204361,
+        0.717766406813084388186654079773298,
+        0.673566368473468364485120633247622,
+        0.626810099010317412788122681624518,
+        0.577662930241222967723689841612654,
+        0.526325284334719182599623778158010,
+        0.473002731445714960522182115009192,
+        0.417885382193037748851814394594572,
+        0.361172305809387837735821730127641,
+        0.303089538931107830167478909980339,
+        0.243866883720988432045190362797452,
+        0.183718939421048892015969888759528,
+        0.122864692610710396387359818808037,
+        0.061544483005685078886546392366797,
+        0.000000000000000000000000000000000
+    };
+    static const double wgk[26] = {
+        0.001987383892330315926507851882843,
+        0.005561932135356713758040236901066,
+        0.009473973386174151607207710523655,
+        0.013236229195571674813656405846976,
+        0.016847817709128298231516667536336,
+        0.020435371145882835456568292235939,
+        0.024009945606953216220092489164881,
+        0.027475317587851737802948455517811,
+        0.030792300167387488891109020215229,
+        0.034002130274329337836748795229551,
+        0.037116271483415543560330625367620,
+        0.040083825504032382074839284467076,
+        0.042872845020170049476895792439495,
+        0.045502913049921788909870584752660,
+        0.047982537138836713906392255756915,
+        0.050277679080715671963325259433440,
+        0.052362885806407475864366712137873,
+        0.054251129888545490144543370459876,
+        0.055950811220412317308240686382747,
+        0.057437116361567832853582693939506,
+        0.058689680022394207961974175856788,
+        0.059720340324174059979099291932562,
+        0.060539455376045862945360267517565,
+        0.061128509717053048305859030416293,
+        0.061471189871425316661544131965264,
+        0.061580818067832935078759824240066
+    };
+
+    centr = 0.5 * (a + b);
+    hlgth = 0.5 * (b - a);
+    dhlgth = fabs(hlgth);
+
+    // Compute the 51-point kronrod approximation to the integral, and
+    // estimate the absolute error.
+
+    fc = (*fcn)(&centr);
+    resg = wg[12]*fc;
+    resk = wgk[25]*fc;
+    *resabs = fabs(resk);
+
+    for (j = 0; j < 12; j++) {
+        jtw = 2*j + 1;
+        absc = hlgth * xgk[jtw];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtw] = fval1;
+        fv2[jtw] = fval2;
+        fsum = fval1 + fval2;
+        resg = resg + wg[j] * fsum;
+        resk = resk + wgk[jtw] * fsum;
+        *resabs = *resabs + wgk[jtw] * (fabs(fval1) + fabs(fval2));
+    }
+    // 10
+
+    for (j = 0; j < 13; j++) {
+        jtwm1 = 2 * j;
+        absc = hlgth * xgk[jtwm1];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtwm1] = fval1;
+        fv2[jtwm1] = fval2;
+        fsum = fval1 + fval2;
+        resk = resk + wgk[jtwm1] * fsum;
+        *resabs = *resabs + wgk[jtwm1] * (fabs(fval1) + fabs(fval2));
+    }
+    // 15
+
+    reskh = resk * 0.5;
+    *resasc = wgk[25]*fabs(fc - reskh);
+    for (j = 0; j < 25; j++ )
+    {
+        *resasc = *resasc + wgk[j] * (fabs(fv1[j] - reskh) + fabs(fv2[j] - reskh));
+    }
+    // 20
+
+    *result = resk * hlgth;
+    *resabs = (*resabs)*dhlgth;
+    *resasc = (*resasc)*dhlgth;
+    *abserr = fabs((resk - resg) * hlgth);
+
+    if ((*resasc != 0.0) && (*abserr != 0.0))
+    {
+        *abserr = (*resasc) * fmin(1.0, pow((200.0 * (*abserr)/(*resasc)), 1.5));
+    }
+    if (*resabs > uflow/(50.0 * epmach))
+    {
+        *abserr = fmax(epmach * 50.0 * (*resabs),(*abserr));
+    }
+
+    return;
+}
+
+
+void
+dqk61(double(*fcn)(double* x), const double a, const double b,
+      double* result, double* abserr, double* resabs, double* resasc)
+{
+    // ***begin prologue  dqk61
+    // ***date written   800101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a1a2
+    // ***keywords  61-point gauss-kronrod rules
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  to compute i = integral of f over (a,b) with error
+    //                            estimate
+    //                        j = integral of dabs(f) over (a,b)
+    // ***description
+    //
+    //         integration rule
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //
+    //         parameters
+    //          on entry
+    //            f      - double precision
+    //                     function subprogram defining the integrand
+    //                     function f(x). the actual name for f needs to be
+    //                     declared e x t e r n a l in the calling program.
+    //
+    //            a      - double precision
+    //                     lower limit of integration
+    //
+    //            b      - double precision
+    //                     upper limit of integration
+    //
+    //          on return
+    //            result - double precision
+    //                     approximation to the integral i
+    //                     result is computed by applying the 61-point
+    //                     kronrod rule (resk) obtained by optimal addition of
+    //                     abscissae to the 30-point gauss rule (resg).
+    //
+    //            abserr - double precision
+    //                     estimate of the modulus of the absolute error,
+    //                     which should equal or exceed dabs(i-result)
+    //
+    //            resabs - double precision
+    //                     approximation to the integral j
+    //
+    //            resasc - double precision
+    //                     approximation to the integral of dabs(f-i/(b-a))
+    //
+    //
+    // ***references  (none)
+    // ***routines called  d1mach
+    // ***end prologue  dqk61
+    //
+    //            the abscissae and weights are given for the
+    //            interval (-1,1). because of symmetry only the positive
+    //            abscissae and their corresponding weights are given.
+    //
+    //            xgk   - abscissae of the 61-point kronrod rule
+    //                    xgk(2), xgk(4)  ... abscissae of the 30-point
+    //                    gauss rule
+    //                    xgk(1), xgk(3)  ... optimally added abscissae
+    //                    to the 30-point gauss rule
+    //
+    //            wgk   - weights of the 61-point kronrod rule
+    //
+    //            wg    - weigths of the 30-point gauss rule
+    //
+    //
+    //  gauss quadrature weights and kronron quadrature abscissae and weights
+    //  as evaluated with 80 decimal digit arithmetic by l. w. fullerton,
+    //  bell labs, nov. 1981.
+    //
+    int j, jtw, jtwm1;
+    double absc, centr, dhlgth, fc, fsum, fval1, fval2, hlgth, resg, resk, reskh;
+    double fv1[30], fv2[30];
+    double mut_D;
+
+    static const double wg[15] = {
+        0.007968192496166605615465883474674,
+        0.018466468311090959142302131912047,
+        0.028784707883323369349719179611292,
+        0.038799192569627049596801936446348,
+        0.048402672830594052902938140422808,
+        0.057493156217619066481721689402056,
+        0.065974229882180495128128515115962,
+        0.073755974737705206268243850022191,
+        0.080755895229420215354694938460530,
+        0.086899787201082979802387530715126,
+        0.092122522237786128717632707087619,
+        0.096368737174644259639468626351810,
+        0.099593420586795267062780282103569,
+        0.101762389748405504596428952168554,
+        0.102852652893558840341285636705415
+    };
+    static const double xgk[31] = {
+        0.999484410050490637571325895705811,
+        0.996893484074649540271630050918695,
+        0.991630996870404594858628366109486,
+        0.983668123279747209970032581605663,
+        0.973116322501126268374693868423707,
+        0.960021864968307512216871025581798,
+        0.944374444748559979415831324037439,
+        0.926200047429274325879324277080474,
+        0.905573307699907798546522558925958,
+        0.882560535792052681543116462530226,
+        0.857205233546061098958658510658944,
+        0.829565762382768397442898119732502,
+        0.799727835821839083013668942322683,
+        0.767777432104826194917977340974503,
+        0.733790062453226804726171131369528,
+        0.697850494793315796932292388026640,
+        0.660061064126626961370053668149271,
+        0.620526182989242861140477556431189,
+        0.579345235826361691756024932172540,
+        0.536624148142019899264169793311073,
+        0.492480467861778574993693061207709,
+        0.447033769538089176780609900322854,
+        0.400401254830394392535476211542661,
+        0.352704725530878113471037207089374,
+        0.304073202273625077372677107199257,
+        0.254636926167889846439805129817805,
+        0.204525116682309891438957671002025,
+        0.153869913608583546963794672743256,
+        0.102806937966737030147096751318001,
+        0.051471842555317695833025213166723,
+        0.000000000000000000000000000000000
+    };
+    static const double wgk[31] = {
+        0.001389013698677007624551591226760,
+        0.003890461127099884051267201844516,
+        0.006630703915931292173319826369750,
+        0.009273279659517763428441146892024,
+        0.011823015253496341742232898853251,
+        0.014369729507045804812451432443580,
+        0.016920889189053272627572289420322,
+        0.019414141193942381173408951050128,
+        0.021828035821609192297167485738339,
+        0.024191162078080601365686370725232,
+        0.026509954882333101610601709335075,
+        0.028754048765041292843978785354334,
+        0.030907257562387762472884252943092,
+        0.032981447057483726031814191016854,
+        0.034979338028060024137499670731468,
+        0.036882364651821229223911065617136,
+        0.038678945624727592950348651532281,
+        0.040374538951535959111995279752468,
+        0.041969810215164246147147541285970,
+        0.043452539701356069316831728117073,
+        0.044814800133162663192355551616723,
+        0.046059238271006988116271735559374,
+        0.047185546569299153945261478181099,
+        0.048185861757087129140779492298305,
+        0.049055434555029778887528165367238,
+        0.049795683427074206357811569379942,
+        0.050405921402782346840893085653585,
+        0.050881795898749606492297473049805,
+        0.051221547849258772170656282604944,
+        0.051426128537459025933862879215781,
+        0.051494729429451567558340433647099
+    };
+
+    centr = 0.5 * (a + b);
+    hlgth = 0.5 * (b - a);
+    dhlgth = fabs(hlgth);
+
+    // Compute the 61-point kronrod approximation to the integral, and
+    // estimate the absolute error.
+
+    fc=(*fcn)(&centr);
+    resg = 0.0;
+    resk = wgk[30] * fc;
+    *resabs = fabs(resk);
+
+    for (j = 0; j < 15; j++) {
+        jtw = 2 * j + 1;
+        absc = hlgth * xgk[jtw];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtw] = fval1;
+        fv2[jtw] = fval2;
+        fsum = fval1 + fval2;
+        resg = resg + wg[j] * fsum;
+        resk = resk + wgk[jtw] * fsum;
+        *resabs = *resabs + wgk[jtw] * (fabs(fval1) + fabs(fval2));
+    }
+    // 10
+
+    for (j = 0; j < 15; j++) {
+        jtwm1 = 2 * j;
+        absc = hlgth * xgk[jtwm1];
+
+        mut_D = centr - absc;
+        fval1 = (*fcn)(&mut_D);
+        mut_D = centr + absc;
+        fval2 = (*fcn)(&mut_D);
+
+        fv1[jtwm1] = fval1;
+        fv2[jtwm1] = fval2;
+        fsum = fval1 + fval2;
+        resk = resk + wgk[jtwm1] * fsum;
+        *resabs = *resabs + wgk[jtwm1] * (fabs(fval1) + fabs(fval2));
+    }
+    // 15
+
+    reskh = resk * 0.5;
+    *resasc = wgk[30] * fabs(fc - reskh);
+    for (j = 0; j < 30; j++ )
+    {
+        *resasc = *resasc + wgk[j] * (fabs(fv1[j] - reskh) + fabs(fv2[j] - reskh));
+    }
+    // 20
+
+    *result = resk * hlgth;
+    *resabs = (*resabs)*dhlgth;
+    *resasc = (*resasc)*dhlgth;
+    *abserr = fabs((resk - resg) * hlgth);
+
+    if ((*resasc != 0.0) && (*abserr != 0.0))
+    {
+        *abserr = (*resasc) * fmin(1.0, pow((200.0 * (*abserr)/(*resasc)), 1.5));
+    }
+    if (*resabs > uflow/(50.0 * epmach))
+    {
+        *abserr = fmax(epmach * 50.0 * (*resabs),(*abserr));
+    }
+
+    return;
+}
+
+
+void
+dqmomo(const double alfa, const double beta, double* ri, double* rj, double* rg,
+       double* rh, const int integr)
+{
+    // ***begin prologue  dqmomo
+    // ***date written   820101   (yymmdd)
+    // ***revision date  830518   (yymmdd)
+    // ***category no.  h2a2a1,c3a2
+    // ***keywords  modified chebyshev moments
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  this routine computes modified chebsyshev moments. the k-th
+    //             modified chebyshev moment is defined as the integral over
+    //             (-1,1) of w(x)*t(k,x), where t(k,x) is the chebyshev
+    //             polynomial of degree k.
+    // ***description
+    //
+    //         modified chebyshev moments
+    //         standard fortran subroutine
+    //         double precision version
+    //
+    //         parameters
+    //            alfa   - double precision
+    //                     parameter in the weight function w(x), alfa.gt.(-1)
+    //
+    //            beta   - double precision
+    //                     parameter in the weight function w(x), beta.gt.(-1)
+    //
+    //            ri     - double precision
+    //                     vector of dimension 25
+    //                     ri(k) is the integral over (-1,1) of
+    //                     (1+x)**alfa*t(k-1,x), k = 1, ..., 25.
+    //
+    //            rj     - double precision
+    //                     vector of dimension 25
+    //                     rj(k) is the integral over (-1,1) of
+    //                     (1-x)**beta*t(k-1,x), k = 1, ..., 25.
+    //
+    //            rg     - double precision
+    //                     vector of dimension 25
+    //                     rg(k) is the integral over (-1,1) of
+    //                     (1+x)**alfa*log((1+x)/2)*t(k-1,x), k = 1, ..., 25.
+    //
+    //            rh     - double precision
+    //                     vector of dimension 25
+    //                     rh(k) is the integral over (-1,1) of
+    //                     (1-x)**beta*log((1-x)/2)*t(k-1,x), k = 1, ..., 25.
+    //
+    //            integr - integer
+    //                     input parameter indicating the modified
+    //                     moments to be computed
+    //                     integr = 1 compute ri, rj
+    //                            = 2 compute ri, rj, rg
+    //                            = 3 compute ri, rj, rh
+    //                            = 4 compute ri, rj, rg, rh
+    //
+    // ***references  (none)
+    // ***routines called  (none)
+    // ***end prologue  dqmomo
+    //
+    int i;
+    double alfp1, an, betp1, alfp2, betp2, ralf, rbet;
+
+    alfp1 = alfa + 1.0;
+    betp1 = beta + 1.0;
+    alfp2 = alfa + 2.0;
+    betp2 = beta + 2.0;
+    ralf = pow(2.0, alfp1);
+    rbet = pow(2.0, betp1);
+
+    // Compute ri, rj using a forward recurrence relation.
+    ri[0] = ralf / alfp1;
+    rj[0] = rbet / betp1;
+    ri[1] = ri[0] * alfa / alfp2;
+    rj[1] = rj[0] * beta / betp2;
+
+    an = 2.0;
+    for (i = 2; i < 25; i++)
+    {
+        ri[i] = -(ralf + an*(an-alfp2)*ri[i-1])/((an - 1.0)*(an + alfp1));
+        rj[i] = -(rbet + an*(an-betp2)*rj[i-1])/((an - 1.0)*(an + betp1));
+        an = an + 1.0;
+    }
+    if (integr == 1)
+    {
+        for (i = 1; i < 25; i += 2){ rj[i] = -rj[i]; }
+        return;
+    }
+
+    if (integr != 3)
+    {
+        // integr 2 or 4
+        // Compute rg using a forware recurrence relation.
+        rg[0] = -ri[0] / alfp1;
+        rg[1] = -(ralf + ralf) / (alfp2 * alfp2) - rg[0];
+        an = 2.0;
+        for (i = 2; i < 25; i++)
+        {
+            rg[i] = -(an*(an - alfp2)*rg[i-1] - an*ri[i-1] + (an - 1.0)*ri[i]) / ((an - 1.0)*(an + alfp1));
+            an = an + 1.0;
+        }
+        if(integr == 2)
+        {
+            for (i = 1; i < 25; i += 2) { rj[i] = -rj[i]; }
+            return;
+        }
+    }
+    // 40
+
+    // Compute rh using a forward recurrence relation.
+    rh[0] = -rj[0] / betp1;
+    rh[1] = -(rbet + rbet) / (betp2 * betp2) - rh[0];
+    an = 2.0;
+    for (i = 2; i < 25; i++)
+    {
+        rh[i] = -(an*(an - betp2)*rh[i-1] - an*rj[i-1] + (an - 1.0)*rj[i]) / ((an - 1.0)*(an + betp1));
+        an = an + 1.0;
+    }
+    for (i = 1; i < 25; i += 2) { rh[i] = -rh[i]; }
+    // 60
+    for (i = 1; i < 25; i += 2) { rj[i] = -rj[i]; }
+    // 80
+
+    return;
+}
+
+
+void
+dqng(double(*fcn)(double* x), const double a, const double b,
+     const double epsabs, const double epsrel,
+     double* result, double* abserr, int* neval, int* ier)
+{
+    // ***begin prologue  dqng
+    // ***date written   800101   (yymmdd)
+    // ***revision date  810101   (yymmdd)
+    // ***category no.  h2a1a1
+    // ***keywords  automatic integrator, smooth integrand,
+    //              non-adaptive, gauss-kronrod(patterson)
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl math & progr. div. - k.u.leuven
+    //            kahaner,david,nbs - modified (2/82)
+    // ***purpose  the routine calculates an approximation result to a
+    //             given definite integral i = integral of f over (a,b),
+    //             hopefully satisfying following claim for accuracy
+    //             abs(i-result).le.max(epsabs,epsrel*abs(i)).
+    // ***description
+    //
+    //  non-adaptive integration
+    //  standard fortran subroutine
+    //  double precision version
+    //
+    //            f      - double precision
+    //                     function subprogram defining the integrand function
+    //                     f(x). the actual name for f needs to be declared
+    //                     e x t e r n a l in the driver program.
+    //
+    //            a      - double precision
+    //                     lower limit of integration
+    //
+    //            b      - double precision
+    //                     upper limit of integration
+    //
+    //            epsabs - double precision
+    //                     absolute accuracy requested
+    //            epsrel - double precision
+    //                     relative accuracy requested
+    //                     if  epsabs.le.0
+    //                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
+    //                     the routine will end with ier = 6.
+    //
+    //          on return
+    //            result - double precision
+    //                     approximation to the integral i
+    //                     result is obtained by applying the 21-point
+    //                     gauss-kronrod rule (res21) obtained by optimal
+    //                     addition of abscissae to the 10-point gauss rule
+    //                     (res10), or by applying the 43-point rule (res43)
+    //                     obtained by optimal addition of abscissae to the
+    //                     21-point gauss-kronrod rule, or by applying the
+    //                     87-point rule (res87) obtained by optimal addition
+    //                     of abscissae to the 43-point rule.
+    //
+    //            abserr - double precision
+    //                     estimate of the modulus of the absolute error,
+    //                     which should equal or exceed abs(i-result)
+    //
+    //            neval  - integer
+    //                     number of integrand evaluations
+    //
+    //            ier    - ier = 0 normal and reliable termination of the
+    //                             routine. it is assumed that the requested
+    //                             accuracy has been achieved.
+    //                     ier.gt.0 abnormal termination of the routine. it is
+    //                             assumed that the requested accuracy has
+    //                             not been achieved.
+    //            error messages
+    //                     ier = 1 the maximum number of steps has been
+    //                             executed. the integral is probably too
+    //                             difficult to be calculated by dqng.
+    //                         = 6 the input is invalid, because
+    //                             epsabs.le.0 and
+    //                             epsrel.lt.max(50*rel.mach.acc.,0.5d-28).
+    //                             result, abserr and neval are set to zero.
+    //
+    // ***references  (none)
+    // ***routines called  d1mach,xerror
+    // ***end prologue  dqng
+    //
+    //            the following data statements contain the
+    //            abscissae and weights of the integration rules used.
+    //
+    //            x1      abscissae common to the 10-, 21-, 43- and 87-
+    //                    point rule
+    //            x2      abscissae common to the 21-, 43- and 87-point rule
+    //            x3      abscissae common to the 43- and 87-point rule
+    //            x4      abscissae of the 87-point rule
+    //            w10     weights of the 10-point formula
+    //            w21a    weights of the 21-point formula for abscissae x1
+    //            w21b    weights of the 21-point formula for abscissae x2
+    //            w43a    weights of the 43-point formula for abscissae x1, x3
+    //            w43b    weights of the 43-point formula for abscissae x3
+    //            w87a    weights of the 87-point formula for abscissae x1,
+    //                    x2, x3
+    //            w87b    weights of the 87-point formula for abscissae x4
+    //
+    //
+    //  gauss-kronrod-patterson quadrature coefficients for use in
+    //  quadpack routine qng.  these coefficients were calculated with
+    //  101 decimal digit arithmetic by l. w. fullerton, bell labs, nov 1981.
+    //
+    int ipx, k, l;
+    double fv1[5], fv2[5], fv3[5], fv4[5], savfun[21];
+    double absc, centr, dhlgth, fcentr, fval, fval1, fval2, hlgth;
+    double res10,res21,res43,res87, resabs,resasc,reskh;
+
+    static const double x1[5] = {
+        0.973906528517171720077964012084452,
+        0.865063366688984510732096688423493,
+        0.679409568299024406234327365114874,
+        0.433395394129247190799265943165784,
+        0.148874338981631210884826001129720
+    };
+    static const double w10[5] = {
+        0.066671344308688137593568809893332,
+        0.149451349150580593145776339657697,
+        0.219086362515982043995534934228163,
+        0.269266719309996355091226921569469,
+        0.295524224714752870173892994651338
+    };
+    static const double x2[5] = {
+        0.995657163025808080735527280689003,
+        0.930157491355708226001207180059508,
+        0.780817726586416897063717578345042,
+        0.562757134668604683339000099272694,
+        0.294392862701460198131126603103866
+    };
+    static const double w21a[5] = {
+        0.032558162307964727478818972459390,
+        0.075039674810919952767043140916190,
+        0.109387158802297641899210590325805,
+        0.134709217311473325928054001771707,
+        0.147739104901338491374841515972068
+    };
+    static const double w21b[6] = {
+        0.011694638867371874278064396062192,
+        0.054755896574351996031381300244580,
+        0.093125454583697605535065465083366,
+        0.123491976262065851077958109831074,
+        0.142775938577060080797094273138717,
+        0.149445554002916905664936468389821
+    };
+    static const double x3[11] = {
+        0.999333360901932081394099323919911,
+        0.987433402908088869795961478381209,
+        0.954807934814266299257919200290473,
+        0.900148695748328293625099494069092,
+        0.825198314983114150847066732588520,
+        0.732148388989304982612354848755461,
+        0.622847970537725238641159120344323,
+        0.499479574071056499952214885499755,
+        0.364901661346580768043989548502644,
+        0.222254919776601296498260928066212,
+        0.074650617461383322043914435796506
+    };
+    static const double w43a[10] = {
+        0.016296734289666564924281974617663,
+        0.037522876120869501461613795898115,
+        0.054694902058255442147212685465005,
+        0.067355414609478086075553166302174,
+        0.073870199632393953432140695251367,
+        0.005768556059769796184184327908655,
+        0.027371890593248842081276069289151,
+        0.046560826910428830743339154433824,
+        0.061744995201442564496240336030883,
+        0.071387267268693397768559114425516
+    };
+    static const double w43b[12] = {
+        0.001844477640212414100389106552965,
+        0.010798689585891651740465406741293,
+        0.021895363867795428102523123075149,
+        0.032597463975345689443882222526137,
+        0.042163137935191811847627924327955,
+        0.050741939600184577780189020092084,
+        0.058379395542619248375475369330206,
+        0.064746404951445885544689259517511,
+        0.069566197912356484528633315038405,
+        0.072824441471833208150939535192842,
+        0.074507751014175118273571813842889,
+        0.074722147517403005594425168280423
+    };
+    static const double x4[22] = {
+        0.999902977262729234490529830591582,
+        0.997989895986678745427496322365960,
+        0.992175497860687222808523352251425,
+        0.981358163572712773571916941623894,
+        0.965057623858384619128284110607926,
+        0.943167613133670596816416634507426,
+        0.915806414685507209591826430720050,
+        0.883221657771316501372117548744163,
+        0.845710748462415666605902011504855,
+        0.803557658035230982788739474980964,
+        0.757005730685495558328942793432020,
+        0.706273209787321819824094274740840,
+        0.651589466501177922534422205016736,
+        0.593223374057961088875273770349144,
+        0.531493605970831932285268948562671,
+        0.466763623042022844871966781659270,
+        0.399424847859218804732101665817923,
+        0.329874877106188288265053371824597,
+        0.258503559202161551802280975429025,
+        0.185695396568346652015917141167606,
+        0.111842213179907468172398359241362,
+        0.037352123394619870814998165437704
+    };
+    static const double w87a[21] = {
+        0.008148377384149172900002878448190,
+        0.018761438201562822243935059003794,
+        0.027347451050052286161582829741283,
+        0.033677707311637930046581056957588,
+        0.036935099820427907614589586742499,
+        0.002884872430211530501334156248695,
+        0.013685946022712701888950035273128,
+        0.023280413502888311123409291030404,
+        0.030872497611713358675466394126442,
+        0.035693633639418770719351355457044,
+        0.000915283345202241360843392549948,
+        0.005399280219300471367738743391053,
+        0.010947679601118931134327826856808,
+        0.016298731696787335262665703223280,
+        0.021081568889203835112433060188190,
+        0.025370969769253827243467999831710,
+        0.029189697756475752501446154084920,
+        0.032373202467202789685788194889595,
+        0.034783098950365142750781997949596,
+        0.036412220731351787562801163687577,
+        0.037253875503047708539592001191226
+    };
+    static const double w87b[23] = {
+        0.000274145563762072350016527092881,
+        0.001807124155057942948341311753254,
+        0.004096869282759164864458070683480,
+        0.006758290051847378699816577897424,
+        0.009549957672201646536053581325377,
+        0.012329447652244853694626639963780,
+        0.015010447346388952376697286041943,
+        0.017548967986243191099665352925900,
+        0.019938037786440888202278192730714,
+        0.022194935961012286796332102959499,
+        0.024339147126000805470360647041454,
+        0.026374505414839207241503786552615,
+        0.028286910788771200659968002987960,
+        0.030052581128092695322521110347341,
+        0.031646751371439929404586051078883,
+        0.033050413419978503290785944862689,
+        0.034255099704226061787082821046821,
+        0.035262412660156681033782717998428,
+        0.036076989622888701185500318003895,
+        0.036698604498456094498018047441094,
+        0.037120549269832576114119958413599,
+        0.037334228751935040321235449094698,
+        0.037361073762679023410321241766599
+    };
+    double mut_D;
+    *result = 0.0;
+    *abserr = 0.0;
+    *neval = 0;
+    *ier = 6;
+    if ((epsabs <= 0.0) && (epsrel < fmax(50.0*epmach, 0.5e-28))) { return; }
+
+    hlgth = 0.5*(b - a);
+    dhlgth = fabs(hlgth);
+    centr = 0.5*(b + a);
+    fcentr = (*fcn)(&centr);
+    *neval = 21;
+    *ier = 1;
+
+    for (l = 1; l <=3; l++) {
+        switch (l) {
+            case 1:
+                // Compute the integral using the 10- and 21-point formula.
+
+                res10 = 0.0;
+                res21 = w21b[5] * fcentr;
+                resabs = w21b[5] * fabs(fcentr);
+                for (k = 0;k < 5; k++) {
+                    absc = hlgth * x1[k];
+
+                    mut_D = centr + absc;
+                    fval1 = (*fcn)(&mut_D);
+                    mut_D = centr - absc;
+                    fval2 = (*fcn)(&mut_D);
+
+                    fval = fval1 + fval2;
+                    res10 = res10 + w10[k] * fval;
+                    res21 = res21 + w21a[k] * fval;
+                    resabs = resabs + w21a[k] * (fabs(fval1) + fabs(fval2));
+                    savfun[k] = fval;
+                    fv1[k] = fval1;
+                    fv2[k] = fval2;
+                }
+                // 10
+                ipx = 4;
+                for (k = 0; k < 5; k++) {
+                    ipx++;
+                    absc = hlgth * x2[k];
+
+                    mut_D = centr + absc;
+                    fval1 = (*fcn)(&mut_D);
+                    mut_D = centr - absc;
+                    fval2 = (*fcn)(&mut_D);
+
+                    fval = fval1 + fval2;
+                    res21 = res21 + w21b[k] * fval;
+                    resabs = resabs + w21b[k] * (fabs(fval1) + fabs(fval2));
+                    savfun[ipx] = fval;
+                    fv3[k] = fval1;
+                    fv4[k] = fval2;
+                }
+                // 15
+
+                // Test for convergence.
+                *result = res21 * hlgth;
+                resabs = resabs*dhlgth;
+                reskh = 0.5 * res21;
+                resasc = w21b[5] * fabs(fcentr - reskh);
+                for (k = 0; k < 5; k++)
+                {
+                 resasc = resasc + w21a[k]*(fabs(fv1[k] -reskh) + fabs(fv2[k] - reskh))
+                           + w21b[k] * (fabs(fv3[k] - reskh) + fabs(fv4[k]-reskh));
+                }
+                *abserr = fabs((res21 - res10) * hlgth);
+                resasc = resasc*dhlgth;
+                break;
+            case 2:
+                // Compute the integral using the 43-point formula.
+
+                res43 = w43b[11] * fcentr;
+                *neval = 43;
+                for (k = 0; k < 10; k++)
+                {
+                 res43 = res43 + savfun[k] * w43a[k];
+                }
+                // 30
+                for (k = 0; k < 11; k++) {
+                    ipx++;
+                    absc = hlgth * x3[k];
+
+                    mut_D = centr + absc;
+                    fval1 = (*fcn)(&mut_D);
+                    mut_D = centr - absc;
+                    fval2 = (*fcn)(&mut_D);
+
+                    fval = fval1 + fval2;
+                    res43 = res43 + fval * w43b[k];
+                    savfun[ipx] = fval;
+                }
+                //40
+
+                // Test for convergence.
+                *result = res43 * hlgth;
+                *abserr = fabs((res43-res21) * hlgth);
+                break;
+            case 3:
+                // Compute the integral using the 87-point formula.
+
+                res87 = w87b[22] * fcentr;
+                *neval = 87;
+                for (k = 0; k < 21; k++)
+                {
+                    res87 = res87 + (savfun[k] * w87a[k]);
+                }
+                // 50
+                for (k = 0; k < 22; k++)
+                {
+                    absc = hlgth * x4[k];
+
+                    mut_D = centr + absc;
+                    fval1 = (*fcn)(&mut_D);
+                    mut_D = centr - absc;
+                    fval2 = (*fcn)(&mut_D);
+
+                    fval = fval1 + fval2;
+                    res87 = res87 + w87b[k] * fval;
+                }
+                // 60
+
+                // Test for convergence.
+                *result = res87 * hlgth;
+                *abserr = fabs((res87 - res43) * hlgth);
+                break;
+        }
+        // 65
+
+        if ((resasc != 0.0) && (*abserr != 0.0))
+        {
+            *abserr = resasc*fmin(1.0, pow(200.0*(*abserr)/resasc, 1.5));
+        }
+        if (resabs > uflow/(50.0 * epmach))
+        {
+            *abserr = fmax((epmach * 50.0) * resabs, *abserr);
+        }
+        if (*abserr <= fmax(epsabs, epsrel*fabs(*result))) {
+            *ier = 0;
+            break;
+        }
+    }
+    // 70
+
+    // 999
+    return;
+}
+
+
+void
+dqpsrt(const int limit, const int last, int* maxerr, double* ermax,
+       const double* elist, int *iord, int* nrmax)
+{
+    // ***begin prologue  dqpsrt
+    // ***refer to  dqage,dqagie,dqagpe,dqawse
+    // ***routines called  (none)
+    // ***revision date  810101   (yymmdd)
+    // ***keywords  sequential sorting
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  this routine maintains the descending ordering in the
+    //             list of the local error estimated resulting from the
+    //             interval subdivision process. at each call two error
+    //             estimates are inserted using the sequential search
+    //             method, top-down for the largest error estimate and
+    //             bottom-up for the smallest error estimate.
+    // ***description
+    //
+    //            ordering routine
+    //            standard fortran subroutine
+    //            double precision version
+    //
+    //            parameters (meaning at output)
+    //               limit  - integer
+    //                        maximum number of error estimates the list
+    //                        can contain
+    //
+    //               last   - integer
+    //                        number of error estimates currently in the list
+    //
+    //               maxerr - integer
+    //                        maxerr points to the nrmax-th largest error
+    //                        estimate currently in the list
+    //
+    //               ermax  - double precision
+    //                        nrmax-th largest error estimate
+    //                        ermax = elist(maxerr)
+    //
+    //               elist  - double precision
+    //                        vector of dimension last containing
+    //                        the error estimates
+    //
+    //               iord   - integer
+    //                        vector of dimension last, the first k elements
+    //                        of which contain pointers to the error
+    //                        estimates, such that
+    //                        elist(iord(1)),...,  elist(iord(k))
+    //                        form a decreasing sequence, with
+    //                        k = last if last.le.(limit/2+2), and
+    //                        k = limit+1-last otherwise
+    //
+    //               nrmax  - integer
+    //                        maxerr = iord(nrmax)
+    //
+    // ***end prologue  dqpsrt
+    //
+    int i, ibeg, j, jbnd, jupbn, k;
+    double errmin, errmax;
+    // Index vars maxerr, iord, nrmax
+
+    if (last <= 2)
+    {
+        iord[0] = 0;
+        iord[1] = 1;
+        *maxerr = iord[*nrmax];
+        *ermax = elist[*maxerr];
+        return;
+    }
+
+    // This part of the routine is only executed if, due to a difficult integrand,
+    // subdivision increased the error estimate. In the normal case the insert
+    // procedure should start after the nrmax-th largest error estimate.
+    errmax = elist[*maxerr];
+    while ((*nrmax > 0) && (errmax > elist[iord[*nrmax-1]]))
+    {
+        iord[*nrmax] = iord[*nrmax - 1];
+        *nrmax -= 1;
+    }
+
+    // Compute the number of elements in the list to be maintained
+    // in descending order. this number depends on the number of
+    // subdivisions still allowed.
+    jupbn = (last > limit/2 + 2 ? limit - last + 2 : last - 1);
+    errmin = elist[last - 1];
+
+    // insert errmax by traversing the list top-down,
+    // starting comparison from the element elist(iord(nrmax+1)).
+    jbnd = jupbn-1;
+    ibeg = *nrmax + 1;
+
+    if (ibeg <= jbnd)
+    {
+        for (i = ibeg; i <= jbnd; i++)
+        {
+            if (errmax >= elist[iord[i]]) { goto LINE60; }
+            iord[i-1] = iord[i];
+        }
+        // 40
+    }
+    // 50
+    iord[jbnd] = *maxerr;
+    iord[jupbn] = last-1;
+    *maxerr = iord[*nrmax];
+    *ermax = elist[*maxerr];
+    return;
+LINE60:
+    // 60
+    // Insert errmin by traversing the list bottom-up
+    iord[i-1] = *maxerr;
+    k = jbnd;
+    for (j = i; j <= jbnd; j++)
+    {
+        if (errmin < elist[iord[k]]) { break; }
+        iord[k+1] = iord[k];
+        k--;
+    }
+    //70
+
+    if (errmin < elist[iord[k]])
+    {
+        iord[k+1] = last-1;
+    } else {
+        iord[i] = last-1;
+    }
+
+    *maxerr = iord[*nrmax];
+    *ermax = elist[*maxerr];
+
+    return;
+}
+
+
+double
+dqwgtc(const double x, const double c, const double p2, const double p3, const double p4, const int integr)
+{
+    // ***begin prologue  dqwgtc
+    // ***refer to dqk15w
+    // ***routines called  (none)
+    // ***revision date  810101   (yymmdd)
+    // ***keywords  weight function, cauchy principal value
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  this function subprogram is used together with the
+    //             routine qawc and defines the weight function.
+    // ***end prologue  dqwgtc
+    //
+    return 1.0 / (x - c);
+}
+
+
+double
+dqwgtf(const double x, const double omega, const double p2, const double p3, const double p4, const int integr)
+{
+    // ***begin prologue  dqwgtf
+    // ***refer to   dqk15w
+    // ***routines called  (none)
+    // ***revision date 810101   (yymmdd)
+    // ***keywords  cos or sin in weight function
+    // ***author  piessens,robert, appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. * progr. div. - k.u.leuven
+    // ***end prologue  dqwgtf
+    //
+    double omx = omega * x;
+    if (integr == 1)
+        return cos(omx);
+    else
+        return sin(omx);
+}
+
+
+double
+dqwgts(const double x, const double a, const double b, const double alfa, const double beta, const int integr)
+{
+    // ***begin prologue  dqwgts
+    // ***refer to dqk15w
+    // ***routines called  (none)
+    // ***revision date  810101   (yymmdd)
+    // ***keywords  weight function, algebraico-logarithmic
+    //              end-point singularities
+    // ***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
+    //            de doncker,elise,appl. math. & progr. div. - k.u.leuven
+    // ***purpose  this function subprogram is used together with the
+    //             routine dqaws and defines the weight function.
+    // ***end prologue  dqwgts
+    //
+    double xma = x - a;
+    double bmx = b - x;
+    double ret = pow(xma, alfa)*pow(bmx, beta);
+    switch (integr)
+    {
+        case 1:
+            break;
+        case 2:
+            ret = ret*log(xma);
+            break;
+        case 3:
+            ret = ret*log(bmx);
+            break;
+        case 4:
+            ret = ret*log(xma)*log(bmx);
+        default:
+            break;
+    }
+    return ret;
+}
Index: scipy/scipy/integrate/__quadpack.h
===================================================================
--- scipy.orig/scipy/integrate/__quadpack.h	2024-08-11 19:01:43.865849459 +0200
+++ scipy/scipy/integrate/__quadpack.h	2024-08-11 19:01:43.861849413 +0200
@@ -1,58 +1,10 @@
-/* This file should be included in the _multipackmodule file */
-/* $Revision$ */
-/* module_methods:
-  {"_qagse", quadpack_qagse, METH_VARARGS, doc_qagse},
-  {"_qagie", quadpack_qagie, METH_VARARGS, doc_qagie},
-  {"_qagpe", quadpack_qagpe, METH_VARARGS, doc_qagpe},
-  {"_qawoe", quadpack_qawoe, METH_VARARGS, doc_qawoe},
-  {"_qawfe", quadpack_qawfe, METH_VARARGS, doc_qawfe},
-  {"_qawse", quadpack_qawse, METH_VARARGS, doc_qawse},
-  {"_qawce", quadpack_qawce, METH_VARARGS, doc_qawce},
- */
-/* link libraries: (should be listed in separate lines)
-   quadpack
-   linpack_lite
-   blas
-   mach
- */
-/* Python files: (to be imported to Multipack.py)
-   quadpack.py
- */
-
-
 #include <Python.h>
 #include <setjmp.h>
-
 #include "ccallback.h"
-
 #include "numpy/arrayobject.h"
 
-#ifdef HAVE_BLAS_ILP64
-
-#define F_INT npy_int64
-#define F_INT_NPY NPY_INT64
-
-#if NPY_BITSOF_SHORT == 64
-#define F_INT_PYFMT   "h"
-#elif NPY_BITSOF_INT == 64
-#define F_INT_PYFMT   "i"
-#elif NPY_BITSOF_LONG == 64
-#define F_INT_PYFMT   "l"
-#elif NPY_BITSOF_LONGLONG == 64
-#define F_INT_PYFMT   "L"
-#else
-#error No compatible 64-bit integer size. \
-       Please contact NumPy maintainers and give detailed information about your \
-       compiler and platform, or set NPY_USE_BLAS64_=0
-#endif
-
-#else
 
 #define F_INT int
-#define F_INT_NPY NPY_INT
-#define F_INT_PYFMT   "i"
-
-#endif
 
 #define PYERR(errobj,message) {PyErr_SetString(errobj,message); goto fail;}
 #define PYERR2(errobj,message) {PyErr_Print(); PyErr_SetString(errobj, message); goto fail;}
@@ -60,67 +12,44 @@
 
 static PyObject *quadpack_error;
 
-
-#if defined(NO_APPEND_FORTRAN)
-  #if defined(UPPERCASE_FORTRAN)
-  /* nothing to do here */
-  #else
-    #define DQAGSE dqagse
-    #define DQAGIE dqagie
-    #define DQAGPE dqagpe
-    #define DQAWOE dqawoe
-    #define DQAWFE dqawfe
-    #define DQAWSE dqawse
-    #define DQAWCE dqawce
-  #endif
-#else
-  #if defined(UPPERCASE_FORTRAN)
-    #define DQAGSE DQAGSE_
-    #define DQAGIE DQAGIE_
-    #define DQAGPE DQAGPE_
-    #define DQAWOE DQAWOE_
-    #define DQAWFE DQAWFE_
-    #define DQAWSE DQAWSE_
-    #define DQAWCE DQAWCE_
-#else
-    #define DQAGSE dqagse_
-    #define DQAGIE dqagie_
-    #define DQAGPE dqagpe_
-    #define DQAWOE dqawoe_
-    #define DQAWFE dqawfe_
-    #define DQAWSE dqawse_
-    #define DQAWCE dqawce_
-  #endif
-#endif
-
- 
-typedef double quadpack_f_t(double *);
-
-void DQAGSE(quadpack_f_t f, double *a, double *b, double *epsabs, double *epsrel, F_INT *limit, double *result,
-            double *abserr, F_INT *neval, F_INT *ier, double *alist, double *blist, double *rlist, double *elist,
-            F_INT *iord, F_INT *last);
-void DQAGIE(quadpack_f_t f, double *bound, F_INT *inf, double *epsabs, double *epsrel, F_INT *limit,
-            double *result, double *abserr, F_INT *neval, F_INT *ier, double *alist, double *blist,
-            double *rlist, double *elist, F_INT *iord, F_INT *last);
-void DQAGPE(quadpack_f_t f, double *a, double *b, F_INT *npts2, double *points, double *epsabs,
-            double *epsrel, F_INT *limit, double *result, double *abserr, F_INT *neval, F_INT *ier,
-            double *alist, double *blist, double *rlist, double *elist, double *pts, F_INT *iord,
-            F_INT *level, F_INT *ndin, F_INT *last);
-void DQAWOE(quadpack_f_t f, double *a, double *b, double *omega, F_INT *integr, double *epsabs, double *epsrel,
-            F_INT *limit, F_INT *icall,  F_INT *maxp1, double *result, double *abserr, F_INT *neval,
-            F_INT *ier, F_INT *last, double *alist, double *blist, double *rlist, double *elist,
-            F_INT *iord,  F_INT *nnlog, F_INT *momcom, double *chebmo);
-void DQAWFE(quadpack_f_t f, double *a, double *omega, F_INT *integr, double *epsabs, F_INT *limlst,
-            F_INT *limit, F_INT *maxp1, double *result, double *abserr, F_INT *neval, F_INT *ier,
-            double *rslst, double *erlst, F_INT *ierlst, F_INT *lst, double *alist, double *blist,
-            double *rlist, double *elist, F_INT *iord, F_INT *nnlog, double *chebmo);
-void DQAWSE(quadpack_f_t f, double *a, double *b, double *alfa, double *beta, F_INT *integr, double *epsabs,
-            double *epsrel, F_INT *limit, double *result, double *abserr, F_INT *neval, F_INT *ier,
-            double *alist, double *blist, double *rlist, double *elist, F_INT *iord, F_INT *last);
-void DQAWCE(quadpack_f_t f, double *a, double *b, double *c, double *epsabs, double *epsrel, F_INT *limit,
-            double *result, double *abserr, F_INT *neval, F_INT *ier, double *alist, double *blist,
-            double *rlist, double *elist, F_INT *iord, F_INT *last);
-
+void dqagie(double(*fcn)(double* x), const double bound, const int inf,
+            const double epsabs, const double epsrel, const int limit, double* result,
+            double* abserr, int* neval, int* ier, double* alist, double* blist,
+            double* rlist, double* elist, int* iord, int* last);
+
+void dqagpe(double(*fcn)(double* x), const double a, const double b, int npts2,
+            double* points, const double epsabs, const double epsrel, const int limit,
+            double* result, double* abserr, int* neval, int* ier, double* alist,
+            double* blist, double* rlist, double* elist, double* pts, int* level,
+            int* ndin, int* iord, int* last);
+
+void dqagse(double(*fcn)(double* x), const double a, const double b,
+            const double epsabs, const double epsrel, const int limit, double* result,
+            double* abserr, int* neval, int* ier, double* alist, double* blist,
+            double* rlist, double* elist, int* iord, int* last);
+
+void dqawce(double(*fcn)(double* x), const double a, const double b, const double c,
+            const double epsabs, const double epsrel, const int limit, double* result,
+            double* abserr, int* neval, int* ier, double* alist, double* blist,
+            double* rlist, double* elist, int* iord, int* last);
+
+void dqawfe(double(*fcn)(double* x), const double a, const double omega, const int integr,
+            const double epsabs, const int limlst, const int limit, const int maxp1,
+            double* result, double* abserr, int* neval, int* ier, double* rslst,
+            double* erlst, int* ierlst, int* lst, double* alist, double* blist,
+            double* rlist, double* elist, int* iord, int* nnlog, double* chebmo);
+
+void dqawoe(double(*fcn)(double* x), const double a, const double b, const double omega,
+            const int integr, const double epsabs, const double epsrel, const int limit,
+            const int icall, const int maxp1, double* result, double* abserr, int* neval,
+            int* ier, int* last, double* alist, double* blist, double* rlist,
+            double* elist, int* iord, int* nnlog, int* momcom, double* chebmo);
+
+void dqawse(double(*fcn)(double* x), const double a, const double b, const double alfa,
+            const double beta, const int integr, const double epsabs, const double epsrel,
+            const int limit, double* result, double* abserr, int* neval, int* ier,
+            double* alist, double* blist, double* rlist, double* elist, int* iord,
+            int* last);
 
 typedef enum {
     CB_1D_USER = 0,
@@ -381,12 +310,12 @@
   int      ret;
   ccallback_t callback;
 
-  if (!PyArg_ParseTuple(args, ("Odd|Oidd" F_INT_PYFMT), &fcn, &a, &b, &extra_args, &full_output, &epsabs, &epsrel, &limit)) return NULL;
+  if (!PyArg_ParseTuple(args, ("Odd|Oiddi"), &fcn, &a, &b, &extra_args, &full_output, &epsabs, &epsrel, &limit)) return NULL;
   limit_shape[0] = limit;
 
   /* Need to check that limit is greater than 1 */
   if (limit < 1)
-      return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+      return Py_BuildValue(("ddi"),result,abserr,ier);
 
   ret = init_callback(&callback, fcn, extra_args);
   if (ret == -1) {
@@ -394,7 +323,7 @@
   }
 
   /* Set up iwork and work arrays */
-  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
+  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
   ap_alist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_blist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_rlist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
@@ -410,15 +339,14 @@
       goto fail;
   }
 
-  DQAGSE(quad_thunk, &a, &b, &epsabs, &epsrel, &limit, &result, &abserr, &neval, &ier, alist,
-         blist, rlist, elist, iord, &last);
+  dqagse(quad_thunk, a, b, epsabs, epsrel, limit, &result, &abserr, &neval, &ier, alist, blist, rlist, elist, iord, &last);
 
   if (free_callback(&callback) != 0) {
       goto fail_free;
   }
 
   if (full_output) {
-      return Py_BuildValue(("dd{s:" F_INT_PYFMT ",s:" F_INT_PYFMT ",s:N,s:N,s:N,s:N,s:N}" F_INT_PYFMT), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist),ier);
+      return Py_BuildValue(("dd{s:i,s:i,s:N,s:N,s:N,s:N,s:N}i"), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist),ier);
   }
   else {
     Py_DECREF(ap_alist);
@@ -426,7 +354,7 @@
     Py_DECREF(ap_rlist);
     Py_DECREF(ap_elist);
     Py_DECREF(ap_iord);
-    return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+    return Py_BuildValue(("ddi"),result,abserr,ier);
   }
 
  fail:
@@ -461,14 +389,14 @@
   int ret;
   ccallback_t callback;
 
-  if (!PyArg_ParseTuple(args, ("Od" F_INT_PYFMT "|Oidd" F_INT_PYFMT), &fcn, &bound, &inf, &extra_args,
+  if (!PyArg_ParseTuple(args, ("Odi|Oiddi"), &fcn, &bound, &inf, &extra_args,
                         &full_output, &epsabs, &epsrel, &limit))
     return NULL;
   limit_shape[0] = limit;
 
   /* Need to check that limit is greater than 1 */
   if (limit < 1)
-      return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+      return Py_BuildValue(("ddi"),result,abserr,ier);
 
   ret = init_callback(&callback, fcn, extra_args);
   if (ret == -1) {
@@ -476,7 +404,7 @@
   }
 
   /* Set up iwork and work arrays */
-  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
+  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
   ap_alist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_blist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_rlist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
@@ -493,14 +421,14 @@
       goto fail;
   }
 
-  DQAGIE(quad_thunk, &bound, &inf, &epsabs, &epsrel, &limit, &result, &abserr, &neval, &ier, alist, blist, rlist, elist, iord, &last);
+  dqagie(quad_thunk, bound, inf, epsabs, epsrel, limit, &result, &abserr, &neval, &ier, alist, blist, rlist, elist, iord, &last);
 
   if (free_callback(&callback) != 0) {
       goto fail_free;
   }
 
   if (full_output) {
-      return Py_BuildValue(("dd{s:" F_INT_PYFMT ",s:" F_INT_PYFMT ",s:N,s:N,s:N,s:N,s:N}" F_INT_PYFMT), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist),ier);
+      return Py_BuildValue(("dd{s:i,s:i,s:N,s:N,s:N,s:N,s:N}i"), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist),ier);
   }
   else {
     Py_DECREF(ap_alist);
@@ -508,7 +436,7 @@
     Py_DECREF(ap_rlist);
     Py_DECREF(ap_elist);
     Py_DECREF(ap_iord);
-    return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+    return Py_BuildValue(("ddi"),result,abserr,ier);
   }
 
  fail:
@@ -548,12 +476,12 @@
   int ret;
   ccallback_t callback;
 
-  if (!PyArg_ParseTuple(args, ("OddO|Oidd" F_INT_PYFMT), &fcn, &a, &b, &o_points, &extra_args, &full_output, &epsabs, &epsrel, &limit)) return NULL;
+  if (!PyArg_ParseTuple(args, ("OddO|Oiddi"), &fcn, &a, &b, &o_points, &extra_args, &full_output, &epsabs, &epsrel, &limit)) return NULL;
   limit_shape[0] = limit;
 
   /* Need to check that limit is greater than 1 */
   if (limit < 1)
-      return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+      return Py_BuildValue(("ddi"),result,abserr,ier);
 
   ret = init_callback(&callback, fcn, extra_args);
   if (ret == -1) {
@@ -567,14 +495,14 @@
   points = (double *)PyArray_DATA(ap_points);
 
   /* Set up iwork and work arrays */
-  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
+  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
   ap_alist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_blist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_rlist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_elist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_pts = (PyArrayObject *)PyArray_SimpleNew(1,npts2_shape,NPY_DOUBLE);
-  ap_level = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
-  ap_ndin = (PyArrayObject *)PyArray_SimpleNew(1,npts2_shape,F_INT_NPY);
+  ap_level = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
+  ap_ndin = (PyArrayObject *)PyArray_SimpleNew(1,npts2_shape,NPY_INT);
   if (ap_iord == NULL || ap_alist == NULL || ap_blist == NULL || ap_rlist == NULL || ap_elist == NULL || ap_pts == NULL || ap_level == NULL || ap_ndin == NULL) goto fail;
   iord = (F_INT *)PyArray_DATA(ap_iord);
   alist = (double *)PyArray_DATA(ap_alist);
@@ -589,7 +517,7 @@
       goto fail;
   }
 
-  DQAGPE(quad_thunk, &a, &b, &npts2, points, &epsabs, &epsrel, &limit, &result, &abserr, &neval, &ier, alist, blist, rlist, elist, pts, iord, level, ndin, &last);
+  dqagpe(quad_thunk, a, b, npts2, points, epsabs, epsrel, limit, &result, &abserr, &neval, &ier, alist, blist, rlist, elist, pts, iord, level, ndin, &last);
 
   if (free_callback(&callback) != 0) {
       goto fail_free;
@@ -598,7 +526,7 @@
   Py_DECREF(ap_points);
 
   if (full_output) {
-      return Py_BuildValue(("dd{s:" F_INT_PYFMT ",s:" F_INT_PYFMT ",s:N,s:N,s:N,s:N,s:N,s:N,s:N,s:N}" F_INT_PYFMT), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist), "pts", PyArray_Return(ap_pts), "level", PyArray_Return(ap_level), "ndin", PyArray_Return(ap_ndin),ier);
+      return Py_BuildValue(("dd{s:i,s:i,s:N,s:N,s:N,s:N,s:N,s:N,s:N,s:N}i"), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist), "pts", PyArray_Return(ap_pts), "level", PyArray_Return(ap_level), "ndin", PyArray_Return(ap_ndin),ier);
   }
   else {
     Py_DECREF(ap_alist);
@@ -609,7 +537,7 @@
     Py_DECREF(ap_iord);
     Py_DECREF(ap_ndin);
     Py_DECREF(ap_level);
-    return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+    return Py_BuildValue(("ddi"),result,abserr,ier);
   }
 
  fail:
@@ -654,14 +582,13 @@
   ccallback_t callback;
 
   if (!PyArg_ParseTuple(args,
-                        ("Oddd" F_INT_PYFMT "|Oidd" F_INT_PYFMT
-                         F_INT_PYFMT F_INT_PYFMT F_INT_PYFMT "O"),
+                        ("Odddi|OiddiiiiO"),
                         &fcn, &a, &b, &omega, &integr, &extra_args, &full_output, &epsabs, &epsrel, &limit, &maxp1, &icall, &momcom, &o_chebmo)) return NULL;
   limit_shape[0] = limit;
 
   /* Need to check that limit is greater than 1 */
   if (limit < 1)
-      return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+      return Py_BuildValue(("ddi"),result,abserr,ier);
 
   ret = init_callback(&callback, fcn, extra_args);
   if (ret == -1) {
@@ -683,8 +610,8 @@
   chebmo = (double *) PyArray_DATA(ap_chebmo);
 
   /* Set up iwork and work arrays */
-  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
-  ap_nnlog = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
+  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
+  ap_nnlog = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
   ap_alist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_blist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_rlist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
@@ -701,14 +628,14 @@
       goto fail;
   }
 
-  DQAWOE(quad_thunk, &a, &b, &omega, &integr, &epsabs, &epsrel, &limit, &icall, &maxp1, &result, &abserr, &neval, &ier, &last, alist, blist, rlist, elist, iord, nnlog, &momcom, chebmo);
+  dqawoe(quad_thunk, a, b, omega, integr, epsabs, epsrel, limit, icall, maxp1, &result, &abserr, &neval, &ier, &last, alist, blist, rlist, elist, iord, nnlog, &momcom, chebmo);
 
   if (free_callback(&callback) != 0) {
       goto fail_free;
   }
 
   if (full_output) {
-      return Py_BuildValue(("dd{s:" F_INT_PYFMT ",s:" F_INT_PYFMT ",s:N,s:N,s:N,s:N,s:N,s:N,s:" F_INT_PYFMT ",s:N}" F_INT_PYFMT ""), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist), "nnlog", PyArray_Return(ap_nnlog), "momcom", momcom, "chebmo", PyArray_Return(ap_chebmo),ier);
+      return Py_BuildValue(("dd{s:i,s:i,s:N,s:N,s:N,s:N,s:N,s:N,s:i,s:N}i"), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist), "nnlog", PyArray_Return(ap_nnlog), "momcom", momcom, "chebmo", PyArray_Return(ap_chebmo),ier);
   }
   else {
     Py_DECREF(ap_alist);
@@ -718,7 +645,7 @@
     Py_DECREF(ap_iord);
     Py_DECREF(ap_nnlog);
     Py_DECREF(ap_chebmo);
-    return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+    return Py_BuildValue(("ddi"),result,abserr,ier);
   }
 
  fail:
@@ -762,15 +689,14 @@
   ccallback_t callback;
 
   if (!PyArg_ParseTuple(args,
-                        ("Odd" F_INT_PYFMT "|Oid" F_INT_PYFMT
-                         F_INT_PYFMT F_INT_PYFMT),
+                        ("Oddi|Oidiii"),
                         &fcn, &a, &omega, &integr, &extra_args, &full_output, &epsabs, &limlst, &limit, &maxp1)) return NULL;
   limit_shape[0] = limit;
   limlst_shape[0] = limlst;
 
   /* Need to check that limit is greater than 1 */
   if (limit < 1)
-      return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+      return Py_BuildValue(("ddi"),result,abserr,ier);
 
   ret = init_callback(&callback, fcn, extra_args);
   if (ret == -1) {
@@ -784,15 +710,15 @@
   chebmo = (double *) PyArray_DATA(ap_chebmo);
 
   /* Set up iwork and work arrays */
-  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
-  ap_nnlog = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
+  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
+  ap_nnlog = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
   ap_alist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_blist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_rlist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_elist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_rslst = (PyArrayObject *)PyArray_SimpleNew(1,limlst_shape,NPY_DOUBLE);
   ap_erlst = (PyArrayObject *)PyArray_SimpleNew(1,limlst_shape,NPY_DOUBLE);
-  ap_ierlst = (PyArrayObject *)PyArray_SimpleNew(1,limlst_shape,F_INT_NPY);
+  ap_ierlst = (PyArrayObject *)PyArray_SimpleNew(1,limlst_shape,NPY_INT);
   if (ap_iord == NULL || ap_nnlog == NULL || ap_alist == NULL || ap_blist == NULL || ap_rlist == NULL || ap_elist == NULL || ap_rslst == NULL || ap_erlst == NULL || ap_ierlst == NULL) goto fail;
   iord = (F_INT *)PyArray_DATA(ap_iord);
   nnlog = (F_INT *)PyArray_DATA(ap_nnlog);
@@ -808,7 +734,7 @@
       goto fail;
   }
 
-  DQAWFE(quad_thunk, &a, &omega, &integr, &epsabs, &limlst, &limit, &maxp1, &result, &abserr, &neval, &ier, rslst, erlst, ierlst, &lst, alist, blist, rlist, elist, iord, nnlog, chebmo);
+  dqawfe(quad_thunk, a, omega, integr, epsabs, limlst, limit, maxp1, &result, &abserr, &neval, &ier, rslst, erlst, ierlst, &lst, alist, blist, rlist, elist, iord, nnlog, chebmo);
 
   if (free_callback(&callback) != 0) {
       goto fail_free;
@@ -823,13 +749,13 @@
   Py_DECREF(ap_chebmo);
 
   if (full_output) {
-      return Py_BuildValue(("dd{s:" F_INT_PYFMT ",s:" F_INT_PYFMT ",s:N,s:N,s:N}" F_INT_PYFMT), result, abserr, "neval", neval, "lst", lst, "rslst", PyArray_Return(ap_rslst), "erlst", PyArray_Return(ap_erlst), "ierlst", PyArray_Return(ap_ierlst), ier);
+      return Py_BuildValue(("dd{s:i,s:i,s:N,s:N,s:N}i"), result, abserr, "neval", neval, "lst", lst, "rslst", PyArray_Return(ap_rslst), "erlst", PyArray_Return(ap_erlst), "ierlst", PyArray_Return(ap_ierlst), ier);
   }
   else {
     Py_DECREF(ap_rslst);
     Py_DECREF(ap_erlst);
     Py_DECREF(ap_ierlst);
-    return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+    return Py_BuildValue(("ddi"),result,abserr,ier);
   }
 
  fail:
@@ -870,12 +796,12 @@
   int ret;
   ccallback_t callback;
 
-  if (!PyArg_ParseTuple(args, ("Oddd|Oidd" F_INT_PYFMT), &fcn, &a, &b, &c, &extra_args, &full_output, &epsabs, &epsrel, &limit)) return NULL;
+  if (!PyArg_ParseTuple(args, ("Oddd|Oiddi"), &fcn, &a, &b, &c, &extra_args, &full_output, &epsabs, &epsrel, &limit)) return NULL;
   limit_shape[0] = limit;
 
   /* Need to check that limit is greater than 1 */
   if (limit < 1)
-      return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+      return Py_BuildValue(("ddi"),result,abserr,ier);
 
   ret = init_callback(&callback, fcn, extra_args);
   if (ret == -1) {
@@ -883,7 +809,7 @@
   }
 
   /* Set up iwork and work arrays */
-  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
+  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
   ap_alist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_blist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_rlist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
@@ -899,14 +825,14 @@
       goto fail;
   }
 
-  DQAWCE(quad_thunk, &a, &b, &c, &epsabs, &epsrel, &limit, &result, &abserr, &neval, &ier, alist, blist, rlist, elist, iord, &last);
+  dqawce(quad_thunk, a, b, c, epsabs, epsrel, limit, &result, &abserr, &neval, &ier, alist, blist, rlist, elist, iord, &last);
 
   if (free_callback(&callback) != 0) {
       goto fail_free;
   }
 
   if (full_output) {
-      return Py_BuildValue(("dd{s:" F_INT_PYFMT ",s:" F_INT_PYFMT ",s:N,s:N,s:N,s:N,s:N}" F_INT_PYFMT), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist),ier);
+      return Py_BuildValue(("dd{s:i,s:i,s:N,s:N,s:N,s:N,s:N}i"), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist),ier);
   }
   else {
     Py_DECREF(ap_alist);
@@ -914,7 +840,7 @@
     Py_DECREF(ap_rlist);
     Py_DECREF(ap_elist);
     Py_DECREF(ap_iord);
-    return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+    return Py_BuildValue(("ddi"),result,abserr,ier);
   }
 
  fail:
@@ -952,13 +878,13 @@
   int ret;
   ccallback_t callback;
 
-  if (!PyArg_ParseTuple(args, ("Odd(dd)" F_INT_PYFMT "|Oidd" F_INT_PYFMT),
+  if (!PyArg_ParseTuple(args, ("Odd(dd)i|Oiddi"),
                         &fcn, &a, &b, &alfa, &beta, &integr, &extra_args, &full_output, &epsabs, &epsrel, &limit)) return NULL;
   limit_shape[0] = limit;
 
   /* Need to check that limit is greater than 1 */
   if (limit < 1)
-      return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+      return Py_BuildValue(("ddi"),result,abserr,ier);
 
   ret = init_callback(&callback, fcn, extra_args);
   if (ret == -1) {
@@ -966,7 +892,7 @@
   }
 
   /* Set up iwork and work arrays */
-  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,F_INT_NPY);
+  ap_iord = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_INT);
   ap_alist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_blist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
   ap_rlist = (PyArrayObject *)PyArray_SimpleNew(1,limit_shape,NPY_DOUBLE);
@@ -982,14 +908,14 @@
       goto fail;
   }
 
-  DQAWSE(quad_thunk, &a, &b, &alfa, &beta, &integr, &epsabs, &epsrel, &limit, &result, &abserr, &neval, &ier, alist, blist, rlist, elist, iord, &last);
+  dqawse(quad_thunk, a, b, alfa, beta, integr, epsabs, epsrel, limit, &result, &abserr, &neval, &ier, alist, blist, rlist, elist, iord, &last);
 
   if (free_callback(&callback) != 0) {
       goto fail_free;
   }
 
   if (full_output) {
-      return Py_BuildValue(("dd{s:" F_INT_PYFMT ",s:" F_INT_PYFMT ",s:N,s:N,s:N,s:N,s:N}" F_INT_PYFMT), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist),ier);
+      return Py_BuildValue(("dd{s:i,s:i,s:N,s:N,s:N,s:N,s:N}i"), result, abserr, "neval", neval, "last", last, "iord", PyArray_Return(ap_iord), "alist", PyArray_Return(ap_alist), "blist", PyArray_Return(ap_blist), "rlist", PyArray_Return(ap_rlist), "elist", PyArray_Return(ap_elist),ier);
   }
   else {
     Py_DECREF(ap_alist);
@@ -997,7 +923,7 @@
     Py_DECREF(ap_rlist);
     Py_DECREF(ap_elist);
     Py_DECREF(ap_iord);
-    return Py_BuildValue(("dd" F_INT_PYFMT),result,abserr,ier);
+    return Py_BuildValue(("ddi"),result,abserr,ier);
   }
 
  fail:
@@ -1010,3 +936,60 @@
   Py_XDECREF(ap_iord);
   return NULL;
 }
+
+
+
+static struct PyMethodDef quadpack_module_methods[] = {
+  {"_qagse", quadpack_qagse, METH_VARARGS, doc_qagse},
+  {"_qagie", quadpack_qagie, METH_VARARGS, doc_qagie},
+  {"_qagpe", quadpack_qagpe, METH_VARARGS, doc_qagpe},
+  {"_qawoe", quadpack_qawoe, METH_VARARGS, doc_qawoe},
+  {"_qawfe", quadpack_qawfe, METH_VARARGS, doc_qawfe},
+  {"_qawse", quadpack_qawse, METH_VARARGS, doc_qawse},
+  {"_qawce", quadpack_qawce, METH_VARARGS, doc_qawce},
+  {NULL    , NULL          , 0           , NULL     }
+};
+
+static struct PyModuleDef moduledef = {
+    PyModuleDef_HEAD_INIT,
+    "_quadpack",
+    NULL,
+    -1,
+    quadpack_module_methods,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+
+PyMODINIT_FUNC
+PyInit__quadpack(void)
+{
+    PyObject *module, *mdict;
+
+    import_array();
+
+    module = PyModule_Create(&moduledef);
+    if (module == NULL) {
+        return NULL;
+    }
+
+    mdict = PyModule_GetDict(module);
+    if (mdict == NULL) {
+        return NULL;
+    }
+
+    quadpack_error = PyErr_NewException ("_quadpack.error", NULL, NULL);
+    if (quadpack_error == NULL) {
+        return NULL;
+    }
+    if (PyDict_SetItemString(mdict, "error", quadpack_error)) {
+        return NULL;
+    }
+
+#if Py_GIL_DISABLED
+    PyUnstable_Module_SetGIL(module, Py_MOD_GIL_NOT_USED);
+#endif
+
+    return module;
+}
